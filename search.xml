<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>知乎：昆虫为什么不会因趋光性齐刷刷地奔向太阳？</title>
      <link href="2021/06/25/0-wang-luo-wen-zhang-fen-xiang/zhi-hu-kun-chong-wei-shi-me-bu-hui-yin-qu-guang-xing-qi-shua-shua-di-ben-xiang-tai-yang/"/>
      <url>2021/06/25/0-wang-luo-wen-zhang-fen-xiang/zhi-hu-kun-chong-wei-shi-me-bu-hui-yin-qu-guang-xing-qi-shua-shua-di-ben-xiang-tai-yang/</url>
      
        <content type="html"><![CDATA[<p>我们对昆虫的趋光性有的时候是误读！特别是飞蛾扑火，我们以为是昆虫喜欢追逐光明，其实这是数千年的误解。<strong>黑夜里，飞蛾不能看清四周的情况，在找不到合适参照物的情况下，如何不走冤枉路，多快好省的飞行呢？</strong>其实亿万年来，夜晚活动的蛾子等昆虫都是靠月光和星光来导航。因为是极远光源，光到了地面可以看成平行光，能作为参照来做直线飞行。如下图所示，注意蛾子只要按照固定夹角飞行，就可以飞成直线，<strong>直飞才最节省力气</strong>。角度稍微一调整，就可以直飞另一个目标。</p><p><img src="/2021/06/25/0-wang-luo-wen-zhang-fen-xiang/zhi-hu-kun-chong-wei-shi-me-bu-hui-yin-qu-guang-xing-qi-shua-shua-di-ben-xiang-tai-yang/1.png"></p><p>但自从该死的人类学会了使用火，这些人造光源因为很近，光线成中心放射线状，可怜的蛾子就开始倒霉了。</p><p><img src="/2021/06/25/0-wang-luo-wen-zhang-fen-xiang/zhi-hu-kun-chong-wei-shi-me-bu-hui-yin-qu-guang-xing-qi-shua-shua-di-ben-xiang-tai-yang/2.jpg"></p><p>蛾子还以为按照与光线的固定夹角飞行就是直线运动，结果越飞越坑爹，飞成了等角螺线，飞到火里去了，这种现象还被人类称为昆虫的正趋光性。蛾子说：<br>趋你妹的光啊，傻瓜才瞪着光飞，不知道会亮瞎眼啊？！！<br>我们完全被人类误导了，亿万年才演化出的精妙直线导航方法，被人类的光污染干扰失效了！<br>不用假慈悲的飞蛾扑火纱罩灯了！<br>(#‵′)凸，赶紧把这幺蛾子的灯关了吧！<br>有人问：这是你自己想出来的吧？我还是坚持蛾子是趋光的！<br>好吧，如果蛾子趋光，为什么不直线飞过去呢？为什么要飞成下面的螺线？趋光能解释吗？</p><p><img src="/2021/06/25/0-wang-luo-wen-zhang-fen-xiang/zhi-hu-kun-chong-wei-shi-me-bu-hui-yin-qu-guang-xing-qi-shua-shua-di-ben-xiang-tai-yang/3.jpg"></p><p>从上面这个照片你还可以看出，蛾子走的并不是理想的等角螺线。<br>蛾子也发现问题了：<br>我飞飞飞<br>咦……不对啊！<br>调正角度，飞飞飞……<br>我去！还不对，我这是在往哪飞啊？<br>继续调整角度……<br>我去……我去……我……我晕……蛾子也想挣扎的飞出正确的路线，不断的调整角度，奈何本能使然，最终还是向灯光飞去。<br>我们人类也是，例如你在原地旋转很多圈，再让你走直线试试。在平衡器官被干扰的情况下，你以为是直线，而在旁人看来更像喝醉了一样东倒西歪乱走。<br>这就是蛾子的处境。</p>]]></content>
      
      
      <categories>
          
          <category> 网络文章分享 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>知乎：你有什么能讲一年的笑话？</title>
      <link href="2021/06/25/0-wang-luo-wen-zhang-fen-xiang/zhi-hu-ni-you-shi-me-neng-jiang-yi-nian-de-xiao-hua/"/>
      <url>2021/06/25/0-wang-luo-wen-zhang-fen-xiang/zhi-hu-ni-you-shi-me-neng-jiang-yi-nian-de-xiao-hua/</url>
      
        <content type="html"><![CDATA[<p>主持人：请说出同一偏旁四个不同字。</p><p>普通青年：江河湖海。</p><p>文艺青年：琴瑟琵琶。</p><p>抬杠青年：魑魅魍魉。</p><p>单身青年：撸打挊揉。</p><p>出柜青年：涂润滑油。</p>]]></content>
      
      
      <categories>
          
          <category> 网络文章分享 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>知乎：有哪些只有美国人才能听懂的笑话?</title>
      <link href="2021/06/25/0-wang-luo-wen-zhang-fen-xiang/zhi-hu-you-na-xie-zhi-you-mei-guo-ren-cai-neng-ting-dong-de-xiao-hua/"/>
      <url>2021/06/25/0-wang-luo-wen-zhang-fen-xiang/zhi-hu-you-na-xie-zhi-you-mei-guo-ren-cai-neng-ting-dong-de-xiao-hua/</url>
      
        <content type="html"><![CDATA[<ol><li><p>“你们美国黑人帮派里面为什么都有一个白人成员？”</p><p>“总要有人负责跟警察交涉吧” </p></li></ol><ol start="2"><li><p>“你不能堕胎，这是谋杀”</p><p>“我可以干掉任何一个闯入我家的混蛋，这是美国法律赋予我的权利”</p></li></ol><ol start="3"><li>“你们白人头发有金色的红色的，眼珠有棕色的蓝色的，我们黑人头发眼珠皮肤都是黑色的，即使这样，你们还叫我们有色人种”</li></ol><ol start="4"><li><p>“黑人是纯种美国人吗”</p><p>“当然不是，他们是非洲来的”</p><p>“那印第安人算是纯种美国人吗”</p><p>“当然不是，他们是原住民”</p></li></ol><ol start="5"><li>怎么到10了？9呢，seven ate nine</li></ol><ol start="6"><li><p>”我们黑人同胞只能生活在犯罪恶极高的贫困街区，这是对我们极大的歧视和不公平“</p><p>”黑人社区犯罪率极高，说句实话，这是我们歧视他们最大的原因“</p></li></ol><ol start="7"><li><p>“你们白人在美国享有太多的特权，我们黑人有什么特权，什么也没有”</p><p>”你们也有特权，只有你们可以说那个N开头的单词“</p></li></ol><ol start="8"><li><p>“我们美国白人不欢迎你们黑人，拉丁人，亚洲人，犹太人，你们来到这里还是吃你们自己的食物，说你们自己的语言，过你们自己的习俗，这是对我们当地人最大的不尊重”</p><p>“现在你能理解印第安人的想法了？”</p></li></ol><ol start="9"><li><p>“总统快下命令吧，只要在日本投下原子弹我们就能很快结束战争了”</p><p>“日本普通人民是无辜的阿”</p><p>“为了拯救更多的无辜百姓，这是最快的办法”</p><p>“好吧”</p><p>“卡，总统先生都录好了”</p><p>“他妈的快点把这段录音放出去，把原子弹都准备好，炸死那帮龟孙子”</p></li></ol><ol start="10"><li><p>“神父，我该怎么做，只要我一声令下敌国将会有数以万计的人死在轰炸下”</p><p>“孩子，记住，对敌人宽容一点，对自己残酷一些，还有一点更重要：时刻站在对方角度思考问题”</p></li></ol><ol start="11"><li><p>“我们美国有一个自杀专线，这个热线专用于开导想不开的人，你们中东这里有吗”</p><p>“有的，我们不叫自杀专线，我们叫炸弹自杀袭击招聘中心”</p></li></ol><ol start="12"><li><p>“美国的女权主义者为什么总是喜欢关着灯做爱？”</p><p>“因为她们见不得男人高兴。”</p></li></ol><ol start="13"><li>去年这个黑人社区百分之30的枪击事件起因是因为毒品交易，百分之70是因为新买的乔丹鞋被踩</li></ol><ol start="14"><li>“我是一个来自中国的留学生，昨天我刚下飞机深深的吸了一口新鲜的空气，然后扔掉了我5个口罩，穿上5件防弹衣”</li></ol><ol start="15"><li><p>“总统先生，因为上周黑人被警察打死的新闻，全国爆发了黑人大游行，我们该如何应对”</p><p>“还是用老办法吧，通知nike快点发布新球鞋上市”</p></li></ol><hr><p>作者：毛毛的万圣节<br>链接：<a href="https://www.zhihu.com/question/283914760/answer/447691165">https://www.zhihu.com/question/283914760/answer/447691165</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 网络文章分享 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>知乎：为什么不从小就向孩子还原社会的残酷？</title>
      <link href="2021/06/25/0-wang-luo-wen-zhang-fen-xiang/zhi-hu-wei-shi-me-bu-cong-xiao-jiu-xiang-hai-zi-huan-yuan-she-hui-de-can-ku/"/>
      <url>2021/06/25/0-wang-luo-wen-zhang-fen-xiang/zhi-hu-wei-shi-me-bu-cong-xiao-jiu-xiang-hai-zi-huan-yuan-she-hui-de-can-ku/</url>
      
        <content type="html"><![CDATA[<p>尼采有句话，是这个问题的最好答案：</p><p><strong>He who has a why to live can bear almost any how</strong></p><p>无论面对什么样的困难，比克服困难的技能更重要的，是克服困难的动机。只要内心的火焰没有熄灭，哪怕寒风再凛烈，活着也是一件温暖的事情。幼年乃至童年教育所要做的，就是点燃孩子内心的火焰。教他们爱，教他们人生的美好，教他们希望，教他们世上各种知识的有趣。当他们拥有了对生命发自内心的热爱之后，再残酷的社会，也打不垮他们。</p><p>如果不热爱生命，既然人生这么残酷，还活着干什么呢？</p><p>我特别喜欢伯利克里在雅典阵亡将士葬礼上的演说：</p><blockquote><p>我们不花费时间来训练自己忍受那些尚未到来的痛苦，但是当我们真的遇到痛苦的时候，我们表现出我们自己正和那些经常受到严格训练的人一样勇敢。</p></blockquote><p>那么，为什么雅典人不像斯巴达人那样从小经受严酷的军事训练，却可以做到同样的勇敢？伯利克里认为，那是因为雅典是一个伟大的城邦，雅典人发自内心的热爱它：</p><blockquote><p>我们爱好美丽，但是没有因此而变得奢侈；我们爱好智慧，但是没有因此而变得柔弱。我们把财富当作可以适当利用的东西，而没有把它当作可以夸耀自己的本钱。至于贫穷，谁也不必以承认自己的贫穷为耻，真正的耻辱是为避免贫穷而不择手段。……</p><p>​      再者，在关于友谊的问题上……我们是独特的。当我们真正给予他人以恩惠时，我们不是因为考虑我们的得失才这样做的，而是由于我们的慷慨，我们不会因为这样做而后悔。因此，如果把一切都联系起来考虑的话，我可以断言，我们的城邦是全希腊的学校……</p><p><strong>这就是这些烈士为它慷慨而战、慷慨而死的一个城邦，因为他们只要想到丧失了这个城邦，就会不寒而栗。</strong></p></blockquote><p>给孩子一个热爱生命的理由吧。</p><hr><p>作者：莫名<br>链接：<a href="https://www.zhihu.com/question/21603465/answer/20787627">https://www.zhihu.com/question/21603465/answer/20787627</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 网络文章分享 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>知乎：有哪些让人深思的故事？</title>
      <link href="2021/06/25/0-wang-luo-wen-zhang-fen-xiang/zhi-hu-you-na-xie-rang-ren-shen-si-de-gu-shi/"/>
      <url>2021/06/25/0-wang-luo-wen-zhang-fen-xiang/zhi-hu-you-na-xie-rang-ren-shen-si-de-gu-shi/</url>
      
        <content type="html"><![CDATA[<p>一只兔子在山洞口写论文。</p><p>一只狐狸走过来，问：“兔子，你在干什么啊？”<br>兔子回答：“我在写论文。”<br>狐狸：“什么论文？”<br>兔子：“为什么兔子比狐狸更强大。”<br>狐狸听了捧着肚子大笑：“你，，你居然说你比我更强大。”<br>兔子不动神色：“你不信？那你跟我来，我证明给你看。”<br>狐狸跟着兔子走进了山洞，过了一会，兔子出来了，狐狸再也没出来。</p><p>兔子继续在山洞口写论文。<br>一只狼走过来，问：“兔子，你在干什么啊？”<br>兔子回答：“我在写论文。”<br>狼：“什么论文？”<br>兔子：“为什么兔子比狼更强大。”<br>狼听了也是捧着肚子大笑：“你，，你居然说你比我更强大。”<br>兔子不动神色：“你不信？那你跟我来，我证明给你看。”<br>狼跟着兔子走进了山洞，过了一会，兔子出来了，狼再也没出来。</p><p>兔子继续在山洞口写论文。<br>一只猎豹走过来，问：“兔子，你在干什么啊？”<br>兔子回答：“我在写论文。”<br>猎豹：“什么论文？”<br>兔子：“为什么兔子比猎豹更强大。”<br>猎豹听了也是捧着肚子大笑：“你，，你居然说你比我更强大。”<br>兔子不动神色：“你不信？那你跟我来，我证明给你看。”<br>猎豹跟着兔子走进了山洞。<br>到了山洞深处，只见里面卧着一只狮子，旁边还有刚刚吃剩的狐狸和狼的残骸。</p><hr><p>这个故事告诉我们，你是谁并不重要，你的论文题目是什么也不重要，最重要的是，你的导师是谁。</p><p>PS：转帖非原创，作者不知，最早见于18年前某报纸。</p>]]></content>
      
      
      <categories>
          
          <category> 网络文章分享 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>知乎：你在什么时候突然有了扎心的感觉？</title>
      <link href="2021/06/24/0-wang-luo-wen-zhang-fen-xiang/zhi-hu-ni-zai-shi-me-shi-hou-tu-ran-you-liao-zha-xin-de-gan-jue/"/>
      <url>2021/06/24/0-wang-luo-wen-zhang-fen-xiang/zhi-hu-ni-zai-shi-me-shi-hou-tu-ran-you-liao-zha-xin-de-gan-jue/</url>
      
        <content type="html"><![CDATA[<p>有这样一个姑娘，长得挺好看，嘴巴却特别毒。</p><p>曾经我问她：有一天要是我赚不到钱了，你会不会离开我？</p><p>她几乎是秒答：当然了，你不知道老子就是喜欢有钱人哦。</p><p>事实上有段时间我确实很穷，穷到房租都付不起快过年了也买不起羽绒服，在家就是静音模式出门就变成震动模式，浑身抖的像个西山猴子。</p><p>她非但没离开我，还把攒了很久的钱都拿出来，给我垫房租买衣服带我去吃饭，在商场买衣服时我有点感动握着她的手：大侠，滴水之恩当涌泉相报，今晚让我帮你捶腿吧。</p><p>她甩开我的手厌恶的说：都穷成这个德行了你怎么还好意思酸呢？</p><p>我也问过她：有一天要是我不会写东西了，你会不会离开我？</p><p>她头都没抬起来：废话，你除了这点还有什么优势？</p><p>后来我沉迷于玩游戏喝酒，年初签了两本书，到了年底一个字都没写出来，编辑每次见到我都恨不得拿把枪把我突突了。</p><p>她不仅没有离开我，还每天晚上陪我在电脑前发呆，有时候实在闷了她就跳起来拍拍我肩膀：走吧，看你这德行真的是江郎才尽了，我们去看看电影想想后路吧，我跟着你算是瞎了眼。</p><p>我也问过她：有一天我出轨了，你会不会离开我？</p><p>她冷酷一笑：你把我想成什么人了，我是那种小气的女人吗？老子肯定要先阉了你咯。</p><p>我吓得背上满是冷汗，识相的闭了嘴。</p><p>所以说不要随便立什么flag，过了一个星期在街上真的被她给逮到了，某个女同学结婚后被老公家暴，不知道怎么想起我来，拉我去饭店吃饭在我肩膀边哭的一把鼻涕一把泪，我正在道德的高压线上徘徊时，她突然出现了。</p><p>她瞪大眼睛打量我们半晌，然后揪起我的耳朵就骂：老子没带钥匙在屋外吹了半小时风，你居然在这里安慰风流少妇，你还是个人吗？</p><p>我疼的大叫，心里却很幸福。</p><p>还有一次，我还问过这样一句话：要是有一天我得了大病，你应该会离开我吧？</p><p>这次她倒是回答的很慢，大眼睛转啊转的，像是突然想到了什么突然跳起来双手抱胸：你他妈是不是又出去乱搞了，晚上滚出去睡。</p><p>虽然她满是嫌弃，但我抑郁发作整夜整夜失眠的时候，她连班都不上了呆在家里陪我，早上的时候会偷偷在卫生间哭泣，但出来的时候露出的是笑脸。两个月过去了，我瘦了十斤，她瘦了十二斤，她还自我调侃：挺好啊，比健身有用多了。</p><p>亲爱的姑娘，经历过这些以后，我觉得以后你再也不会离开我。</p><p>我不再问这些无聊的问题，只想安静温和的和你走完余生。</p><p>我怎么也不会想到，你怎么会这么突然的离开。</p><p>又过了一段时间，我决定要给她一个承诺，于是把她带回了家见见父母，她特别紧张在网上买了好多衣服，早上起床后精心的化妆，我拿钥匙开门的时候她的手都在抖。我知道她紧张什么，她出身于一个离异家庭，家里还有弟弟妹妹要养，负担要比一般人要重，而且她做的工作也不算太体面，这些都是她担忧的因素。</p><p>饭吃的很开心，这是我第一次带女孩回家，爸妈都表现的很开心。吃完饭洗碗的时候我妈突然把我拉到厨房，小声的说：这个女孩你认识多久了？</p><p>我说：很久了。</p><p>我妈用过来人的语气劝我：你要好好考虑清楚，她家的情况确实太复杂了，要是结婚的话你以后负担肯定会很大，到时候两个人肯定会有很多矛盾，谈恋爱和成家是两件事，你可得想清楚。</p><p>我忍不住大声反驳：这些算什么，我多赚点钱不就成了，您别管我的事！</p><p>我妈叹了口气，她知道她拗不过我。</p><p>出门的时候，她突然给我妈鞠了一躬，这行为有点郑重而反常，我妈连忙拉着她的手笑着说下次再过来吃饭。</p><p>第二天，她就突然离开了，回到了自己的家乡，冷酷到连个招呼都没打。</p><p>我从来没有这么慌张过，每隔三分钟给她打一个电话，像疯了一样问她的朋友，还买了午夜去成都的飞机票。</p><p>亲爱的姑娘，你不能这样。</p><p>亲爱的姑娘，你可感到明天已经来临？</p><p>码头上停着我们的船，我会洗干净头发爬上桅杆，撑起我们葡萄枝嫩叶般的家。</p><p>我赶去机场的时候，她的电话才打过来，她的声音很疲倦：刘兮，我们分手吧。</p><p>我说：不分，你想得美，就算分手也得当面说。</p><p>她故作冷酷的说：你别来找我了，其实我早就受够你了，你贪玩任性又没有责任感，我们不会有未来的。</p><p>我大声说：不是这样的，不是这样的……，你到底为什么要和我分手？</p><p>沉默了一分钟，她哽咽的开口：为了你好。</p><p>我终于明白了，我和我妈的窃窃私语被她听到了，她本就敏感而脆弱，我明白了她昨天离开时的反常表现。</p><p><strong>我终于明白，她也是会离开我的。</strong></p><p><strong>当她把最好的都给了我，当她没有什么可以再给我时，她就会选择离开。</strong></p><p>我说了句等着我就挂了电话，结果在去机场的路上遇到大拥堵，我急的暴跳如雷，也没能及时的赶上飞机，我又买了一张最近的航班，结果又因为天气原因延误了，我失落的蹲在安检门口的凳子边，看到旁边一对小情侣在拥抱，他们紧紧拥抱轻吻，好像要抓住每一秒相聚的时光。</p><p>原来机场比婚礼的殿堂见证了更多真诚的吻,而医院的墙比教堂听到了更多的祈祷。</p><p>女孩终于要登机了，过安检的时候她突然扭过脸笑着对男孩说：放心啦，我不会离开你的。</p><p>那一秒钟我痛彻心扉，以前觉得矫情的眼泪，也忍不住夺眶而出。</p><hr><p>作者：Seasee Youl<br>链接：<a href="https://www.zhihu.com/question/61228610/answer/282199758">https://www.zhihu.com/question/61228610/answer/282199758</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 网络文章分享 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>知乎：哪些短篇科幻小说让你震惊且念念不忘？</title>
      <link href="2021/06/24/0-wang-luo-wen-zhang-fen-xiang/zhi-hu-na-xie-duan-pian-ke-huan-xiao-shuo-rang-ni-zhen-liang-qie-nian-nian-bu-wang/"/>
      <url>2021/06/24/0-wang-luo-wen-zhang-fen-xiang/zhi-hu-na-xie-duan-pian-ke-huan-xiao-shuo-rang-ni-zhen-liang-qie-nian-nian-bu-wang/</url>
      
        <content type="html"><![CDATA[<p>这是我看过的最为“现实”的科幻小说。</p><p>故事的讲述者是主角的儿子，他的父亲是一个顶级富豪。</p><p>父亲给儿子一直以来的印象都是一个十分理性的人，直到最近。</p><p>他的父亲最近发现自己得了癌症，而且进入了晚期，癌细胞已经扩散到了全身。</p><p>但父亲疯狂的想要为自己延续生命，甚至异想天开的<strong>想要将自己的大脑移至到一个健康的身体上</strong>，全然不顾这种移脑手术从未有任何医生在人身上实施过。</p><p>但没有什么是钱办不到的。</p><p>富豪很快找到了愿意为他实施手术的医生，甚至找到了愿意献出身体的“捐赠者”。</p><p>“捐赠者”倒不是真的同意让富豪的脑子雀占鸠巢，但他的确没有反对这件事——他是个全脑死亡的植物人，连呼吸跟心跳都需要机器帮助才能完成。收下巨款后签署协议的是他那早已无法继续支付医疗费用的家人。</p><p>所有一切似乎已经是箭在弦上不得不发了，<strong>但一个记者不知道怎么挖到了这个猛料，第二天，一篇《顶级富豪用金钱购买植物人性命》的通稿就传遍了全国。</strong></p><p>舆论自然不可能站在富豪这边。</p><p>正义的民众自发的组织了捐款，“捐赠者”的家庭收到钱后也退出了原有的协议。</p><p>更是有检察官直接将富豪告上了法庭，<strong>认为他这种行为与谋杀无异</strong>。</p><p>一大群精英律师极为熟练的站到了公众的对立面。但他们的工作也没有那么简单。</p><p>其实要帮富豪脱罪并不困难，但此时的富豪哪里关心自己是否要去蹲大狱呢？</p><p>他的诉求是让法庭承认自己之前跟“捐赠者”家庭签署的协议合法，让自己的换脑手术可以继续进行。</p><p>律师们看在钱的面子上，还是为富豪制订了诉讼计划。</p><p>他们的辩护策略是：<strong>一个已经全脑死亡的人，应该被认定为已经死亡。连呼吸跟心跳都需要靠机器维持的“活着”，是人活着还是机器活着？</strong>如果修改了法律对于死亡的判定标准，那么富豪的行为就是接受遗体捐赠。</p><p>当所有人都认为这种言论不过是于事无补的狡辩时，又一个消息被捅了出来：<strong>居然真的有国会议员提案修改法律对于一个人死亡的界定！</strong></p><p>这件案子逐渐变得越来越大，代表的意义也越来越严肃：<strong>这俨然已经成为了社会公良与资本的力量的对抗了。</strong></p><p>最终，这件案子被摆到了最高院的桌子上，经过五位大法官一致决定之后，认为<strong>哪怕依赖机器，哪怕残缺，一个人只要一部分仍具备生物活性，也算依然活着，不可被作为逝者对待</strong>。</p><p>这个判决将作为案例，直接成为法律。富豪连合法找下一个“捐赠者”的机会都没有了。</p><p>漫长的诉讼耗尽了富豪最后的生命能量，没多久就去世了。</p><p>作为富豪的儿子，父亲的过世自然带来了悲伤，但他明白自己接下来的一段时间也将面对几近无穷的法律文书。</p><p>但律师们却为他带来了一个小型培养皿，培养皿里是看不出任何形状的肉块。</p><p><strong>培养皿里装的是死去的富豪的癌细胞。只要有培养液继续维持，他们可以无限的分裂下去。而依据最新的立法，富豪将被认定为活着。</strong></p><p>律师说道这里，儿子也已明白了这是什么意思。</p><p><strong>这意味着他们家再也不用交一分钱遗产税。而与遗产税相比，富豪死前最后一段时间的疯狂完全是九牛一毛。</strong></p><p>原来这一切都是富豪计划好的，原来他的父亲一直都是那么理性的一个人。</p><hr><p>作者：幼发拉底河<br>链接：<a href="https://www.zhihu.com/question/41047159/answer/293072078">https://www.zhihu.com/question/41047159/answer/293072078</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 网络文章分享 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>知乎：你见过哪些父母惊艳到你的教育方式？</title>
      <link href="2021/06/24/0-wang-luo-wen-zhang-fen-xiang/zhi-hu-ni-jian-guo-na-xie-fu-mu-liang-yan-dao-ni-de-jiao-yu-fang-shi/"/>
      <url>2021/06/24/0-wang-luo-wen-zhang-fen-xiang/zhi-hu-ni-jian-guo-na-xie-fu-mu-liang-yan-dao-ni-de-jiao-yu-fang-shi/</url>
      
        <content type="html"><![CDATA[<p>班里一个女生家里穷，但长得好看，被同校一个混混缠上了，后来纠缠中被教导主任发现，便把两人都训了一顿。</p><p>女生性子直，宁死不认错误，相反男生却知道这种事就坡下驴就好，结果女生被请家长。</p><p>女生父亲来了，她父亲是个憨厚的人，大家都知道主任在欺负人，但是万万没想到这个大叔也耿直，死活不认为是女生的错。</p><p>教导主任便说出了一句我听了无数遍的话：</p><blockquote><p>一个巴掌拍不响。<br>他为什么不找别人？</p></blockquote><p>据回来说当时情景的班主任回忆，女生的父亲想反驳这句话，但嘴巴笨，支支吾吾说不出来，教导主任露出了满意的微笑，突然女生的父亲仿佛下了一个艰难的决定。</p><p>他打了那个混混一个耳光，不知哪里来的勇气问：</p><blockquote><p>你说，响不响？</p></blockquote><p>那个男生当时就蒙了，大家都蒙了，之后再也没人敢欺负这个女生了。</p><p>以往我总怵一个巴掌拍不响这句话，因为我不知道怎么自证清白，我不知道我也不用自证清白。</p><p>但她父亲这一巴掌惊醒了我，原来这个局可以这么破。</p><p>一旦知道这个道理，便再也不会陷入受害者也有错需要自责的圈套了。</p><p>我们这前段时间发生了女孩自杀跳楼，原因就是大家都觉得一个巴掌拍不响。</p><p>教导主任，老师，同学，校长，甚至父母都觉得一个巴掌拍不响。</p><p>女孩子不知道怎么解释，其实她不需要解释，可是她郁结于心，最终选择了自杀。</p><p>下次再听到一个巴掌拍不响这种话，请给一个漂亮的回复。</p><p>对方定会对你刮目相看。</p><hr><p>作者：我是一只小萌刀<br>链接：<a href="https://www.zhihu.com/question/264918610/answer/428768644">https://www.zhihu.com/question/264918610/answer/428768644</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 网络文章分享 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>知乎：有哪些瞬间会让你觉得对方情商高？</title>
      <link href="2021/06/24/0-wang-luo-wen-zhang-fen-xiang/zhi-hu-you-na-xie-shun-jian-hui-rang-ni-jue-de-dui-fang-qing-shang-gao/"/>
      <url>2021/06/24/0-wang-luo-wen-zhang-fen-xiang/zhi-hu-you-na-xie-shun-jian-hui-rang-ni-jue-de-dui-fang-qing-shang-gao/</url>
      
        <content type="html"><![CDATA[<p>刚开始来上海那阵儿，很屌丝，经常给领导开车。。。</p><p>有一次，半路被一个交警给拦了下来，那小伙子对着我就问了一句话，“先生，您是对上海市委市政府不满吗？”</p><p>我一脸懵逼，“没啊没啊！”</p><p>交警说，“那你大白天的开远光灯干嘛，是嫌世道太黑？！”</p><p>我赶紧关了远光灯！！！</p><p><img src="/2021/06/24/0-wang-luo-wen-zhang-fen-xiang/zhi-hu-you-na-xie-shun-jian-hui-rang-ni-jue-de-dui-fang-qing-shang-gao/1.jpg"></p><p>这情商，当交警太屈才了，我觉得他以后至少也会干到交通局局长。。。</p><hr><p>作者：我最帅<br>链接：<a href="https://www.zhihu.com/question/61978045/answer/369488554">https://www.zhihu.com/question/61978045/answer/369488554</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 网络文章分享 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java学习笔记2</title>
      <link href="2021/06/21/java-xue-xi-bi-ji-2/"/>
      <url>2021/06/21/java-xue-xi-bi-ji-2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面经</title>
      <link href="2021/06/16/mian-jing/"/>
      <url>2021/06/16/mian-jing/</url>
      
        <content type="html"><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h3 id="C-的三大特性"><a href="#C-的三大特性" class="headerlink" title="C++ 的三大特性"></a>C++ 的三大特性</h3><hr><p><strong>封装性</strong>：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。 类将成员变量和成员函数封装在类的内部，根据需要设置访问权限，通过成员函数管理内部状态。</p><p><strong>继承</strong>：继承所表达的是类之间相关的关系，这种关系使得对象可以继承另外一类对象的特征和能力。 继承的作用：避免公用代码的重复开发，减少代码和数据冗余。</p><p><strong>多态</strong>：多态性可以简单地概括为“一个接口，多种方法”，字面意思为多种形态。程序在运行时才决定调用的函数，它是面向对象编程领域的核心概念。比如函数重载、运算符重载、虚函数等。</p><blockquote><p><strong>面对对象的程序设计有4大特性：分别是，抽象、封装、继承、多态。</strong></p></blockquote><h3 id="什么是多态"><a href="#什么是多态" class="headerlink" title="什么是多态?"></a>什么是多态?</h3><hr><p>同一操作作用于不同的对象，可以产生不同的效果。</p><h3 id="虚函数的实现原理"><a href="#虚函数的实现原理" class="headerlink" title="虚函数的实现原理"></a>虚函数的实现原理</h3><hr><p>C++ 通过<strong>虚函数表</strong>和<strong>虚函数表指针</strong>来实现虚函数机制</p><h3 id="所有函数都可以是虚函数吗？"><a href="#所有函数都可以是虚函数吗？" class="headerlink" title="所有函数都可以是虚函数吗？"></a>所有函数都可以是虚函数吗？</h3><hr><p>不是. static函数就不可以是虚函数，因为static定义的函数不属于任何类实例，与虚函数表无关</p><h3 id="构造函数可以是虚函数吗？"><a href="#构造函数可以是虚函数吗？" class="headerlink" title="构造函数可以是虚函数吗？"></a>构造函数可以是虚函数吗？</h3><hr><p>不可以</p><h3 id="析构函数可以是虚函数吗？"><a href="#析构函数可以是虚函数吗？" class="headerlink" title="析构函数可以是虚函数吗？"></a>析构函数可以是虚函数吗？</h3><hr><p>可以，而且在有虚函数的基类里面，强烈建议将析构函数定义为虚函数</p><h3 id="虚函数表的存放内容"><a href="#虚函数表的存放内容" class="headerlink" title="虚函数表的存放内容"></a>虚函数表的存放内容</h3><hr><p>函数指针，每项指向一个函数的入口地址，根据调用者类类型确定</p><h3 id="C-11-的新特性"><a href="#C-11-的新特性" class="headerlink" title="C++11 的新特性"></a>C++11 的新特性</h3><hr><ul><li>语法糖</li><li>右值引用和移动语义</li><li>智能指针</li><li>多线程编程</li></ul><blockquote><p>C++11新增加了哪些新特性？一般而言，大概有以下四个方面：</p><ul><li>“语法糖”：<code>nullptr</code>, <code>auto</code>自动类型推导，范围for循环，初始化列表, lambda表达式等</li><li>右值引用和移动语义</li><li>智能指针</li><li>C++11多线程编程：<code>thread</code>库及其相配套的同步原语<code>mutex</code>, <code>lock_guard</code>, <code>condition_variable</code>, 以及异步<code>std::furture</code></li></ul><p><strong>“语法糖”</strong></p><hr><p>C++11新增加了一些语法糖，其中常用的就是auto和lambda。</p><p><strong>auto自动类型推导</strong></p><p>C语言也有auto关键字，但是其含义只是与static变量做一个区分，一个变量不指定的话默认就是auto。因为很少有人去用这个东西，所以在C++11中就把原有的auto功能给废弃掉了，而变成了现在的自动类型推导关键字。用法很简单不多赘述，比如写一个auto a = 3, 编译器就会自动推导a的类型为int. 在遍历某些STL容器的时候，不用去声明那些迭代器的类型，也不用去使用typedef就能很简洁的实现遍历了。</p><p>auto的使用有以下两点必须注意：</p><ul><li>auto声明的变量必须要初始化，否则编译器不能判断变量的类型。</li><li>auto不能被声明为返回值，auto不能作为形参，auto不能被修饰为模板参数</li></ul><p><strong>关于效率</strong>: auto实际上是在编译时对变量进行了类型推导，所以不会对程序的运行效率造成不良影响。另外，auto并不会影响编译速度，因为编译时本来也要右侧推导然后判断与左侧是否匹配。</p><p><strong>lambda表达式</strong></p><p>lambda表达式是匿名函数，可以认为是一个可执行体functor，语法规则如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">></span><span class="token punctuation">[</span>捕获区<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token parameter">参数区</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>代码区<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">></span>auto add <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token parameter">int a<span class="token punctuation">,</span> int b</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就我的理解而言，捕获的意思即为将一些变量展开使得为lambda内部可见，具体方式有如下几种</p><ul><li><strong>[a,&amp;b]</strong> 其中 <em>a</em> 以复制捕获而 <em>b</em> 以引用捕获。</li><li><strong>[this]</strong> 以引用捕获当前对象（ <code>*this</code> ）</li><li><strong>[&amp;]</strong> 以引用捕获所有用于 lambda 体内的<strong>自动变量</strong>，并以引用捕获当前对象，若存在</li><li><strong>[=]</strong> 以复制捕获所有用于 lambda 体内的<strong>自动变量</strong>，并以引用捕获当前对象，若存在</li><li><strong>[]</strong> 不捕获，大部分情况下不捕获就可以了</li></ul><p><strong>一般使用场景</strong>：sort等自定义比较函数、用thread起简单的线程。</p><p><strong>右值引用与移动语义</strong></p><hr><p>右值引用是C++11新特性，它实现了转移语义和完美转发，主要目的有两个方面</p><ul><li>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率</li><li>能够更简洁明确地定义泛型函数</li><li>C++中的变量要么是左值、要么是右值。通俗的左值定义指的是非临时变量，而右值指的是临时对象。左值引用的符号是一个&amp;，右值引用是两个&amp;&amp;</li></ul><p><strong>移动语义</strong><br>转移语义可以将资源(堆、系统对象等)从一个对象转移到另一个对象，这样可以减少不必要的临时对象的创建、拷贝及销毁。移动语义与拷贝语义是相对的，可以类比文件的剪切和拷贝。在现有的C++机制中，自定义的类要实现转移语义，需要定义移动构造函数，还可以定义转移赋值操作符。<br>以string类的移动构造函数为例</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">></span><span class="token function">MyString</span><span class="token punctuation">(</span>MyString<span class="token operator">&amp;&amp;</span> str<span class="token punctuation">)</span> <span class="token operator">></span><span class="token punctuation">&#123;</span>    std<span class="token operator">:</span><span class="token operator">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Move Ctor source from "</span> <span class="token operator">&lt;&lt;</span> str<span class="token punctuation">.</span>_data <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    _len <span class="token operator">=</span> str<span class="token punctuation">.</span>_len<span class="token punctuation">;</span>    _data <span class="token operator">=</span> str<span class="token punctuation">.</span>_data<span class="token punctuation">;</span>    str<span class="token punctuation">.</span>_len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    str<span class="token punctuation">.</span>_data <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token operator">></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>和拷贝构造函数类似，有几点需要注意：</p><ol><li>参数(右值)的符号必须是&amp;&amp;</li><li>参数(右值)不可以是常量，因为我们需要修改右值</li><li>参数(右值)的资源链接和标记必须修改，否则，右值的析构函数就会释放资源。转移到新对象的资源也就无效了。</li></ol><p>标准库函数std::move — 将左值变成一个右值</p><p>编译器只对右值引用才能调用移动构造函数，那么如果已知一个命名对象不再被使用，此时仍然想调用它的移动构造函数，也就是<strong>把一个左值引用当做右值引用来使用</strong>，该怎么做呢？用std::move，这个函数以非常简单的方式将左值引用转换为右值引用。</p><p><strong>智能指针</strong></p><hr><p>核心思想：为防止内存泄露等问题，用一个对象来管理野指针，使得在该对象构造时获得该指针管理权，析构时自动释放(delete).基于此思想C++98提供了第一个智能指针：<code>auto_ptr</code></p><p><code>  auto_ptr</code>基于所有权转移的语义，即将一个旧的auto_ptr赋值给另外一个新的auto_ptr时，旧的那一个就不再拥有该指针的控制权（内部指针被赋值为null),那么这就会带来一些根本性的破绽：</p><ul><li>函数参数传递时，会有隐式的赋值，那么原来的auto_ptr自动失去了控制权</li><li>自我赋值时，会将自己内部指针赋值为null，造成bug</li></ul><p>因为auto_ptr的各种bug，C++11标准基本废弃了这种类型的智能指针，转而带来了三种全新的智能指针：</p><ul><li><strong>shared_ptr</strong>，基于引用计数的智能指针，会统计当前有多少个对象同时拥有该内部指针；当引用计数降为0时，自动释放</li><li><strong>weak_ptr</strong>，基于引用计数的智能指针在面对循环引用的问题将无能为力，因此C++11还引入weak_ptr与之配套使用，weak_ptr只引用，不计数</li><li><strong>unique_ptr</strong>: 遵循独占语义的智能指针，在任何时间点，资源智能唯一地被一个unique_ptr所占有，当其离开作用域时自动析构。资源所有权的转移只能通过<code>std::move()</code>而不能通过赋值</li></ul><p><strong>C++11多线程编程</strong></p><hr><p><strong>1. 线程</strong></p><p><strong>std::thread</strong></p><ul><li>创建std::thread，一般会绑定一个底层的线程。若该thread还绑定好函数对象，则即刻将该函数运行于thread的底层线程。</li><li>线程相关的很多默认是move语义，因为在常识中线程复制是很奇怪的行为。</li><li>**joinable()**：是否可以阻塞至该thread绑定的底层线程运行完毕（倘若该thread没有绑定底层线程等情况，则不可以join)</li><li>**join()**：本线程阻塞直至该thread的底层线程运行完毕。</li><li>**detach()**：该thread绑定的底层线程分离出来，任该底层线程继续运行（thread失去对该底层线程的控制）。</li></ul><p><strong>2. 互斥量</strong></p><p>为了避免多线程对共享变量的一段操作会发生冲突，引入了互斥体和锁。</p><p><em><strong>*std::mutex*</strong></em></p><ul><li>互斥体，一般搭配锁使用，也可自己锁住自己（<strong>lock()</strong>,**unlock()**）。</li><li>若互斥体被第二个锁请求锁住，则第二个锁所在线程被阻塞直至第一个锁解锁。</li></ul><p><em><strong>*std::lock_guard*</strong></em></p><ul><li>简单锁，构造时请求上锁，释放时解锁，性能耗费较低。适用区域的多线程互斥操作。</li></ul><p><em><strong>*std::unique_lock*</strong></em></p><ul><li>更多功能也更灵活的锁，随时可解锁或重新锁上（减少锁的粒度），性能耗费比前者高一点点。适用灵活的区域的多线程互斥操作。</li></ul><p><strong>3. 原子变量</strong></p><p>原子变量的意思就是单个最小的、不可分割的变量（例如一个int），原子操作则指单个极小的操作（例如一个自增操），C++的原子类封装了这种数据对象，使多线程对原子变量的访问不会造成竞争。（可以利用原子类可实现无锁设计)</p><p><strong>std::atomic_flag</strong></p><ul><li>它是一个原子的布尔类型，可支持两种原子操作。(实际上mutex可用atomic_flag实现）</li><li>**test_and_set()**： 如果atomic_flag对象被设置，则返回true; 如果atomic_flag对象未被设置，则设置之，返回false</li><li>**clear()**：清除atomic_flag对象。</li></ul><p><strong>std::atomic</strong></p><ul><li>对int, char, bool等基本数据类型进行原子性封装（其实是特化模板）。</li><li>**store()**：修改被封装的值。</li><li>**load()**： 读取被封装的值。</li></ul><p><strong>4. 条件变量</strong></p><p>条件变量一般是用来实现多个线程的等待队列，即主线程通知（notify）有活干了，则等待队列中的其它线程就会被唤醒，开始干活。</p><p><strong>std::condition_variable</strong></p><ul><li>**wait(std::unique_lock&amp; lock, Predicate pred = <a href></a>{return true;})*<em>：pred()为true时直接返回，pred()为false时，lock必须满足已被当前线程锁定的前提。执行原子地释放锁定，阻塞当前线程，并将其添加到等待</em>this的线程列表中。</li><li>**notify_one()/notify_all()**：激活某个或者所有等待的线程，被激活的线程重新获得锁。</li></ul></blockquote><p><a href="https://leetcode-cn.com/circle/discuss/3UrXap/">https://leetcode-cn.com/circle/discuss/3UrXap/</a></p><p><a href="https://blog.csdn.net/weixin_44026604/article/details/113823333#comments_15143834">https://blog.csdn.net/weixin_44026604/article/details/113823333#comments_15143834</a></p>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mac下使用GitHub+Hexo搭建个人博客</title>
      <link href="2021/06/15/0-ri-chang-xue-xi/mac-xia-shi-yong-github-hexo-da-jian-ge-ren-bo-ke/"/>
      <url>2021/06/15/0-ri-chang-xue-xi/mac-xia-shi-yong-github-hexo-da-jian-ge-ren-bo-ke/</url>
      
        <content type="html"><![CDATA[<p>开始之前需要在电脑上安装好<a href="https://git-scm.com/">Git</a>和<a href="https://nodejs.org/en/">node.js</a>，Mac上可以使用Homebrew命令行工具来安装Git和node.js</p><hr><h4 id="安装Homebrew"><a href="#安装Homebrew" class="headerlink" title="安装Homebrew"></a>安装Homebrew</h4><p>在命令行工具输入以下命令，如果已经安装过Homebrew可以忽略</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;usr&#x2F;bin&#x2F;ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install)&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h4 id="Homebrew-安装-node-js"><a href="#Homebrew-安装-node-js" class="headerlink" title="Homebrew 安装 node.js"></a>Homebrew 安装 node.js</h4><pre class="line-numbers language-none"><code class="language-none">brew install node<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装后可以使用命令来检查是否安装成功</p><p>检查node</p><pre class="line-numbers language-none"><code class="language-none">node -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-none"><code class="language-none">v12.14.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>检查<a href="https://www.npmjs.com/">npm</a>是否安装成功，npm是node.js的包管理工具，用它来安装hexo</p><pre class="line-numbers language-none"><code class="language-none">npm -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出结果:</p><pre class="line-numbers language-none"><code class="language-none">6.13.4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h4 id="Homebrew-安装git"><a href="#Homebrew-安装git" class="headerlink" title="Homebrew 安装git"></a>Homebrew 安装git</h4><pre class="line-numbers language-none"><code class="language-none">brew install git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>检查git是否安装成功</p><pre class="line-numbers language-none"><code class="language-none">git -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出结果:</p><pre class="line-numbers language-none"><code class="language-none">git version 2.24.3 (Apple Git-128)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h4 id="使用-npm-安装-hexo"><a href="#使用-npm-安装-hexo" class="headerlink" title="使用 npm 安装 hexo"></a>使用 npm 安装 <a href="https://hexo.io/zh-cn/docs/">hexo</a></h4><pre class="line-numbers language-none"><code class="language-none">sudo npm install -g hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装完成后，在Desktop创建一个blog文件夹，在该文件夹下初始化我们的博客</p><pre class="line-numbers language-none"><code class="language-none">cd ~&#x2F;Desktop &amp;&amp; mkdir blog &amp;&amp; cd blog<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在该文件件目录下执行博客初始化操作</p><pre class="line-numbers language-none"><code class="language-none"># 会下载一些node.js的依赖文件hexo init<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>初始化成功后，在blog目录下执行预览操作</p><pre class="line-numbers language-none"><code class="language-none">hexo s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当看到如下输出就可以预览我们创建的博客了</p><pre class="line-numbers language-none"><code class="language-none">INFO  Validating configINFO  Start processingINFO  Hexo is running at http:&#x2F;&#x2F;localhost:4000 . Press Ctrl+C to stop. <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>预览效果如下</p><p><img src="/2021/06/15/0-ri-chang-xue-xi/mac-xia-shi-yong-github-hexo-da-jian-ge-ren-bo-ke/1.jfif"></p><hr><h4 id="配置客户端git-添加SSH-Key到github"><a href="#配置客户端git-添加SSH-Key到github" class="headerlink" title="配置客户端git 添加SSH Key到github"></a>配置客户端git 添加SSH Key到github</h4><p><strong>如果已经配置过，该步骤可以忽略</strong><br>在命令行输入配置用户名和账号的命令</p><pre class="line-numbers language-none"><code class="language-none">git config --global user.name &quot;username&quot;git config --global user.email &quot;email@gmail.com&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中 <code>username</code> 是你的用户名，<code>email@gmail.com</code>是你github的登录邮箱<br>然后通过终端命令生成SSH Key</p><pre class="line-numbers language-none"><code class="language-none">ssh-keygen -t rsa -C &quot;email@gmail.com&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果已经创建过会出现 <code>Overwrite (y/n)? n</code>提示可以输入 <code>n</code>，如果没有创建过会要求我们输入密码，然后一路回车下去就行，执行完成后会在<code>~/.ssh/id_rsa.pub</code>目录下生成 需要使用的 key。</p><p>可以使用命令行输出key并复制</p><pre class="line-numbers language-none"><code class="language-none">cat ~&#x2F;.ssh&#x2F;id_rsa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者可以找到这个文件并打开它，复制里面的内容。</p><p>登录github账号 找到 <code>setting</code></p><p><img src="/2021/06/15/0-ri-chang-xue-xi/mac-xia-shi-yong-github-hexo-da-jian-ge-ren-bo-ke/2.png"></p><p>先点击 <code>SSH and GPG keys</code> 然后再点击 <code>New SSH key </code>进入到配置 SSH Key 的页面</p><p><img src="/2021/06/15/0-ri-chang-xue-xi/mac-xia-shi-yong-github-hexo-da-jian-ge-ren-bo-ke/3.jfif"></p><p>然后输入复制好的key的内容</p><p><img src="/2021/06/15/0-ri-chang-xue-xi/mac-xia-shi-yong-github-hexo-da-jian-ge-ren-bo-ke/4.png"></p><p>点击 <code>Add SSH Key </code>即可</p>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>定期更新Homebrew</title>
      <link href="2021/06/15/0-ri-chang-xue-xi/ding-qi-geng-xin-homebrew/"/>
      <url>2021/06/15/0-ri-chang-xue-xi/ding-qi-geng-xin-homebrew/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/06/15/0-ri-chang-xue-xi/ding-qi-geng-xin-homebrew/1.webp"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Homebrew</code> 是使用 <code>Mac OS</code> 的一件利器，<code>Homebrew</code> 可以安装 <code>Apple</code> 没有预装但非常需要的东西。<code>Homebrew</code> 会将软件包安装到独立目录，并将其文件软链接至 <code>/usr/local</code>。</p><p>这一切只需要一条指令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">/usr/bin/ruby -e <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">curl</span> -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install<span class="token variable">)</span></span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="是否需要定期更新"><a href="#是否需要定期更新" class="headerlink" title="是否需要定期更新"></a>是否需要定期更新</h1><p>软件保持最新肯定是好的，但是一些软件因为某些原因没有更新到最新，如果一味地更新 <code>Homebrew</code> 所有安装包可能带来依赖的不支持。所以我的意见是每个月定期查看一下，有选择性地更新。</p><h1 id="如何更新"><a href="#如何更新" class="headerlink" title="如何更新"></a>如何更新</h1><p>更新 Homebrew 自己：</p><pre class="line-numbers language-undefined" data-language="undefined"><code class="language-undefined">brew update<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看哪些安装包需要更新：</p><pre class="line-numbers language-undefined" data-language="undefined"><code class="language-undefined">brew outdated<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>更新：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">brew upgrade             <span class="token comment"># 更新所有的包</span>brew upgrade <span class="token variable">$FORMULA</span>    <span class="token comment"># 更新指定的包</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>清理旧版本：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">brew cleanup             <span class="token comment"># 清理所有包的旧版本</span>brew cleanup <span class="token variable">$FORMULA</span>    <span class="token comment"># 清理指定包的旧版本</span>brew cleanup -n          <span class="token comment"># 查看可清理的旧版本包，不执行实际操作</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>锁定不想更新的包：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">brew pin <span class="token variable">$FORMULA</span>      <span class="token comment"># 锁定某个包</span>brew unpin <span class="token variable">$FORMULA</span>    <span class="token comment"># 取消锁定</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看安装包的相关信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">brew info <span class="token variable">$FORMULA</span>    <span class="token comment"># 显示某个包的信息</span>brew info             <span class="token comment"># 显示安装了包数量，文件数量，和总占用空间</span>brew deps --installed --tree <span class="token comment"># 查看已安装的包的依赖，树形显示</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>列出已安装包</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">brew list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">brew <span class="token function">rm</span> <span class="token variable">$FORMULA</span>                <span class="token comment"># 删除某个包</span>brew uninstall --force <span class="token variable">$FORMULA</span> <span class="token comment"># 删除所有版本</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java学习笔记1</title>
      <link href="2021/06/07/0-ri-chang-xue-xi/java-xue-xi-bi-ji-1/"/>
      <url>2021/06/07/0-ri-chang-xue-xi/java-xue-xi-bi-ji-1/</url>
      
        <content type="html"><![CDATA[<h4 id="一次编写，到处运行"><a href="#一次编写，到处运行" class="headerlink" title="一次编写，到处运行"></a>一次编写，到处运行</h4><hr><p>Java介于编译型语言和解释型语言之间。编译型语言如C、C++，代码是直接编译成机器码执行，但是不同的平台（x86、ARM等）CPU的指令集不同，因此，需要编译出每一种平台的对应机器码。解释型语言如Python、Ruby没有这个问题，可以由解释器直接加载源码然后运行，代价是运行效率太低。而Java是将代码编译成一种“字节码”，它类似于抽象的CPU指令，然后，针对不同平台编写虚拟机，不同平台的虚拟机负责加载字节码并执行，这样就实现了“一次编写，到处运行”的效果。当然，这是针对Java开发者而言。对于虚拟机，需要为每个平台分别开发。为了保证不同平台、不同公司开发的虚拟机都能正确执行Java字节码，SUN公司制定了一系列的Java虚拟机规范。从实践的角度看，JVM的兼容性做得非常好，低版本的Java字节码完全可以正常运行在高版本的JVM上。</p><h4 id="Java的三个版本"><a href="#Java的三个版本" class="headerlink" title="Java的三个版本"></a>Java的三个版本</h4><hr><p><img src="/2021/06/07/0-ri-chang-xue-xi/java-xue-xi-bi-ji-1/image-20210618110854252.png"></p><h4 id="JDK和JRE名词解释"><a href="#JDK和JRE名词解释" class="headerlink" title="JDK和JRE名词解释"></a>JDK和JRE名词解释</h4><hr><p><img src="/2021/06/07/0-ri-chang-xue-xi/java-xue-xi-bi-ji-1/image-20210618111014389.png"></p><h4 id="大小写敏感"><a href="#大小写敏感" class="headerlink" title="大小写敏感"></a>大小写敏感</h4><hr><p>Java 是大小写敏感的</p><blockquote><p>Java入口程序规定的方法必须是静态方法，方法名必须为<code>main</code>，括号内的参数必须是String数组。</p></blockquote><blockquote><p>int i3 = 2_000_000_000; // 加下划线更容易识别</p></blockquote><blockquote><p>对于<code>float</code>类型，需要加上<code>f</code>后缀。</p></blockquote><h4 id="Java布尔类型的存储大小"><a href="#Java布尔类型的存储大小" class="headerlink" title="Java布尔类型的存储大小"></a>Java布尔类型的存储大小</h4><hr><p>Java语言对布尔类型的存储并没有做规定，因为理论上存储布尔类型只需要1 bit，但是通常JVM内部会把<code>boolean</code>表示为4字节整数。</p><p>理由：在《Java虚拟机规范》一书中的描述：“虽然定义了boolean这种数据类型，但是只对它提供了非常有限的支持。在Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达式所操作的boolean值，在编译之后都使用Java虚拟机中的int数据类型来代替，而boolean数组将会被编码成Java虚拟机的byte数组，每个元素boolean元素占8位”。也就是说JVM规范指出boolean当做int处理，也就是4字节，boolean数组当做byte数组处理，这样我们可以得出boolean类型占了单独使用是4个字节，在数组中是确定的1个字节。</p><p>如果认同上面说法，那么存在问题：那虚拟机为什么要用int来代替boolean呢？为什么不用byte或short，这样不是更节省内存空间吗。经过查阅资料发现，使用int的原因是，对于当下32位的处理器（CPU）来说，一次处理数据是32位（这里不是指的是32/64位系统，而是指CPU硬件层面），32 位 CPU 使用 4 个字节是最为节省的，哪怕你是 1 个 bit 他也是占用 4 个字节。因为 CPU 寻址系统只能 32 位 32 位地寻址，具有高效存取的特点。</p><p>It depends on Java virtual machine.这取决于java虚拟机 。</p><p>总结：java规范中，没有明确指出boolean的大小。在《Java虚拟机规范》给出了4个字节，和boolean数组1个字节的定义，具体还要看虚拟机实现是否按照规范来，所以1个字节、4个字节都是有可能的。</p><blockquote><p>定义变量的时候，如果加上<code>final</code>修饰符，这个变量就变成了常量：根据习惯，常量名通常全部大写。</p></blockquote><h4 id="var关键字"><a href="#var关键字" class="headerlink" title="var关键字"></a>var关键字</h4><hr><p><img src="/2021/06/07/0-ri-chang-xue-xi/java-xue-xi-bi-ji-1/image-20210618112928152.png"></p><h4 id="整数注意事项"><a href="#整数注意事项" class="headerlink" title="整数注意事项"></a>整数注意事项</h4><blockquote><ul><li>整数的数值表示不但是精确的，而且整数运算永远是精确的，即使是除法也是精确的，因为两个整数相除只能得到结果的整数部分。</li></ul><ul><li>特别注意：整数的除法对于除数为0时运行时将报错，但编译不会报错。</li></ul><ul><li>要特别注意，整数由于存在范围限制，如果计算结果超出了范围，就会产生溢出，而溢出<em>不会出错</em>，却会得到一个奇怪的结果。</li></ul><ul><li>可以对整数进行移位运算。对整数<code>7</code>左移1位将得到整数<code>14</code>，左移两位将得到整数<code>28</code>。</li></ul><ul><li>还有一种无符号的右移运算，使用<code>&gt;&gt;&gt;</code>，它的特点是不管符号位，右移后高位总是补<code>0</code>，因此，对一个负数进行<code>&gt;&gt;&gt;</code>右移，它会变成正数，原因是最高位的<code>1</code>变成了<code>0</code>。</li></ul><ul><li>对<code>byte</code>和<code>short</code>类型进行移位时，会首先转换为<code>int</code>再进行位移。</li></ul><ul><li>仔细观察可发现，左移实际上就是不断地×2，右移实际上就是不断地÷2。</li></ul></blockquote><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><blockquote><ul><li>在运算过程中，如果参与运算的两个数类型不一致，那么计算结果为较大类型的整型。例如，<code>short</code>和<code>int</code>计算，结果总是<code>int</code>，原因是<code>short</code>首先自动被转型为<code>int</code>。</li></ul><ul><li>也可以将结果强制转型，即将大范围的整数转型为小范围的整数。强制转型使用<code>(类型)</code>，例如，将<code>int</code>强制转型为<code>short</code>：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">12345</span><span class="token punctuation">;</span><span class="token keyword">short</span> s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span> i<span class="token punctuation">;</span> <span class="token comment">// 12345</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><blockquote><p>浮点数<code>0.1</code>在计算机中就无法精确表示，因为十进制的<code>0.1</code>换算成二进制是一个无限循环小数，很显然，无论使用<code>float</code>还是<code>double</code>，都只能存储一个<code>0.1</code>的近似值。但是，<code>0.5</code>这个浮点数又可以精确地表示。</p></blockquote><ul><li>如果参与运算的两个数其中一个是整型，那么整型可以自动提升到浮点型：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>        <span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">1.2</span> <span class="token operator">+</span> <span class="token number">24.0</span> <span class="token operator">/</span> n<span class="token punctuation">;</span> <span class="token comment">// 6.0</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要特别注意，在一个复杂的四则运算中，两个整数的运算不会出现自动提升的情况。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">1.2</span> <span class="token operator">+</span> <span class="token number">24</span> <span class="token operator">/</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// 5.2</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>计算结果为<code>5.2</code>，原因是编译器计算<code>24 / 5</code>这个子表达式时，按两个整数进行运算，结果仍为整数<code>4</code>。</p><h4 id="浮点数运算除数为0时返回的特殊值"><a href="#浮点数运算除数为0时返回的特殊值" class="headerlink" title="浮点数运算除数为0时返回的特殊值"></a>浮点数运算除数为<code>0</code>时返回的特殊值</h4><hr><p>整数运算在除数为<code>0</code>时会报错，而浮点数运算在除数为<code>0</code>时，不会报错，但会返回几个特殊值：</p><ul><li><code>NaN</code>表示Not a Number</li><li><code>Infinity</code>表示无穷大</li><li><code>-Infinity</code>表示负无穷大</li></ul><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">double</span> d1 <span class="token operator">=</span> <span class="token number">0.0</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// NaN</span><span class="token keyword">double</span> d2 <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// Infinity</span><span class="token keyword">double</span> d3 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1.0</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// -Infinity</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>可以将浮点数强制转型为整数。在转型时，浮点数的小数部分会被丢掉。如果转型后超过了整型能表示的最大范围，将返回整型的最大值。</p></blockquote><blockquote><p>如果要进行四舍五入，可以对浮点数加上0.5再强制转型。</p></blockquote><blockquote><p>布尔运算的一个重要特点是短路运算。如果一个布尔运算的表达式能提前确定结果，则后续的计算不再执行，直接返回结果。</p></blockquote><blockquote><p>如果用<code>+</code>连接字符串和其他数据类型，会将其他数据类型先自动转型为字符串，再连接。</p></blockquote><h4 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h4><hr><p>如果我们要表示多行字符串，使用+号连接会非常不方便：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">"first line \n"</span>         <span class="token operator">+</span> <span class="token string">"second line \n"</span>         <span class="token operator">+</span> <span class="token string">"end"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>从Java 13开始，字符串可以用<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code>表示多行字符串（Text Blocks）了。举个例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 多行字符串</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token triple-quoted-string string">"""                   SELECT * FROM                     users                   WHERE id > 100                   ORDER BY name DESC                   """</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述多行字符串实际上是5行，在最后一个<code>DESC</code>后面还有一个<code>\n</code>。如果我们不想在字符串末尾加一个<code>\n</code>，就需要这么写：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token triple-quoted-string string">"""            SELECT * FROM             users           WHERE id > 100           ORDER BY name DESC"""</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还需要注意到，多行字符串前面共同的空格会被去掉，即：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token triple-quoted-string string">"""...........SELECT * FROM...........  users...........WHERE id > 100...........ORDER BY name DESC..........."""</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用<code>.</code>标注的空格都会被去掉。</p><p>如果多行字符串的排版不规则，那么，去掉的空格就会变成这样：</p><pre class="line-numbers language-none"><code class="language-none">String s &#x3D; &quot;&quot;&quot;.........  SELECT * FROM.........    users.........WHERE id &gt; 100.........  ORDER BY name DESC.........  &quot;&quot;&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>即总是以最短的行首空格为基准。</p><h4 id="字符串不可变特性"><a href="#字符串不可变特性" class="headerlink" title="字符串不可变特性"></a>字符串不可变特性</h4><hr><p>Java的字符串除了是一个引用类型外，还有个重要特点，就是字符串不可变。考察以下代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 字符串不可变</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 显示 hello</span>        s <span class="token operator">=</span> <span class="token string">"world"</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 显示 world</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>观察执行结果，难道字符串<code>s</code>变了吗？其实变的不是字符串，而是变量<code>s</code>的“指向”。</p><p>执行<code>String s = &quot;hello&quot;;</code>时，JVM虚拟机先创建字符串<code>&quot;hello&quot;</code>，然后，把字符串变量<code>s</code>指向它：</p><pre class="line-numbers language-ascii" data-language="ascii"><code class="language-ascii">      s      │      ▼┌───┬───────────┬───┐│   │  &quot;hello&quot;  │   │└───┴───────────┴───┘<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>紧接着，执行<code>s = &quot;world&quot;;</code>时，JVM虚拟机先创建字符串<code>&quot;world&quot;</code>，然后，把字符串变量<code>s</code>指向它：</p><pre class="line-numbers language-ascii" data-language="ascii"><code class="language-ascii">      s ──────────────┐                      │                      ▼┌───┬───────────┬───┬───────────┬───┐│   │  &quot;hello&quot;  │   │  &quot;world&quot;  │   │└───┴───────────┴───┴───────────┴───┘<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原来的字符串<code>&quot;hello&quot;</code>还在，只是我们无法通过变量<code>s</code>访问它而已。因此，字符串的不可变是指<strong>字符串内容不可变</strong>。</p><blockquote><p>注意要区分空值<code>null</code>和空字符串<code>&quot;&quot;</code>，空字符串是一个有效的字符串对象，它不等于<code>null</code>。</p></blockquote><blockquote><p>Java的数组有几个特点：</p><ul><li>数组所有元素初始化为默认值，整型都是<code>0</code>，浮点型是<code>0.0</code>，布尔型是<code>false</code>；</li><li>数组一旦创建后，大小就不可改变。</li></ul></blockquote><blockquote><p><code>println</code>是print line的缩写，表示输出并换行。因此，如果输出后不想换行，可以用<code>print()</code>：</p></blockquote><h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><hr><p>Java还提供了格式化输出的功能。为什么要格式化输出？因为计算机表示的数据不一定适合人来阅读：</p><p>如果要把数据显示成我们期望的格式，就需要使用格式化输出的功能。格式化输出使用<code>System.out.printf()</code>，通过使用占位符<code>%?</code>，<code>printf()</code>可以把后面的参数格式化成指定格式，而不能使用<code>println</code>。</p><blockquote><p>在使用git这些版本控制系统自动合并时更容易出问题，所以不推荐忽略花括号的写法。</p></blockquote><h4 id="新Switch语法"><a href="#新Switch语法" class="headerlink" title="新Switch语法"></a>新Switch语法</h4><hr><p>使用新的<code>switch</code>语法，不但不需要<code>break</code>，还可以直接返回值。把上面的代码改写如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> fruit <span class="token operator">=</span> <span class="token string">"apple"</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> opt <span class="token operator">=</span> <span class="token keyword">switch</span> <span class="token punctuation">(</span>fruit<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">case</span> <span class="token string">"apple"</span> <span class="token operator">-></span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">"pear"</span><span class="token punctuation">,</span> <span class="token string">"mango"</span> <span class="token operator">-></span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">default</span> <span class="token operator">-></span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 注意赋值语句要以;结束</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"opt = "</span> <span class="token operator">+</span> opt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意新语法使用<code>-&gt;</code>，如果有多条语句，需要用<code>&#123;&#125;</code>括起来。不要写<code>break</code>语句，因为新语法只会执行匹配的语句，没有穿透效应。</p><h4 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h4><hr><p>但是，很多时候，我们实际上真正想要访问的是数组每个元素的值。Java还提供了另一种<code>for each</code>循环，它可以更简单地遍历数组：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ns <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">25</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">:</span> ns<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>人人都是产品经理</title>
      <link href="2021/06/07/0-du-shu-bi-ji/ren-ren-du-shi-chan-pin-jing-li/"/>
      <url>2021/06/07/0-du-shu-bi-ji/ren-ren-du-shi-chan-pin-jing-li/</url>
      
        <content type="html"><![CDATA[<blockquote><p>虽然不是每个人都能以产品经理为业，但在我看来，产品经理是一类人，他的做事思路与方法可以解决很多实际的生活问题。只要你能够发现问题并描述清楚，转化为一个需求，进而转化为一个任务，争取到支持，发动起一批人，将这个任务完成，并持续不断以主人翁的心态去跟踪、维护这个产物，那么，你就是产品经理。至少，你已经是自己的产品经理，这才是“人人都是产品经理”的真谛。</p></blockquote><blockquote><p>我们为什么要做产品经理？因为，好产品能改变世界，坏产品也能，而我们身边已经有太多的坏产品了，世界需要我们——好的产品经理——来拯救！</p></blockquote><blockquote><p>不管企业想用怎样的专业取向，以便产品经理更容易地管理他的工作，很重要的一点是，请记住这个职位当初是为何而设——想要更了解产品与它面临的竞争情况，最终目的是要满足顾客的需求。</p></blockquote><blockquote><p>管理的能力，其实就是“在资源不足的情况下把事情做成”的能力。凡是资源，总归不足——这是常态！</p></blockquote><blockquote><p>不要试图满足所有用户：试图满足所有用户的需求是一个灾难，那会让产品变成一个臃肿不堪，谁都不满意的四不像。优先满足哪些用户需要和产品的商业目标结合起来考虑。</p></blockquote><blockquote><p>在对产品足够熟悉的基础上，先做出方向性的假设，再提取相应的数据并分析，得到一些现象，最好是之前没发现的现象，然后尝试解释，接下来做用户调研修正解释，最终指导产品发展方向。</p></blockquote><h1 id="1-产品经理的主要工作职责"><a href="#1-产品经理的主要工作职责" class="headerlink" title="1.产品经理的主要工作职责"></a>1.产品经理的主要工作职责</h1><p>作为一名新进产品经理，甚至一名资深PM，你可能都或多或少对这个职位产生某种迷惑。到底什么是产品经理？这个职位的主要职责是什么？在IT产业的不同领域，甚至在同一领域的不同公司，这个职位的定义似乎都有不同。</p><p>虽然在不同的公司，产品经理的角色和职责互有差异，但是有一些关键职责是任何一个产品经理都应承担的。可以将其归纳为如下六个方面：</p><h2 id="1-1市场调研"><a href="#1-1市场调研" class="headerlink" title="1.1市场调研"></a>1.1市场调研</h2><p>市场调研是指研究市场以了解客户需求、竞争状况及市场力量（market forces），其最终目标是发现创新或改进产品的潜在机会。</p><p>可以通过下面的方式进行市场调研：</p><ol><li><p>   与用户和潜在用户交流</p></li><li><p>   与直接面对客户的一线同事（如销售、客服、技术支持等）交流</p></li><li><p>   研究市场分析报告及文章</p></li><li><p>   试用竞争产品</p></li><li><p>   仔细观察用户行为等</p></li></ol><p>市场调研最终会形成商业机会、产品战略或商业需求文档（BRD），详述如何利用潜在的机会。</p><p>出现的成果主要为：《商业需求文档（BRD）》或《商业机会》或《产品战略》</p><h2 id="1-2产品定义及设计"><a href="#1-2产品定义及设计" class="headerlink" title="1.2产品定义及设计"></a>1.2产品定义及设计</h2><p>1、    产品定义是指确定产品需要做哪些事情。通常采用产品需求文档（PRD）来进行描述，PRD可能包含如下信息：</p><ol><li><p>   产品的愿景</p></li><li><p>   目标市场</p></li><li><p>   竞争分析</p></li><li><p>   产品功能的详细描述</p></li><li><p>   产品功能的优先级</p></li><li><p>   产品用例（Use Case）</p></li><li><p>   系统需求</p></li><li><p>   性能需求</p></li><li><p>   销售及支持需求等</p></li></ol><p>2、   产品设计是指确定产品的外观，包括用户界面设计（UI，User Interface）和用户交互设计（User Interaction），包含所有的用户体验部分。</p><p>在大型公司里，PM通常和UI设计师或互动设计师一起完成产品设计，不过在小公司或者创业公司里，产品经理也许需要全包这些工作。</p><p>这是产品经理工作中最有价值的部分，如果产品经理工作中不包含这部分内容，那几乎可以肯定的说，那不是产品经理的工作。</p><p>出现的成果主要为：《产品需求文档（PRD）》</p><h2 id="1-3项目管理"><a href="#1-3项目管理" class="headerlink" title="1.3项目管理"></a>1.3项目管理</h2><p>项目管理是指带领来自不同团队的人员（包括工程师、QA、UI设计师、市场、销售、客服等），在预算内按时开发并发布产品。其中可能包括如下工作内容：</p><ol><li><p>   确保资源投入</p></li><li><p>   制定项目计划</p></li><li><p>   根据计划跟踪项目进展</p></li><li><p>   辨别关键路径</p></li><li><p>   必要时争取追加投入</p></li><li><p>   向主管领导报告项目进展状况等</p></li></ol><p>在大型公司里，通常会有项目经理来处理大部分项目管理工作，产品经理只需提供支持。不过在创业公司里，产品经理通常需要自己进行项目管理。在有些公司，技术负责人也可能作为项目经理，处理大部分项目管理事宜。</p><h2 id="1-4产品宣介"><a href="#1-4产品宣介" class="headerlink" title="1.4产品宣介"></a>1.4产品宣介</h2><p>主要包括和内部同事如老板、销售、市场、客服等沟通产品的优点、功能和目标市场，也可能包括向外界如媒体、行业分析师及用户宣介产品。</p><p>大公司的产品经理通常都有产品市场、市场推广和媒体关系（PR）团队帮忙进行对外的产品宣介。</p><p>这是除了产品定义和设计之外，对产品经理而言价值第二高的工作，尤其是在向老板、市场同事宣介产品并让他们感到兴奋的时候。</p><h2 id="1-5产品市场"><a href="#1-5产品市场" class="headerlink" title="1.5产品市场"></a>1.5产品市场</h2><p>主要是对外的信息传播——告诉外界有关产品的信息。通常包括制作产品数据表、手册、网站、Flash演示、媒体专题以及展会演示等。</p><p>在大型公司，产品市场工作通常不会由PM来负责，这些公司会有专门的产品市场经理来打理此项工作。当然，这种分工最大的缺点就是导致沟通效率较低，并会削弱对外传播。</p><p>在某些公司，“产品管理”和“产品市场”被认为是同义词，会由一个人担当两者的职责。而在那些将产品管理团队和产品市场团队分开的公司，后者会打理本节所提及的工作职责，同时他们也可能会承担“市场调研”、“产品宣介”和“产品生命周期”管理的部分工作。</p><h2 id="1-6产品生命周期管理"><a href="#1-6产品生命周期管理" class="headerlink" title="1.6产品生命周期管理"></a>1.6产品生命周期管理</h2><p>指那些随着产品经历“概念化→发布→成熟→退出市场”整个生命周期中的产品管理活动。</p><p>主要包括的工作有：</p><ol><li><p>   产品定位</p></li><li><p>   产品定价及促销</p></li><li><p>   产品线管理</p></li><li><p>   竞争策略</p></li><li><p>   建立或收购合作伙伴</p></li><li><p>   识别并建立合作关系等</p></li></ol><p>产品经理和产品市场、BD及市场沟通同事一起完成这些工作。</p><p>产品周期一般分为五个阶段：</p><h3 id="1-6-1概念化阶段"><a href="#1-6-1概念化阶段" class="headerlink" title="1.6.1概念化阶段"></a>1.6.1概念化阶段</h3><p>这个阶段主要是提出一些产品概念，市场需求，对于产品而言，仅仅是一些描述而缺乏具体的量化指标，但是这个阶段是周期的基础，只有积累一定量的需求，才能为产品经理的具体工作提供依据。</p><p>在这个阶段中，产品经理主要是负责提出概念和进行概念表述，描绘一个产品的轮廓，让相关部门和高层接受这个概念，得到支持和资源分配。</p><p>这个阶段可以分为两个步骤：市场数据获取和需求分析。</p><p>出现的成果主要为：《市场需求反馈记录》和《需求分析报告》</p><h3 id="1-6-2产品化阶段"><a href="#1-6-2产品化阶段" class="headerlink" title="1.6.2产品化阶段"></a>1.6.2产品化阶段</h3><p>这个阶段主要是对概念进行图纸化和量化，设定产品指标，形成可设计的功能和产品原型，并且通过公司认可，纳入公司产品开发计划中。</p><p>在这个阶段中，产品经理主要是负责对产品进行量化的工作，量化的内容应该包括产品功能，产品模型，开发进度，所需资源。</p><p>这个阶段可以分为三个步骤：市场沟通，产品设计和计划确认。</p><p>出现的成果主要为：《产品设计文档》，《产品开发计划》和《产品立项单》</p><h3 id="1-6-3技术化阶段"><a href="#1-6-3技术化阶段" class="headerlink" title="1.6.3技术化阶段"></a>1.6.3技术化阶段</h3><p>这个阶段主要是把图纸化的产品原型进行物理化，依据产品设计文档开发出具有实际操作价值的实物（这里的实物是指可以实现具体功能的物理载体）。</p><p>在这个阶段中，主要依靠研发生产部门进行，产品经理的职责就是协调各种资源，全力保障技术化阶段能够按照产品开发计划进行。</p><p>这个阶段可以分为两个步骤：产品开发和产品验收</p><p>出现的成果主要为：可交付的产品和《技术白皮书》</p><h3 id="1-6-4商品化阶段"><a href="#1-6-4商品化阶段" class="headerlink" title="1.6.4商品化阶段"></a>1.6.4商品化阶段</h3><p>这个阶段主要是把交付的产品形成具有销售价值的商品，就是对该产品进行商业化包装，这个包括两个部分：内涵商业化和外延商业化。</p><p>内涵商业化是指对产品本身进行的商业化过程，比如产品说明书，销售手册，包装元素等；</p><p>外延商业化是指促进商品销售的元素确定过程，比如媒体准备，软文准备，渠道准备等。</p><p>在这个阶段中，产品经理的主要职责就是负责内涵商业化的整体过程，协助销售部门完成外延商业化的过程，完成产品发布。</p><p>这个阶段可以分为两个步骤：商业化和产品发布</p><p>出现的主要成果为：可销售的产品和产品发布，以及大量的商品化元素。</p><h3 id="1-6-5市场化阶段"><a href="#1-6-5市场化阶段" class="headerlink" title="1.6.5市场化阶段"></a>1.6.5市场化阶段</h3><p>这个阶段主要就是跟踪产品发布后的销售进度（我习惯于跟踪3个月），积极推动销售部门完成销售任务，并随时了解销售反馈，进行记录，调整产品在一个产品年度的策略，并对产品的下一步发展提供依据。</p><p>在这个阶段中，产品经理的主要职责就是和销售部门进行沟通，协助解决销售过程中遇到的产品问题。</p><p>这个阶段可以分为两个步骤：产品跟踪和产品总结</p><p>出现的主要成果为：预定的销售渠道完成和销售反馈记录</p><p>一般的产品规划周期就是由这五个阶段组成的，在进入到市场化阶段后，其实就可以进入到第一个阶段中了，产品规划的周期本身就是一个螺旋史式发展的过程，从概念开始，逐渐完成一个完成产品的周期，其中包含了多个这样的产品规划周期，而产品经理作为产品的全程参与者，其责任将大大超出横向部门的职责范围，其重要性和不可替代性也是显而易见的，我们可以看到，在那些产品经理体系建立比较完善和重视的企业，其产品的市场感知度相当强烈，产品的市场替代能力也非常强，从而也推动了企业的产品创新能力和开发能力。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>富爸爸：财富自由之路</title>
      <link href="2021/06/04/0-du-shu-bi-ji/fu-ba-ba-cai-fu-zi-you-zhi-lu/"/>
      <url>2021/06/04/0-du-shu-bi-ji/fu-ba-ba-cai-fu-zi-you-zhi-lu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>显而易见，任何认为钱不重要的人都不能长期缺钱。</p></blockquote><blockquote><p>钱没有什么不同，但是挣钱的途径却截然不同。</p></blockquote><blockquote><p>财商不是指你挣了多少钱，而是指你有多少钱、这些钱为你工作的努力程度，以及你的钱能维持几代。</p></blockquote><blockquote><p>你老板的工作是给你工作，而你的工作是让自己变富。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>富爸爸穷爸爸</title>
      <link href="2021/06/03/0-du-shu-bi-ji/fu-ba-ba-qiong-ba-ba/"/>
      <url>2021/06/03/0-du-shu-bi-ji/fu-ba-ba-qiong-ba-ba/</url>
      
        <content type="html"><![CDATA[<h3 id="第一课：富人不为钱工作"><a href="#第一课：富人不为钱工作" class="headerlink" title="第一课：富人不为钱工作"></a>第一课：富人不为钱工作</h3><blockquote><p>大部分增长的收入都流向企业家及投资者，而并非劳动者——那些为钱而工作的人们。</p></blockquote><blockquote><p>穷人和中产阶级为钱而工作。富人让钱为他工作。</p></blockquote><blockquote><p>生活推动着我们所有的人，有些人放弃了，有些人在抗争。少数人学会了这门课程，取得了进步，他们欢迎生活来推动他们。</p></blockquote><blockquote><p>停止责备我，不要认为是我的问题。如果你认为是我的问题，你就会想改变我；如果你认为问题在你那儿，你就会改变自己，学习一些东西让自己变得更聪明。</p></blockquote><blockquote><p>说到钱，大多数人都希望稳稳妥妥地赚钱，这样他们才感到安全。关于钱，他们没有激情，有的只是恐惧。</p></blockquote><blockquote><p>钱并不能解决人们的问题。很多人有着高收入的工作但他们还是为钱所困——因为他们不知道如何让钱为他们工作。</p><p>对大多数人而言，给他们的钱越多，他们欠的债也就越多。</p><p>人们让恐惧和贪婪控制了自己的人生。</p></blockquote><blockquote><p>正是出于恐惧的心理，人们才想找一份安稳的工作。这些恐惧有：害怕付不起账单，害怕被解雇，害怕没有足够的钱，害怕重新开始。为了寻求保障，他们会学习某种专业，或是做生意，拼命为钱而工作。大多数人成了钱的奴隶，然后就把怒气发泄在他们老板身上。</p></blockquote><blockquote><p>大多数人并不知道是他们的感情代替了他们进行思考。</p></blockquote><blockquote><p>工作只是试图用暂时的办法来解决长期的问题。</p><p>就像一幅画表现的：驴子拉车，因为主人在它前面挂了个胡萝卜。主人清楚自己想要去哪里，而驴子却只是在追逐一个幻影。但第二天驴子依旧会去拉车，因为又有胡萝卜放在它的面前。</p></blockquote><h3 id="第二课：为什么要教授财务知识"><a href="#第二课：为什么要教授财务知识" class="headerlink" title="第二课：为什么要教授财务知识"></a>第二课：为什么要教授财务知识</h3><blockquote><p>你挣了多少钱并不重要，重要的是你留下了多少钱。</p></blockquote><blockquote><p>有太多人过多地关注钱，而不是关注他们最大的财富——所受的教育。如果人们能灵活一些，保持开放的头脑不断学习，他们将在时代的变化中一天天地富有起来。如果人们认为钱能解决一切问题，恐怕他们的日子就不会太好过。只有知识才能解决问题并创造财富，那些不是靠财务知识挣来的钱也不会长久。</p></blockquote><blockquote><p>富人获得资产，而穷人和中产阶级获得负债，只不过他们以为那些负债就是资产。</p></blockquote><blockquote><p>资产是能把钱放进你口袋里的东西。负债是把钱从你口袋里取走的东西。<br>你只要知道这些就足够了。如果你想致富，只需不断买入资产就行了；如果你只想当穷人或是中产阶级，只要不断地买入负债。正是因为不知道资产与负债的区别，世界上才会有这么多人有财务问题。</p></blockquote><blockquote><p>现金流说明了问题，即一个人怎样处理他的钱。</p></blockquote><blockquote><p>我也常听人说：“我欠了债，所以我必须挣钱。”</p><p>但有更多的钱往往不能解决问题，实际上可能使问题变得更加严重。钱往往能暴露人性中那些可悲的弱点，并凸显人们的无知。这就是为什么经常有一些人在忽然得到一大笔意外之财，比如遗产、加薪或买彩票中大奖之后，不久又陷入财务困境的原因——即便他们的财务状况会比之前好一些。钱只会让你头脑中的现金流的模式更加明显，如果你的模式是把收入都花掉，那么最可能的结果是在增加收入的同时也增加支出。正所谓，“蠢人用蠢钱”。</p></blockquote><blockquote><p>作为一名雇员，表面上社会保险和医疗保险共计约7.5％，实际上却是15％，因为雇主必须为你付7.5％的社会保险。关键是，雇主是拿他本该支付给你的钱去支付的。</p></blockquote><blockquote><p>当我还是孩子时，我的爸爸告诉我日本人注重3种力量：剑、宝石和镜子。<br>剑象征着武器的力量。美国人在武器上已经花了上千亿美元，是世界上的超级军事大国。<br>宝石象征着金钱的力量。有句格言很有道理：“记住黄金规则：有黄金的人制定规则。”<br>镜子象征着自知的力量。从日本的传奇故事中我们得知，自知是3种力量中最宝贵的。</p></blockquote><blockquote><p>大多数人的财务困境是由于随大流、盲目地跟从其他人所造成的。因此我们都需要不时地照照镜子，相信我们内心的智慧而不是恐惧。</p></blockquote><blockquote><p>聪明人总是雇用比他更聪明的人。</p></blockquote><blockquote><p>为什么富人越来越富？关于富爸爸的财务状况的分析说明了为什么富人会越来越富。资产项产生的收入足以弥补支出，还可以用剩余的收入对资产项进行再投资。资产项不断增长，相应的收入也会越来越多。其结果是：富人越来越富！</p></blockquote><blockquote><p>为什么中产阶级无法摆脱财务问题？真正的悲剧是：正是由于早年缺乏必要的财务知识教育，才造成了中产阶级财务上的风险。而他们必须回避风险，是因为他们的财务状况不容乐观。他们的资产负债表从来没有平衡过，负担着大量债务而且没有能够产生收入的真实资产。一般说来工资是他们收入的全部来源，他们的生活完全依赖于他们的雇主。所以当名副其实的“关系一生的机会”来临时，这些人无法抓住，他们必须保证安全，因为他们工作非常辛苦，并负担着高额的税和债务。</p></blockquote><blockquote><p>对于财富的定义，借用一个名叫巴克敏斯特·富勒的人的关于“财富”的话：财富就是支撑一个人生存多长时间的能力，或者说，如果我今天停止工作，我还能活多久？</p><p>用另一个方式来阐述：财富是将资产项产生的现金与支出项流出的现金进行比较而定的。当你的资产项能产生足够的收入来填补你的支出时，你就是富有的，即使你还没有什么钱。</p></blockquote><h3 id="第三课：关注自己的事业"><a href="#第三课：关注自己的事业" class="headerlink" title="第三课：关注自己的事业"></a>第三课：关注自己的事业</h3><blockquote><p>富人关心的焦点是资产而其他人关心的是收入。</p></blockquote><blockquote><p>在上一章的结尾，我们用图表说明了大多数人工作其实是为其他人，而非他们自己。首先他们要为公司的老板工作，其次是通过纳税为政府工作，最后是为向他们提供住房按揭贷款的银行工作。</p></blockquote><blockquote><p>从事你所学的专业的可怕后果在于，它会让你忘记关注自己的事业。人们耗尽一生去关注别人的事业并使他人致富。</p></blockquote><blockquote><p>为了财务安全，人们需要关注自己的事业。你的事业的重心是你的资产项，而不是你的收入项。</p></blockquote><blockquote><p>那些能给子孙留下遗产的人和那些能长期富有的人，就是先构筑资产项，然后才用资产所产生的收入购买奢侈品的，而穷人和中产阶级则用他们的血汗钱和本应该留给子孙的遗产来购买奢侈品。<br>真正的奢侈品是对投资和积累真正资产的奖励。</p></blockquote><h3 id="第四课：税收的历史和公司的力量"><a href="#第四课：税收的历史和公司的力量" class="headerlink" title="第四课：税收的历史和公司的力量"></a>第四课：税收的历史和公司的力量</h3><blockquote><p>富爸爸做得更聪明，他利用公司——富人的最大秘密——来达到他的目的。</p></blockquote><blockquote><p>税收的初衷是惩罚有钱人，而现实却是它惩罚了对它投赞同票的中产阶级和穷人。</p></blockquote><blockquote><p>富人永远不会缴税。我们越来越频繁地看到政府利用税法刺激企业主和投资者创造更多的工作机会和住房。这些刺激政策降低了富人的税收。所以，政府只能从中产阶级那里获得税收。</p></blockquote><blockquote><p>真正的资本家则利用他们的财务知识逃脱了。他们借助于公司的保护来避税。公司的确可以保护富人。但是许多没有建立过公司的人不知道这一点，公司并不一定是一个真正的实体，公司可以只是一些装着法律文件的文件夹，在政府机构注册后就被放在了律师的办公室里。公司并不意味着一定有刻着公司名称的办公楼、厂房和雇员，它可以只是一个没有灵魂的法律实体，但富人的财富在这里受到保护。所得税法被通过之后，成立公司就变得流行起来了，因为企业所得税率低于个人收入所得税率。此外，正如之前我们所讨论过的，公司的某些支出可以用税前收入支付。</p></blockquote><blockquote><p>每当人们想惩罚富人时，富人不会坐以待毙，而是进行反击。他们有钱、有能力、有决心去改变处境。他们决不会坐视不管，自动地缴纳高额的税款，他们会想办法把税负降至最低。他们雇用聪明的律师和会计师，说服政客们改变法律，钻法律的漏洞，他们有能力扭转乾坤。<br>美国的税法允许人们采用合理的方法避税，大多数人都可以运用这些方法，但实际上只有富人才常用它们，因为他们关注自己的事业。</p></blockquote><blockquote><p>富爸爸经常提醒我和迈克，最大的敌人不是老板或上司，而是税负，税负总想从你那里拿走更多，如果你不进行阻止。</p></blockquote><h3 id="第五课：富人的投资"><a href="#第五课：富人的投资" class="headerlink" title="第五课：富人的投资"></a>第五课：富人的投资</h3><blockquote><p>在现实生活中，人们往往是依靠勇气而不是智慧去取得领先的位置的。<br>以我的个人经验来看，要成为财务上的天才既需要专业知识，又需要足够的勇气。如果畏难情绪太重，往往会抑制才能的发挥。</p></blockquote><blockquote><p>我们唯一的，也是最重要的资产是我们的头脑。如果受到良好的训练，它就能创造大量的财富。</p></blockquote><blockquote><p>如果你清楚自己在做什么，就不是在赌博；如果你把钱投进一笔交易然后只是祈祷，才是在赌博。在任何一项投资中，成功的办法都是运用你的技术知识、智慧以及对于这个游戏的热爱来减少意外、降低风险。当然，风险总是存在的，但你的财商可以提高你应付意外的能力。常常有这样的情况，对一个人来说是高风险的事情，对另一个人来说则可能是低风险的。这就是我不断鼓励人们多关注财商教育而不只是投资股票、房地产或其他市场的原因。你越精明，就越能应付意外情况。</p></blockquote><blockquote><p>好机会是用你的脑子而不是用你的眼睛看到的。大部分人无法致富仅仅是因为他们没有受到理财训练，因而不知道机会其实就在眼前。</p></blockquote><ol><li>如何寻找其他人都忽视的机会。</li><li>如何增加资金。</li><li>怎样把精明的人组织起来。</li></ol><blockquote><p>风险总是无处不在，要学会驾驭风险，而别总想回避风险。</p></blockquote><h3 id="第六课：学会不为钱工作"><a href="#第六课：学会不为钱工作" class="headerlink" title="第六课：学会不为钱工作"></a>第六课：学会不为钱工作</h3><blockquote><p>大部分人需要学习和掌握不止一项技能，只有这样他们的收入才能获得显著增长。</p></blockquote><blockquote><p>对许多知识你只需知道一点就够了</p></blockquote><blockquote><p>对于受过良好教育的爸爸来说，工作的稳定就是一切；而对于富爸爸来说，不断学习才是一切。</p></blockquote><blockquote><p>工人付出最大努力以免于被解雇，而雇主提供最低工资以防止工人辞职。</p></blockquote><blockquote><p>世界上到处都是有才华的穷人。在很多情况下，他们贫穷、财务困难或者只能挣到低于他们应得的薪水，不是因为他们已知的东西而是因为他们未知的东西。他们只将注意力集中在提高做汉堡包的技能上，却不注意提高销售和配送汉堡包的技能。也许麦当劳不能做出最好的汉堡包，但他们能在做出一般水平的汉堡包的前提下，做到最好的销售和配送工作。</p></blockquote><h3 id="第七课：克服困难"><a href="#第七课：克服困难" class="headerlink" title="第七课：克服困难"></a>第七课：克服困难</h3><blockquote><p>人们通过学习掌握了财务知识，但在通向财务自由之路上仍面临着许多障碍。资产项可以产生大量的现金流，使人们过上梦想中的生活，而不必整天为了支付账单而忙碌。但掌握财务知识的人有时候还是不能积累丰厚的资产项，其主要原因有5个：</p><ol><li>恐惧心理。</li><li>愤世嫉俗。</li><li>懒惰。</li><li>不良习惯。</li><li>自负。</li></ol></blockquote><blockquote><p>克服恐惧</p><p>富爸爸经常跟我和迈克说，大部分人在财务上不成功的最大原因是他们的做法过于安全。“因为太害怕失败，所以才会失败。”他常这么说。</p><p>对此前美国职业橄榄球联赛的四分卫弗朗·塔肯顿还有另一种说法：“胜利意味着不害怕失败。”</p><p>对于胜利者，失败会激励他们；对于失败者，失败则会击垮他们。</p><p>只是想说明积累资产项其实非常容易，这就像一场低智商的游戏，不需要多高的教育，五年级的数学水平就够了。然而，用资产进行投资却是一种高智商的游戏，需要胆量、耐心和对待失败的良好态度。失败者回避失败，而失败本来是可以使失败者转变为成功者的。</p></blockquote><blockquote><p>克服“愤世嫉俗”心理</p><p>但是，一位聪明的投资者知道，看似最糟糕的时代实际上却是赚钱的最佳时代。当别人都因为太恐惧而不敢行动时，他们却先发制人，收获回报。</p><p>“愤世者永远不会成功。”富爸爸说。“未经证实的怀疑和恐惧会使人们成为愤世嫉俗者。愤世者抱怨现实，而成功者分析现实。”</p></blockquote><blockquote><p>克服懒惰</p><p>富爸爸禁止我们说“我可付不起”这类的话。在我自己的家里，这可是我经常听到的。但富爸爸要求他的孩子们这样说：“我怎样才能付得起？”他的理由是：“我可付不起”这句话禁锢了你的思想，使你无法进一步思考。“我怎样才能付得起”这句话则开启了你的头脑，迫使你去思考并寻求答案。</p><p>对我来说，埃莉诺·罗斯福说的最好：“做你内心认为正确的事情因为你不管怎么做总会受到批评。如果你做，会受到指责；而你不做，还是会受到指责。</p></blockquote><blockquote><p>克服不良习惯</p><p>如果我也学会先支付给自己，就会在财务上更‘强壮’，噢，应该是在精神上和财务上都更加‘强壮’。</p></blockquote><blockquote><p>克服自负</p><p>“我知道的东西给我带来金钱，我不知道的东西使我失去金钱。因为每当我自高自大时，我就认为我不知道的东西并不重要。”富爸爸经常这样告诉我。</p></blockquote><h3 id="第八课：开始行动"><a href="#第八课：开始行动" class="headerlink" title="第八课：开始行动"></a>第八课：开始行动</h3><blockquote><p>在秘鲁，我问一位工作了45年的金矿工人，为什么他对找新的金矿充满信心。他回答说：“金矿到处都是，但大部分人没有经过相应的培训，所以发现不了它们。”</p></blockquote><ol><li><h5 id="找一个超现实的理由——精神的力量"><a href="#找一个超现实的理由——精神的力量" class="headerlink" title="找一个超现实的理由——精神的力量"></a>找一个超现实的理由——精神的力量</h5></li><li><h5 id="每天做出选择——选择的力量"><a href="#每天做出选择——选择的力量" class="headerlink" title="每天做出选择——选择的力量"></a>每天做出选择——选择的力量</h5></li><li><h5 id="慎重地选择朋友——关系的力量"><a href="#慎重地选择朋友——关系的力量" class="headerlink" title="慎重地选择朋友——关系的力量"></a>慎重地选择朋友——关系的力量</h5></li><li><h5 id="掌握一种模式，然后再学习一种新的模式——快速学习的力量"><a href="#掌握一种模式，然后再学习一种新的模式——快速学习的力量" class="headerlink" title="掌握一种模式，然后再学习一种新的模式——快速学习的力量"></a>掌握一种模式，然后再学习一种新的模式——快速学习的力量</h5></li><li><h5 id="首先支付自己——自律的力量"><a href="#首先支付自己——自律的力量" class="headerlink" title="首先支付自己——自律的力量"></a>首先支付自己——自律的力量</h5></li></ol><blockquote><p>穷人有一些不好的习惯，其中一个普遍的坏习惯就是随便动用储蓄。富人知道储蓄只能用于创造更多的收入，而不是用来支付账单。</p></blockquote><ol start="6"><li><h5 id="给你的经纪人以优厚的报酬——好建议的力量"><a href="#给你的经纪人以优厚的报酬——好建议的力量" class="headerlink" title="给你的经纪人以优厚的报酬——好建议的力量"></a>给你的经纪人以优厚的报酬——好建议的力量</h5></li><li><h5 id="给你的经纪人以优厚的报酬——好建议的力量-1"><a href="#给你的经纪人以优厚的报酬——好建议的力量-1" class="headerlink" title="给你的经纪人以优厚的报酬——好建议的力量"></a>给你的经纪人以优厚的报酬——好建议的力量</h5></li><li><h5 id="用资产来购买奢侈品——专注的力量"><a href="#用资产来购买奢侈品——专注的力量" class="headerlink" title="用资产来购买奢侈品——专注的力量"></a>用资产来购买奢侈品——专注的力量</h5></li><li><h5 id="对英雄的崇拜——神话的力量"><a href="#对英雄的崇拜——神话的力量" class="headerlink" title="对英雄的崇拜——神话的力量"></a>对英雄的崇拜——神话的力量</h5></li><li><h5 id="先予后取——给予的力量"><a href="#先予后取——给予的力量" class="headerlink" title="先予后取——给予的力量"></a>先予后取——给予的力量</h5></li></ol><blockquote><p>这使我想起了一个故事，说的是一个人抱着柴火坐在寒冷的夜里，冲着一只大火炉叫道：“你什么时候给我温暖，我就什么时候给你添柴火。”推而广之，当涉及金钱、爱情、幸福、销售和合约等时，都应记住要为自己想要的东西先付出，然后才能得到加倍的回报。</p></blockquote><h3 id="第九课：还想要更多吗？这里有一些要做的事情"><a href="#第九课：还想要更多吗？这里有一些要做的事情" class="headerlink" title="第九课：还想要更多吗？这里有一些要做的事情"></a>第九课：还想要更多吗？这里有一些要做的事情</h3><ul><li>停下你手头的活儿</li><li>寻找新的思想</li><li>找一些做过你想做的事情的人，请他们和你一起共进午餐，向他们请教一些诀窍和技巧</li><li>上辅导班、读书或参加研讨会</li><li>提出多份报价</li><li>每月在某一地区慢跑、散步或驾车10分钟左右</li><li>购买特价商品</li><li>关注适当的地方</li><li>我首先寻找想买进的人，然后才去找想卖出的人</li><li>考虑大生意</li><li>学习前人经验</li><li>行动的人总会击败不行动的人</li></ul><blockquote><p>请牢记：利润是买来的，而不是卖出来的。</p></blockquote><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><blockquote><p>今天，即使只是为了生存下去我们也需要提高自己的财商。只有工作才能赚钱的思想是在理财上不成熟的人才有的。这并不意味着他们不够聪明，他们只是没有学到挣钱的学问。</p></blockquote><blockquote><p>富爸爸常说：“变富有的关键是拥有尽快将劳动性收入转换成被动收入或投资组合收入的能力。”他还说：“劳动性收入的税赋是最重的，而税赋最轻的收入则是被动收入。这也是为什么你要让金钱为你努力工作的另一个原因。政府从你努力工作所得的收入中收的税比你的金钱为你努力工作所得的收入所收的税还高。”</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>启示录：打造用户喜爱的产品</title>
      <link href="2021/06/02/0-du-shu-bi-ji/qi-shi-lu-da-zao-yong-hu-xi-ai-de-chan-pin/"/>
      <url>2021/06/02/0-du-shu-bi-ji/qi-shi-lu-da-zao-yong-hu-xi-ai-de-chan-pin/</url>
      
        <content type="html"><![CDATA[<ul><li>好产品具备三个基本条件：价值、可用性、可行性，三者缺一不可。</li></ul><ul><li>如果开发的产品没有市场价值，那么无论开发团队多么优秀也无济于事。</li></ul><blockquote><p>好产品靠设计</p><p>我从不认为富有创意的产品来自偶然。成功的产品都遵循一定的规律。以下是我总结的十条规律：</p><ol><li>产品经理的任务是探索产品的价值、可用性、可行性。</li><li>探索（定义）产品需要产品经理、交互设计师、软件架构师通力合作。</li><li>开发人员不擅长用户体验设计，因为开发人员脑子里想的是实现模型，而用户看重的是产品的概念模型。</li><li>用户体验设计就是交互设计、视觉设计（对硬件设备来说，则是工业设计）。</li><li>功能（产品需求）和用户体验设计密不可分。</li><li>产品创意必须尽早地、反复地接受目标用户的试用，以便获取有效的用户体验。</li><li>为了验证产品的价值和可用性，必须尽早地、反复地请目标用户测试产品创意。</li><li>采用高保真的产品原型是全体团队成员了解用户需求和用户体验最有效的途径。</li><li>产品经理的目标是在最短的时间内把握复杂的市场／用户需求，确定产品的基本要求——价值、可用性、可行性。</li><li>一旦认定产品符合以上基本要求，它就是一个完整的概念，去掉任何因素，都不可能达到预期的结果。</li></ol></blockquote><blockquote><p>人员常见的问题：由市场营销人员定义产品、两人分担定义产品的工作、一人兼任两项工作。</p><p>要解决这些问题，必须清晰界定产品经理和产品营销人员的职责。产品经理负责详细定义待开发的产品，让真实的用户测试产品。产品营销人员负责向外界宣传和推广产品，负责产品发布，为拓展市场销售渠道、组织重点营销活动（如在线营销）、促进产品销售提供支持。产品经理和产品营销人员应该经常沟通、展开合作。一方面，营销人员是产品经理获取产品需求的重要来源；另一方面，产品经理是营销人员获取市场营销信息的重要来源。</p></blockquote><ul><li>评估产品机会是产品经理的重要职责。评估产品机会的目的在于：淘汰馊主意，避免浪费时间和金钱；挑选合适的产品机会，团结团队，理解产品，整合资源。</li></ul><ul><li>成功的产品基于以下两点认识：深入理解用户需求，以及明白什么样的解决方案在现阶段是可行的。</li></ul><blockquote><p>从业二十多年来，我一直在总结打造富有创意产品的方法。这里分享我认为最重要的十个要点。每个要点在书中都有详细描述，希望这里的汇总能加深读者的印象，建议大家结合实际工作来体会：</p><ol><li>产品管理的职责　许多产品经理将大把的时间浪费在与产品管理无关的工作上，比如，营销管理和项目管理，这些都不是产品经理应该干的活。</li><li>用户体验　对于大多数软件产品来说，用户体验就是产品的生命。产品经理应该与交互设计师、开发人员密切合作，设计良好的用户体验，打造有实用价值的产品。</li><li>机会评估　用方便快捷的机会评估方法取代过时的市场需求文档。动手设计产品前，先明确产品要解决什么问题，为谁解决问题，以及评估产品的标准。</li><li>特约用户　有些产品团队企图绕过用户，直接设计、开发产品，这种想法可笑至极。打造优秀的产品没有任何捷径，只能请用户反复试用产品，不断改进。</li><li>产品原则　产品管理工作的主要内容是制定决策。明确的产品原则可以帮助产品经理和产品团队树立清晰的价值标准，作出果断的决策。</li><li>人物角色　人物角色是协助产品经理制定决策的另一项工具。把目标用户按特征分类，逐一分析、理解其情感和行为，以此作为决策的依据。</li><li>探索（定义）产品　产品经理的主要职责是探索（定义）有价值的、可用的、可行的产品。除非产品经理确定这三点，否则同事的努力都将付之东流。</li><li>使用原型　使用高保真原型是探索（定义）产品的关键步骤。原因如下：第一，迫使产品经理深入定义解决方案；第二，可以让真实的用户参与测试、验证产品创意；第三，可以直观地向团队展示产品的设计思路。</li><li>用户参与原型测试　有了产品原型，产品经理可以方便地请用户验证产品创意。原型测试是所有产品经理和产品设计师都必须掌握的工作技能。获取有效的用户反馈是产品经理最重要的工作。</li><li>根据数据改进产品　成功的产品经理懂得利用数据来改进现有产品。改进产品不是根据客户要求一味增加新功能，而是根据产品的实际应用情况，不断地提升产品的各项指标，逐步完善产品。</li></ol></blockquote><blockquote><p>出色的产品经理会时刻关注产品的现状与未来。以下是产品经理无时无刻不在思考的问题：</p><ol><li><p>产品能吸引目标消费者的关注吗？</p></li><li><p>产品的设计是否人性化，是否易于操作？</p></li><li><p>产品能在竞争中取胜吗？即使是面对未来风云变化的市场，依旧有取胜的把握吗？</p></li><li><p>我了解目标用户吗？产品（不是理想的产品，而是实际开发出来的产品）是否能得到他们的认可？</p></li><li><p>产品是否有别于市面上的其他产品？我能在两分钟内向公司高管清楚地阐明这些差别吗？能在一分钟内向客户解释清楚吗？能在半分钟内向经验丰富的行业分析师解释清楚吗？</p></li><li><p>产品能正常运行吗？</p></li><li><p>产品是否完整？用户对产品的印象如何？销售业绩如何？销售任务能否顺利完成？</p></li><li><p>产品的特色是否与目标用户的需求一致？产品特色是否鲜明？</p></li><li><p>产品值钱吗？值多少钱？为什么值这么多钱？用户会选择更便宜的产品吗？</p></li><li><p>我了解其他团队成员对产品的看法吗？他们觉得产品好在哪里？他们的看法是否与我的观点一致？</p><p>为什么每天的思考时间如此重要，为什么产品经理的工作如此费时？原因就在于这十个问题等着他不断地去琢磨。</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux find指令的exec参数</title>
      <link href="2021/05/31/0-ri-chang-xue-xi/linux-find-zhi-ling-de-exec-can-shu/"/>
      <url>2021/05/31/0-ri-chang-xue-xi/linux-find-zhi-ling-de-exec-can-shu/</url>
      
        <content type="html"><![CDATA[<p>Linux 下找文件经常会用上 find 指令，当用 find 指令找到文件或目录后，可以在后面加上 -exec 参数，来对每一个找到的文件或目录执行特定指令。</p><p>find 指令加上 -exec 参数的具体语法是这样:</p><pre class="line-numbers language-none"><code class="language-none">$ find &#x2F;path&#x2F;to -name “filename” -exec command &#123;&#125; \;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 -exec 前面是 find 指令找出想要的文件，在 -exec 后面的 command 是要执行的指令, 而 { } 包着的是找到的文件或目录，后面需要加上 ; 完结。</p><p>以下是几个 find -exec 的使用例子：</p><p>搜寻并删除所有大过 100MB 的档案：</p><pre class="line-numbers language-none"><code class="language-none">$ find &#x2F;path&#x2F;to -size +100M -exec &#x2F;bin&#x2F;rm &#123;&#125; \;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>找出 .log.old 结尾的档案并删除:</p><pre class="line-numbers language-none"><code class="language-none">$ find &#x2F;path&#x2F;to -name “*.log.old” -exec &#x2F;bin&#x2F;rm &#123;&#125; \;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将所有档案 .php 档案改变权限为 644:</p><pre class="line-numbers language-none"><code class="language-none">$ find &#x2F;path&#x2F;to -name “*.php” -exec chmod 644 &#123;&#125; \;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将所有目录改变权限为 755:</p><pre class="line-numbers language-none"><code class="language-none">$ find &#x2F;path&#x2F;to -type d -exec chmod 755 &#123;&#125; \;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将所有属于 “olduser” 的档案，改变为 “newuser”:</p><pre class="line-numbers language-none"><code class="language-none">$ find &#x2F;path&#x2F;to -user olduser -exec chown newuser &#123;&#125; \;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>新零售：吹响第四次零售革命的号角</title>
      <link href="2021/05/31/0-du-shu-bi-ji/xin-ling-shou-chui-xiang-di-si-ci-ling-shou-ge-ming-de-hao-jiao/"/>
      <url>2021/05/31/0-du-shu-bi-ji/xin-ling-shou-chui-xiang-di-si-ci-ling-shou-ge-ming-de-hao-jiao/</url>
      
        <content type="html"><![CDATA[<ul><li>刘慈欣在《三体》中说：“弱小和无知不是生存的障碍，而傲慢才是。”</li></ul><ul><li>万物皆有裂痕，那是光照进来的地方。</li></ul><p>​        马云说：“纯电商已死，新零售已来，变革超乎我们想象！” 新零售是毁灭过去，还是迎接未来？有人诚惶诚恐，如履薄冰；有人兴高采烈，跨步向前！回顾2017年，新零售已经人尽皆知，阿里巴巴、京东等电商巨头，银泰、王府井等传统零售商纷纷合纵连横，新物种迎来大爆发，各种新场景、新体验新鲜出炉。</p><p>　　那么，什么是新零售呢？</p><p>　　当Amazon Go无人门店出现的时候，人们认为这就是新零售：无需排队，无需付款，拿货即走，极致便利。于是无人门店成了资本追逐的风口，潮起潮落，谁在裸泳？</p><p>　　当盒马生鲜出现的时候，大家又开始惊呼：这才是新零售的模板！于是它“四不像”的超市新型业态成了追捧的对象，成了零售业的“网红”。</p><p>　　纷繁的信息扑来，你会发现：其实，我们根本不懂新零售！</p><p>　　在《新零售：吹响第四次零售革命的号角》一书中为我们厘清了新零售的概念，指出新零售是消费者赋能，新零售是供给侧改革，新零售是数字化革命，新零售是围绕着用户体验的零售革命。系统全面地介绍了新零售的“前世今生”，并诠释了以下一系列问题。</p><p>　　这本书在消费升级和互联网技术催生第四次零售革命的背景下，系统性地解读了新零售的概念、特征和形态，并指出新零售就是以用户为中心，数据赋能下为消费者提供升维体验的实时“在线”的全渠道场景。详细介绍了在新零售时代零售企业如何重构商业模式，并通过大量案例进行全面精彩地诠释。主要包括以下内容：</p><ol><li>消费4.0时代到来，三大变革催生了新零售，并促进了零售新物种的大爆发，阿里巴巴、京东、万达等企业纷纷转型强势布局新零售，一场没有硝烟的战争一触即发。</li><li>新零售是围绕着消费体验的零售革命，具有典型的女性主义特征，零售企业要学会玩场景、玩数据、玩情怀，打造有趣、有心、有爱的零售体验，未来，新零售能实现的消费愿景就是“所想即所得，所得即所爱”。</li><li>用升维打击的思想，为零售企业给出一个“新零售之锥”的升维体验商业模式，即通过消费场景、数据赋能和会员营销三个维度的叠加组合打造极致的用户体验，并介绍了新零售时代升维体验的四种玩法。</li><li>指出新零售吹响了第四次零售革命的号角，并预言未来的新零售终极形态是“云零售”，供应链和零售渠道将会实现云转型，未来零售企业的商业模式将是S2b。</li></ol><p>　　其中几个主要观点让我受益匪浅：</p><ul><li><p>消费变革、渠道变革、技术变革三大变革催生了新零售，新零售呈现出典型的“女性主义”特征，消费者追求产品、服务和消费的叠加体验，为了虏获“女性主义”的消费者，要打造有趣、有心、有爱的升维零售体验。</p></li><li><p>在新零售时代，零售企业要有一种“升维打击”的思维模式，通过打造消费场景，利用数据赋能，强化会员营销，零售企业要学会玩场景、玩数据、玩社群，打造一种三位一体的升维体验商业模式。</p></li><li><p>新零售吹响了第四次零售革命的号角，未来的新零售终极形态是“云零售”，供应链和零售渠道将会实现云转型，未来零售企业的商业模式将是S2b。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Find指令详解</title>
      <link href="2021/05/27/0-ri-chang-xue-xi/find-zhi-ling-xiang-jie/"/>
      <url>2021/05/27/0-ri-chang-xue-xi/find-zhi-ling-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux中find命令用法全汇总，看完就没有不会用的！"><a href="#Linux中find命令用法全汇总，看完就没有不会用的！" class="headerlink" title="Linux中find命令用法全汇总，看完就没有不会用的！"></a>Linux中find命令用法全汇总，看完就没有不会用的！</h1><p>Linux 查找命令是Linux系统中最重要和最常用的命令之一。查找可以在各种条件下使用，您可以通过权限，用户，组，文件类型，日期，大小等可能的条件查找文件。         </p><p>通过这篇文章，我们以实例的形式分享我们的日常Linux查找命令体验及其用法。在本文中，我们将分五个部分向您展示Linux中最常用的35查找命令示例：</p><hr><ul><li>第一部分：查找名称查找文件的基本查找命令</li><li>第二部分：根据他们的权限查找文件</li><li>第三部分：基于所有者和组的搜索文件</li><li>第四部分：根据日期和时间查找文件和目录</li><li>第五部分：根据大小查找文件和目录</li></ul><blockquote><p><strong>第一部分 - 查找名称查找文件的基本查找命令</strong></p></blockquote><h4 id="1-使用当前目录中的名称查找文件"><a href="#1-使用当前目录中的名称查找文件" class="headerlink" title="1.使用当前目录中的名称查找文件"></a>1.使用当前目录中的名称查找文件</h4><p>在当前工作目录中查找名称为test.c的所有文件：</p><p><img src="/2021/05/27/0-ri-chang-xue-xi/find-zhi-ling-xiang-jie/1.png"></p><hr><h4 id="2-在主目录下查找文件"><a href="#2-在主目录下查找文件" class="headerlink" title="2.在主目录下查找文件"></a>2.在主目录下查找文件</h4><p>查找/ home目录下的所有文件，名称为test：</p><p><img src="/2021/05/27/0-ri-chang-xue-xi/find-zhi-ling-xiang-jie/2.png"></p><p>  (上文中的前面两个find没有权限)</p><hr><h4 id="3-使用名称和忽略案例查找文件"><a href="#3-使用名称和忽略案例查找文件" class="headerlink" title="3.使用名称和忽略案例查找文件"></a>3.使用名称和忽略案例查找文件</h4><p>大小写不敏感地在/ home目录中找到名称为test的所有文件：</p><p><img src="/2021/05/27/0-ri-chang-xue-xi/find-zhi-ling-xiang-jie/3.png"></p><hr><h4 id="4-使用名称查找目录"><a href="#4-使用名称查找目录" class="headerlink" title="4.使用名称查找目录"></a>4.使用名称查找目录</h4><p>在/目录中查找名称为test的所有目录：</p><p><img src="/2021/05/27/0-ri-chang-xue-xi/find-zhi-ling-xiang-jie/4.png"></p><hr><h4 id="5-使用名称查找PHP文件"><a href="#5-使用名称查找PHP文件" class="headerlink" title="5.使用名称查找PHP文件"></a>5.使用名称查找PHP文件</h4><p>在当前工作目录中查找名为test.PHP的所有PHP文件：</p><p><img src="/2021/05/27/0-ri-chang-xue-xi/find-zhi-ling-xiang-jie/5.png"></p><hr><h4 id="6-查找目录中的所有PHP文件"><a href="#6-查找目录中的所有PHP文件" class="headerlink" title="6.查找目录中的所有PHP文件"></a>6.查找目录中的所有PHP文件</h4><p>查找目录中的所有php文件：</p><p><img src="/2021/05/27/0-ri-chang-xue-xi/find-zhi-ling-xiang-jie/6.png"></p><hr><blockquote><p><strong>第二部分 - 根据他们的权限查找文件</strong></p></blockquote><hr><h4 id="7-查找777个权限的文件"><a href="#7-查找777个权限的文件" class="headerlink" title="7.查找777个权限的文件"></a>7.查找777个权限的文件</h4><p>查找权限为777的所有文件：</p><p><img src="/2021/05/27/0-ri-chang-xue-xi/find-zhi-ling-xiang-jie/7.png"></p><hr><h4 id="8-查找没有777权限的文件"><a href="#8-查找没有777权限的文件" class="headerlink" title="8.查找没有777权限的文件"></a>8.查找没有777权限的文件</h4><p>查找所有文件未经许可777：</p><p><img src="/2021/05/27/0-ri-chang-xue-xi/find-zhi-ling-xiang-jie/8.png"></p><hr><h4 id="9-查找具有644个权限的SGID文件"><a href="#9-查找具有644个权限的SGID文件" class="headerlink" title="9.查找具有644个权限的SGID文件"></a>9.查找具有644个权限的SGID文件</h4><p>查找权限设置为644的所有SGID位文件：</p><p><img src="/2021/05/27/0-ri-chang-xue-xi/find-zhi-ling-xiang-jie/9.png"></p><hr><h4 id="10-找到具有551权限的粘滞位文件"><a href="#10-找到具有551权限的粘滞位文件" class="headerlink" title="10.找到具有551权限的粘滞位文件"></a>10.找到具有551权限的粘滞位文件</h4><p>查找权限为551的所有Sticky Bit设置文件：</p><p><img src="/2021/05/27/0-ri-chang-xue-xi/find-zhi-ling-xiang-jie/10.png"></p><hr><h4 id="11-查找SUID文件"><a href="#11-查找SUID文件" class="headerlink" title="11.查找SUID文件"></a>11.查找SUID文件</h4><p>查找所有SUID集文件：</p><p><img src="/2021/05/27/0-ri-chang-xue-xi/find-zhi-ling-xiang-jie/11.png"></p><hr><h4 id="12-查找SGID文件"><a href="#12-查找SGID文件" class="headerlink" title="12.查找SGID文件"></a>12.查找SGID文件</h4><p>查找所有SGID设置文件：</p><p><img src="/2021/05/27/0-ri-chang-xue-xi/find-zhi-ling-xiang-jie/12.png"></p><hr><h4 id="13-查找只读文件"><a href="#13-查找只读文件" class="headerlink" title="13.查找只读文件"></a>13.查找只读文件</h4><p>查找所有只读文件：</p><p><img src="/2021/05/27/0-ri-chang-xue-xi/find-zhi-ling-xiang-jie/13.png"></p><hr><h4 id="14-查找可执行文件"><a href="#14-查找可执行文件" class="headerlink" title="14.查找可执行文件"></a>14.查找可执行文件</h4><p>查找所有可执行文件：</p><p><img src="/2021/05/27/0-ri-chang-xue-xi/find-zhi-ling-xiang-jie/14.png"></p><hr><h4 id="15-找到777个权限和Chmod到644的文件"><a href="#15-找到777个权限和Chmod到644的文件" class="headerlink" title="15.找到777个权限和Chmod到644的文件"></a>15.找到777个权限和Chmod到644的文件</h4><p>查找所有777个权限文件，并使用chmod命令将权限设置为644：</p><p><img src="/2021/05/27/0-ri-chang-xue-xi/find-zhi-ling-xiang-jie/15.png"></p><hr><h4 id="16-找到具有777个权限的目录和Chmod到755"><a href="#16-找到具有777个权限的目录和Chmod到755" class="headerlink" title="16.找到具有777个权限的目录和Chmod到755"></a>16.找到具有777个权限的目录和Chmod到755</h4><p>查找所有777个权限目录，并使用chmod命令将权限设置为755：</p><p><img src="/2021/05/27/0-ri-chang-xue-xi/find-zhi-ling-xiang-jie/16.png"></p><hr><h4 id="17-查找并删除单个文件"><a href="#17-查找并删除单个文件" class="headerlink" title="17.查找并删除单个文件"></a>17.查找并删除单个文件</h4><p>找到一个名为test.c的文件并将其删除：</p><p><img src="/2021/05/27/0-ri-chang-xue-xi/find-zhi-ling-xiang-jie/17.png"></p><hr><h4 id="18-查找并删除多个文件"><a href="#18-查找并删除多个文件" class="headerlink" title="18.查找并删除多个文件"></a>18.查找并删除多个文件</h4><p>查找和删除多个文件，如.mp3或.txt，然后使用：</p><p><img src="/2021/05/27/0-ri-chang-xue-xi/find-zhi-ling-xiang-jie/18.png"></p><hr><h4 id="19-查找所有空文件"><a href="#19-查找所有空文件" class="headerlink" title="19.查找所有空文件"></a>19.查找所有空文件</h4><p>在特定路径下查找所有空文件：</p><p><img src="/2021/05/27/0-ri-chang-xue-xi/find-zhi-ling-xiang-jie/19.png"></p><hr><h4 id="20-查找所有空目录"><a href="#20-查找所有空目录" class="headerlink" title="20.查找所有空目录"></a>20.查找所有空目录</h4><p>将特定路径下的所有空目录归档：</p><p><img src="/2021/05/27/0-ri-chang-xue-xi/find-zhi-ling-xiang-jie/20.png"></p><hr><h4 id="21-文件所有隐藏文件"><a href="#21-文件所有隐藏文件" class="headerlink" title="21.文件所有隐藏文件"></a>21.文件所有隐藏文件</h4><p>要查找所有隐藏的文件，请使用以下命令：</p><p><img src="/2021/05/27/0-ri-chang-xue-xi/find-zhi-ling-xiang-jie/21.png"></p><hr><blockquote><p><strong>第三部分 - 基于所有者和组的搜索文件</strong></p></blockquote><hr><h4 id="22-查找基于用户的单个文件"><a href="#22-查找基于用户的单个文件" class="headerlink" title="22.查找基于用户的单个文件"></a>22.查找基于用户的单个文件</h4><p>在所有者root的/ root目录下查找名为test.c的所有或单个文件：</p><p><img src="/2021/05/27/0-ri-chang-xue-xi/find-zhi-ling-xiang-jie/22.png"></p><hr><h4 id="23-查找基于用户的所有文件"><a href="#23-查找基于用户的所有文件" class="headerlink" title="23.查找基于用户的所有文件"></a>23.查找基于用户的所有文件</h4><p>查找~目录下属于用户neil的所有文件：</p><p><img src="/2021/05/27/0-ri-chang-xue-xi/find-zhi-ling-xiang-jie/23.png"></p><hr><h4 id="24-查找基于组的所有文件"><a href="#24-查找基于组的所有文件" class="headerlink" title="24.查找基于组的所有文件"></a>24.查找基于组的所有文件</h4><p>查找/ home目录下属于Group Developer的所有文件：</p><p><img src="/2021/05/27/0-ri-chang-xue-xi/find-zhi-ling-xiang-jie/24.png"></p><hr><h4 id="25-查找用户的特定文件"><a href="#25-查找用户的特定文件" class="headerlink" title="25.查找用户的特定文件"></a>25.查找用户的特定文件</h4><p>查找~目录下的用户neil的所有.txt文件：</p><p><img src="/2021/05/27/0-ri-chang-xue-xi/find-zhi-ling-xiang-jie/25.png"></p><hr><blockquote><p><strong>第四部分 - 根据日期和时间查找文件和目录</strong></p></blockquote><hr><h4 id="26-查找最近50天修改的文件"><a href="#26-查找最近50天修改的文件" class="headerlink" title="26.查找最近50天修改的文件"></a>26.查找最近50天修改的文件</h4><p>查找当前目录下，最近50天前修改过的常规文件：</p><pre class="line-numbers language-none"><code class="language-none">find . -type f -mtime +50<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h4 id="27-查找最近50天访问的文件"><a href="#27-查找最近50天访问的文件" class="headerlink" title="27.查找最近50天访问的文件"></a>27.查找最近50天访问的文件</h4><p>查找50天后访问的所有文件：</p><p><img src="/2021/05/27/0-ri-chang-xue-xi/find-zhi-ling-xiang-jie/27.png"></p><hr><h4 id="28-查找最后50-100天修改的文件"><a href="#28-查找最后50-100天修改的文件" class="headerlink" title="28.查找最后50-100天修改的文件"></a>28.查找最后50-100天修改的文件</h4><p>查找所有被修改超过50天以及少于100天的文件：</p><p><img src="/2021/05/27/0-ri-chang-xue-xi/find-zhi-ling-xiang-jie/28.png"></p><hr><h4 id="29-在过去1小时内查找更改的文件"><a href="#29-在过去1小时内查找更改的文件" class="headerlink" title="29.在过去1小时内查找更改的文件"></a>29.在过去1小时内查找更改的文件</h4><p>查找最近1小时内更改的所有文件：</p><p><img src="/2021/05/27/0-ri-chang-xue-xi/find-zhi-ling-xiang-jie/29.png"></p><hr><h4 id="30-在最近1小时内查找修改的文件"><a href="#30-在最近1小时内查找修改的文件" class="headerlink" title="30.在最近1小时内查找修改的文件"></a>30.在最近1小时内查找修改的文件</h4><p>查找最近1小时内修改的所有文件：</p><p><img src="/2021/05/27/0-ri-chang-xue-xi/find-zhi-ling-xiang-jie/30.png"></p><hr><h4 id="31-查找最近1小时内访问的文件"><a href="#31-查找最近1小时内访问的文件" class="headerlink" title="31.查找最近1小时内访问的文件"></a>31.查找最近1小时内访问的文件</h4><p>查找最近1小时内访问的所有文件：</p><p><img src="/2021/05/27/0-ri-chang-xue-xi/find-zhi-ling-xiang-jie/31.png"></p><hr><blockquote><p><strong>第五部分 - 根据大小查找文件和目录</strong></p></blockquote><hr><h4 id="32-找到50MB的文件"><a href="#32-找到50MB的文件" class="headerlink" title="32.找到50MB的文件"></a>32.找到50MB的文件</h4><p>要找到所有50MB的文件，请使用：</p><p><img src="/2021/05/27/0-ri-chang-xue-xi/find-zhi-ling-xiang-jie/32.png" alt="32"></p><hr><h4 id="33-查找大小在50MB到100MB之间"><a href="#33-查找大小在50MB到100MB之间" class="headerlink" title="33.查找大小在50MB到100MB之间"></a>33.查找大小在50MB到100MB之间</h4><p>找到大于50MB且小于100MB的所有文件：</p><p><img src="/2021/05/27/0-ri-chang-xue-xi/find-zhi-ling-xiang-jie/33.png"></p><hr><h4 id="34-查找并删除100MB的文件"><a href="#34-查找并删除100MB的文件" class="headerlink" title="34.查找并删除100MB的文件"></a>34.查找并删除100MB的文件</h4><p>查找所有100MB文件并使用一个命令删除它们：</p><p><img src="/2021/05/27/0-ri-chang-xue-xi/find-zhi-ling-xiang-jie/34.png"></p><h4 id="35-查找特定文件并删除"><a href="#35-查找特定文件并删除" class="headerlink" title="35.查找特定文件并删除"></a>35.查找特定文件并删除</h4><p>查找超过10MB的所有.mp3文件，并使用一个命令删除它们：</p><p><img src="/2021/05/27/0-ri-chang-xue-xi/find-zhi-ling-xiang-jie/35.png"></p><p>这35个命令，基本上汇总了find命令的大部分用法，当然，想要穷尽也是非常难得。如果你有一些不为人知的使用技巧，欢迎在下方评论区留言哦！</p>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Makefile组织结构及编译控制</title>
      <link href="2021/05/21/0-ri-chang-xue-xi/makefile-zu-zhi-jie-gou-ji-bian-yi-kong-zhi/"/>
      <url>2021/05/21/0-ri-chang-xue-xi/makefile-zu-zhi-jie-gou-ji-bian-yi-kong-zhi/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/05/21/0-ri-chang-xue-xi/makefile-zu-zhi-jie-gou-ji-bian-yi-kong-zhi/11.png"></p><center>Makefile文件的组织结构</center><center>注解详见：<a herf="https://www.bbsmax.com/A/1O5EpQLnJ7/">https://www.bbsmax.com/A/1O5EpQLnJ7/</a></center><p>列出makefile中跟目标有关的语法：</p><blockquote><p>[目标1]：[依赖]</p><p>[[命令1]</p><p>[[命令2]</p><p>[[目标2]：[依赖]</p><p>[[命令1]</p><p>[[命令2]</p></blockquote><p>注解：</p><blockquote><p>1）目标：指make要做的事情，可以是一个简单的代号，也可以是目标文件，需要顶格书写，前面不能有空格或Tab。一个Makefile可以有多个目标，写在最前面的第一个目标，会被Make程序确立为 “默认目标”；</p><p>2）依赖：要达成目标需要依赖的某些文件或其它目标；</p><p>3）命令1，命令2…命令n：make达成目标所需要的命令。只有当目标不存在或依赖文件的修改时间比目标文件还要新时，才会执行命令。要特别注意命令的开头要用“Tab”键，不能使用空格代替，有的编辑器会把Tab键自动转换成空格导致出错，若出现这种情况请检查自己的编辑器配置；</p></blockquote><p>下面列举一个实例展示makefile实现编译控制的方法：</p><p>现有三个文件：hello_main.c主文件，hello_func.c函数文件，hello_func.h头文件，hello_main.c的main主函数调用了hello_func.c文件的打印函数，而打印函数在hello_func.h文件中声明。</p><p>hello_main.c主文件</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">\#include <span class="token string">"hello_func.h"</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">hello_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>hello_func.c函数文件</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">\#include <span class="token operator">&lt;</span>stdio<span class="token punctuation">.</span>h<span class="token operator">></span>    \#include <span class="token string">"hello_func.h"</span><span class="token keyword">void</span> <span class="token function">hello_func</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello, world! This is a C program.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"output i=%d\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>hello_func.h头文件</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">hello_func</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>则可以编写makefile代码如下：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment">#Makefile格式</span><span class="token comment">#目标:依赖</span><span class="token comment">#Tab 命令1</span><span class="token comment">#Tab 命令2</span><span class="token comment">#默认目标</span><span class="token comment">#hello_main依赖于hello_main.c和hello_func.c文件</span><span class="token symbol">hello_main</span><span class="token punctuation">:</span> hello_main.c hello_func.c gcc -o hello_main hello_main.c hello_func.c -I<span class="token comment">#clean目标，用来删除编译生成的文件</span><span class="token symbol">clean</span><span class="token punctuation">:</span> rm -f *.o hello_main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该文件定义了默认目标hello_main用于编译程序，clean目标用于删除编译生成的文件。特别地，其中hello_main目标名与gcc编译生成的文件名”gcc -o hello_main”设置成一致了，也就是说，此处的目标hello_main在Makefile看来，已经是一个目标文件hello_main。这样的好处是make每次执行的时候，会检查hello_main文件和依赖文件hello_main.c、hello_func.c的修改日期，如果依赖文件的修改日期比hello_main文件的日期新，那么make会执行目标其下的Shell命令更新hello_main文件，否则不会执行。如此便实现了编译控制。</p>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux kernel启动流程学习</title>
      <link href="2021/05/21/0-ri-chang-xue-xi/linux-kernel-qi-dong-liu-cheng-xue-xi/"/>
      <url>2021/05/21/0-ri-chang-xue-xi/linux-kernel-qi-dong-liu-cheng-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="前导知识"><a href="#前导知识" class="headerlink" title="前导知识"></a><strong>前导知识</strong></h1><p>Linux内核的启动过程可以分为两部分：架构/开发板的相关引导过程，后续的通用启动过程</p><p>1.<strong>引导阶段</strong>通常使用汇编语言编写，它首先检查内核是否支持当前架构的处理器，然后检查是否支持当前开发板。通过检查后，就为调用下一阶段的start_kernel函数做准备，这主要分为两个步骤：</p><blockquote><ul><li>设置页表，使能MMU</li><li>调用c函数start_kernel之前的常规工作，包括复制数据段，清除BSS段，调用start_kernel函数</li></ul></blockquote><p>2.第二阶段的关键代码主要使用c语言编写，它进行内核初始化的全部工作，最后调用rest_init函数启动init过程，创建系统的第一个进程：init进程。在第二个阶段，仍有部分架构、开发板相关的代码</p><p><img src="/2021/05/21/0-ri-chang-xue-xi/linux-kernel-qi-dong-liu-cheng-xue-xi/1.png"></p><center>下面图解ARM-Linux的启动全过程：内核自解压阶段—>内核引导阶段—>内核初始化阶段—>BusyBox初始化阶段</center><p><img src="/2021/05/21/0-ri-chang-xue-xi/linux-kernel-qi-dong-liu-cheng-xue-xi/2.png"></p><h1 id="Linux-kernel启动流程："><a href="#Linux-kernel启动流程：" class="headerlink" title="Linux kernel启动流程："></a>Linux kernel启动流程：</h1><h3 id="执行arch-arm-kernel-head-armv-S"><a href="#执行arch-arm-kernel-head-armv-S" class="headerlink" title="执行arch/arm/kernel/head-armv.S"></a>执行arch/arm/kernel/head-armv.S</h3><p>该文件是内核最先执行的一个文件，包括内核入口ENTRY(stext)到start_kernel间的初始化代码，</p><p><strong>主要作用</strong>是检查CPU ID， Architecture Type，初始化BSS等操作，并跳到start_kernel函数。在执行前，处理器应满足以下状态： </p><blockquote><p>r0 - should be 0<br>r1 - unique architecture number<br>MMU - off<br>I-cache - on or off<br>D-cache – off </p></blockquote><pre class="line-numbers language-none"><code class="language-none"> 1 &#x2F;* 部分源代码分析 *&#x2F;  2 &#x2F;* 内核入口点 *&#x2F;  3 ENTRY(stext)  4 &#x2F;* 程序状态，禁止FIQ、IRQ，设定SVC模式 *&#x2F;  5 mov r0, #F_BIT | I_BIT | MODE_SVC@ make sure svc mode  6 &#x2F;* 置当前程序状态寄存器 *&#x2F;  7 msr cpsr_c, r0 @ and all irqs disabled  8 &#x2F;* 判断CPU类型，查找运行的CPU ID值与Linux编译支持的ID值是否支持 *&#x2F;  9 bl __lookup_processor_type 10 &#x2F;* 跳到__error *&#x2F; 11 teq r10, #0 @ invalid processor? 12 moveq r0, #&#39;p&#39; @ yes, error &#39;p&#39; 13 beq __error 14 &#x2F;* 判断体系类型，查看R1寄存器的Architecture Type值是否支持 *&#x2F; 15 bl __lookup_architecture_type 16 &#x2F;* 不支持，跳到出错 *&#x2F; 17 teq r7, #0 @ invalid architecture? 18 moveq r0, #&#39;a&#39; @ yes, error &#39;a&#39; 19 beq __error 20 &#x2F;* 创建核心页表 *&#x2F; 21 bl __create_page_tables 22 adr lr, __ret @ return address 23 add pc, r10, #12 @ initialise processor 24 &#x2F;* 跳转到start_kernel函数 *&#x2F; 25 b start_kernel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="start-kernel中进行各项初始化工作（例如cpu，irq，时钟，cmd参数解析，console初始化等等……）"><a href="#start-kernel中进行各项初始化工作（例如cpu，irq，时钟，cmd参数解析，console初始化等等……）" class="headerlink" title="start_kernel中进行各项初始化工作（例如cpu，irq，时钟，cmd参数解析，console初始化等等……）"></a>start_kernel中进行各项初始化工作（例如cpu，irq，时钟，cmd参数解析，console初始化等等……）</h3><p>start_kernel ()函数完成Linux内核的初始化工作。几乎每天内核部件都是由这个函数进行初始化的，例如：</p><blockquote><ul><li>调用sched_init()函数来初始化调度程序；</li><li>调用build_all_zonelists()函数来初始化内存管理区；</li><li>调用page_alloc_init()函数来初始化伙伴系统分配程序；</li><li>调用trap_init()函数和init_IRQ()函数以完成IDT初始化；</li><li>调用softirq_init()函数初始化TASKLET_SOFTIRQ和HI_SOFTIRQ；</li><li>调用time_init()函数来初始化系统日期和时间；</li><li>调用kmem_cache_init()函数来初始化slab分配器；</li><li>调用calibrate_delay()函数以确定CPU时钟的速度；</li><li>调用kernel_thread()函数为进程1创建内核线程，这个内核线程又会创建其他的内核线程并执行sbin/init程序</li></ul></blockquote><p>现对start_kernel()函数及其相关函数进行具体分析：</p><ul><li><h3 id="lock-kernel"><a href="#lock-kernel" class="headerlink" title="lock_kernel()"></a>lock_kernel()</h3></li></ul><pre class="line-numbers language-none"><code class="language-none"> 1 &#x2F;* Getting the big kernel lock.  2 * This cannot happen asynchronously,  3 * so we only need to worry about other  4 * CPU&#39;s.  5 *&#x2F;  6 extern __inline__ void lock_kernel(void)  7 &#123;  8     if (!++current-&gt;lock_depth)  9     spin_lock(&amp;kernel_flag); 10 &#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>kernel_flag</strong> 是一个内核大自旋锁，所有进程都通过这个大锁来实现向内核态的迁移。</p><p>只有获得这个大自旋锁的处理器可以进入内核，如中断处理程序等。在任何一对 lock_kernel／unlock_kernel函数里至多可以有一个程序占用CPU。</p><p>进程的lock_depth成员初始化为-1，在 kerenl/fork.c文件中设置。在它小于0时 （恒为 -1），进程不拥有内核锁；当大于或等于0时，进程得到内核锁。</p><ul><li><h3 id="setup-arch"><a href="#setup-arch" class="headerlink" title="setup_arch()"></a>setup_arch()</h3></li></ul><p>**setup_arch()**函数做体系相关的初始化工作，函数的定义在arch/arm/kernel/setup.c文件中，主要涉及下列主要函数及代码。 </p><p><strong>setup_processor()</strong> 该函数主要通过</p><pre class="line-numbers language-none"><code class="language-none">for (list &#x3D; &amp;__proc_info_begin; list &lt; &amp;__proc_info_end ; list++) if ((processor_id &amp; list-&gt;cpu_mask) &#x3D;&#x3D; list-&gt;cpu_val) break; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样一个循环来在.<a href="http://proc.info/">proc.info</a>段中寻找匹配的processor_id，processor_id在head_armv.S文件中设置。 </p><h4 id="setup-architecture-machine-arch-type-该函数获得体系结构的信息，返回mach-xxx-arch-c-文件中定义的machine结构体的指针，包含以下内容"><a href="#setup-architecture-machine-arch-type-该函数获得体系结构的信息，返回mach-xxx-arch-c-文件中定义的machine结构体的指针，包含以下内容" class="headerlink" title="setup_architecture(machine_arch_type) 该函数获得体系结构的信息，返回mach-xxx/arch.c 文件中定义的machine结构体的指针，包含以下内容"></a><strong>setup_architecture(machine_arch_type)</strong> 该函数获得体系结构的信息，返回mach-xxx/arch.c 文件中定义的machine结构体的指针，包含以下内容</h4><pre class="line-numbers language-none"><code class="language-none">MACHINE_START (xxx, “xxx”) MAINTAINER (&quot;xxx&quot; BOOT_MEM (xxx, xxx, xxx) FIXUP (xxx) MAPIO (xxx) INITIRQ (xxx) MACHINE_END <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="内存设置代码"><a href="#内存设置代码" class="headerlink" title="内存设置代码"></a>内存设置代码</h4><pre class="line-numbers language-none"><code class="language-none">if (meminfo.nr_banks &#x3D;&#x3D; 0) &#123;     meminfo.nr_banks &#x3D; 1;     meminfo.bank[0].start &#x3D; PHYS_OFFSET;     meminfo.bank[0].size &#x3D; MEM_SIZE; &#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>meminfo结构表明内存情况，是对物理内存结构meminfo的默认初始化。nr_banks指定内存块的数量，bank指定每块内存的范围，PHYS _OFFSET指定某块内存块的开始地址，MEM_SIZE指定某块内存块长度。 PHYS _OFFSET和MEM_SIZE都定义在include/asm-armnommu/arch-XXX/memory.h文件中，其中 PHYS _OFFSET是内存的开始地址，MEM_SIZE就是内存的结束地址。这个结构在接下来内存的初始化代码中起重要作用。</p><h4 id="内核内存空间管理"><a href="#内核内存空间管理" class="headerlink" title="内核内存空间管理"></a>内核内存空间管理</h4><pre class="line-numbers language-none"><code class="language-none">init_mm.start_code &#x3D; (unsigned long) &amp;_text; 内核代码段开始 init_mm.end_code &#x3D; (unsigned long) &amp;_etext; 内核代码段结束 init_mm.end_data &#x3D; (unsigned long) &amp;_edata; 内核数据段开始 init_mm.brk &#x3D; (unsigned long) &amp;_end; 内核数据段结束 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>每一个任务都有一个<strong>mm_struct</strong>结构管理其内存空间，init_mm 是内核的mm_struct。其中设置成员变量* mmap指向自己， 意味着内核只有一个内存管理结构，设置 pgd=swapper_pg_dir，swapper_pg_dir是内核的页目录，ARM体系结构的内核页目录大小定义为16k。init_mm定义了整个内核的内存空间，内核线程属于内核代码，同样使用内核空间，其访问内存空间的权限与内核一样。 </p><h4 id="内存结构初始化"><a href="#内存结构初始化" class="headerlink" title="内存结构初始化"></a>内存结构初始化</h4><p>bootmem_init (&amp;meminfo)函数根据meminfo进行内存结构初始化。</p><p>bootmem_init(&amp;meminfo)函数中调用reserve_node_zero(bootmap_pfn, bootmap_pages) 函数，这个函数的作用是保留一部分内存使之不能被动态分配。</p><p>这些内存块包括：</p><pre class="line-numbers language-none"><code class="language-none">reserve_bootmem_node(pgdat, __pa(&amp;_stext), &amp;_end - &amp;_stext); &#x2F;*内核所占用地址空间*&#x2F; reserve_bootmem_node(pgdat, bootmap_pfn&lt;&lt;PAGE_SHIFT, bootmap_pages&lt;&lt;PAGE_SHIFT) &#x2F;*bootmem结构所占用地址空间*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="paging-init-amp-meminfo-mdesc"><a href="#paging-init-amp-meminfo-mdesc" class="headerlink" title="paging_init(&amp;meminfo, mdesc)"></a>paging_init(&amp;meminfo, mdesc)</h4><p>创建内核页表，映射所有物理内存和IO空间，对于不同的处理器，该函数差别比较大。</p><p>下面简单描述一下<strong>ARM体系结构的存储系统及MMU相关的概念。</strong></p><p>在ARM存储系统中，使用内存管理单元(MMU)实现虚拟地址到实际物理地址的映射。</p><p>利用MMU，可把SDRAM的地址完全映射到0x0起始的一片连续地址空间，而把原来占据这片空间的FLASH或者ROM映射到其他不相冲突的存储空间位置。</p><p>例如，FLASH的地址从0x0000 0000～0x00FFFFFF，而SDRAM的地址范围是0x3000 0000～0x3lFFFFFF，则可把SDRAM地址映射为0x0000 0000～0xlFFFFFF，而FLASH的地址可以映射到0x9000 0000～0x90FFFFFF(此处地址空间为空闲，未被占用)。映射完成后，如果处理器发生异常，假设依然为IRQ中断，PC指针指向0xl8处的地址，而这个时候PC实际上是从位于物理地址的0x3000 0018处读取指令。</p><p>通过MMU的映射，则可实现程序完全运行在SDRAM之中。在实际的应用中．可能会把两片不连续的物理地址空间分配给SDRAM。而在操作系统中，习惯于把SDRAM的空间连续起来，方便内存管理，且应用程序申请大块的内存时，操作系统内核也可方便地分配。通过MMU可实现不连续的物理地址空间映射为连续的虚拟地址空间。操作系统内核或者一些比较关键的代码，一般是不希望被用户应用程序访问。通过MMU可以控制地址空间的访问权限，从而保护这些代码不被破坏。 </p><p><strong>MMU的实现过程，实际上就是一个查表映射的过程</strong>。建立页表是实现MMU功能不可缺少的一步。页表位于系统的内存中，页表的每一项对应于一个虚拟地址到物理地址的映射。每一项的长度即是一个字的长度(在ARM中，一个字的长度被定义为4Bytes)。页表项除完成虚拟地址到物理地址的映射功能之外，还定义了访问权限和缓冲特性等。　</p><p>MMU的映射分为两种，一级页表的变换和二级页表变换。两者的不同之处就是实现的变换地址空间大小不同。</p><p>一级页表变换支持1 M大小的存储空间的映射，而二级可以支持64 kB，4 kB和1 kB大小地址空间的映射。</p><blockquote><p>动态表(页表)的大小＝表项数＊每个表项所需的位数，即为整个内存空间建立索引表时，需要多大空间存放索引表本身。<br>表项数＝虚拟地址空间/每页大小<br>每个表项所需的位数＝Log(实际页表数)+适当控制位数<br>实际页表数 ＝物理地址空间/每页大小</p></blockquote><ul><li><h3 id="parse-options"><a href="#parse-options" class="headerlink" title="parse_options()"></a><strong>parse_options()</strong></h3></li></ul><p>分析由内核引导程序发送给内核的启动选项，在初始化过程中按照某些选项运行，并将剩余部分传送给init进程。</p><p>这些选项可能已经存储在配置文件中，也可能是由用户在系统启动时敲入的。但内核并不关心这些，这些细节都是内核引导程序关注的内容，嵌入式系统更是如此。 </p><ul><li><h3 id="trap-init-（-kernel-traps-c-do-trap）"><a href="#trap-init-（-kernel-traps-c-do-trap）" class="headerlink" title="trap_init() （/kernel/traps.c do_trap）"></a>trap_init() （/kernel/traps.c do_trap）</h3></li></ul><p>这个函数用来做体系相关的<strong>中断处理</strong>的初始化，在该函数中调用__trap_init((void *)vectors_base()) </p><p>函数将exception vector设置到vectors_base开始的地址上。 __trap_init函数位于entry-armv.S文件中，对于ARM处理器，共有复位、未定义指令、SWI、预取终止、数据终止、IRQ和FIQ 几种方式。</p><p>　　</p><p><strong>SWI主要用来实现系统调用</strong>，而产生了IRQ之后，通过exception vector进入中断处理过程，执行<strong>do_IRQ</strong>函数。</p><p>armnommu的trap_init（）函数在arch/armnommu/kernel/traps.c文件中。</p><p>vectors_base是写中断向量的开始地址，在include/asm-armnommu/proc-armv/system.h文件中设置，地址为0或0XFFFF0000。 </p><pre class="line-numbers language-none"><code class="language-none">ENTRY(__trap_init)stmfd sp!, &#123;r4 - r6, lr&#125;mrs r1, cpsr @ code from 2.0.38bic r1, r1, #MODE_MASK @ clear mode bits &#x2F;* 设置svc模式，disable IRQ,FIQ *&#x2F;orr r1, r1, #I_BIT|F_BIT|MODE_SVC @ set SVC mode, disable IRQ,FIQmsr cpsr, r1adr r1, .LCvectors @ set up the vectorsldmia r1, &#123;r1, r2, r3, r4, r5, r6, ip, lr&#125;stmia r0, &#123;r1, r2, r3, r4, r5, r6, ip, lr&#125; &#x2F;* 拷贝异常向量 *&#x2F;add r2, r0, #0x200adr r0, __stubs_start @ copy stubs to 0x200adr r1, __stubs_end1: ldr r3, [r0], #4str r3, [r2], #4cmp r0, r1blt 1bLOADREGS(fd, sp!, &#123;r4 - r6, pc&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>__stubs_start到__stubs_end的地址中包含了异常处理的代码，因此拷贝到vectors_base+0x200的位置上。 </p><ul><li><h3 id="init-IRQ"><a href="#init-IRQ" class="headerlink" title="init_IRQ()"></a>init_IRQ()</h3></li></ul><pre class="line-numbers language-none"><code class="language-none">void __init init_IRQ(void)&#123;extern void init_dma(void);int irq;for (irq &#x3D; 0; irq &lt; NR_IRQS; irq++) &#123;irq_desc[irq].probe_ok &#x3D; 0;irq_desc[irq].valid &#x3D; 0;irq_desc[irq].noautoenable &#x3D; 0;irq_desc[irq].mask_ack &#x3D; dummy_mask_unmask_irq;irq_desc[irq].mask &#x3D; dummy_mask_unmask_irq;irq_desc[irq].unmask &#x3D; dummy_mask_unmask_irq;&#125;CSR_WRITE(AIC_MDCR, 0x7FFFE); &#x2F;* disable all interrupts *&#x2F;CSR_WRITE(CAHCNF,0x0);&#x2F;*Close Cache*&#x2F;CSR_WRITE(CAHCON,0x87);&#x2F;*Flush Cache*&#x2F;while(CSR_READ(CAHCON)!&#x3D;0);CSR_WRITE(CAHCNF,0x7);&#x2F;*Open Cache*&#x2F;init_arch_irq();init_dma();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个函数用来做体系相关的irq处理的初始化.</p><p><strong>irq_desc</strong>数组是用来描述IRQ的请求队列，<strong>每一个中断号分配一个irq_desc结构，组成了一个数组。</strong></p><p>NR_IRQS代表中断数目，这里只是对中断结构irq_desc进行了初始化。</p><p>在默认的初始化完成后调用初始化函数init_arch_irq，先执行arch/armnommu/kernel/irq-arch.c文件中的函数genarch_init_irq()，然后就执行 include/asm-armnommu/arch-xxxx/irq.h中的inline函数<strong>irq_init_irq</strong>，在这里对irq_desc进行了实质的初始化。</p><p>其中mask用阻塞中断；unmask用来取消阻塞；mask_ack的作用是阻塞中断，同时还回应ack给硬件表示这个中断已经被处理了，否则硬件将再次发生同一个中断。这里，不是所有硬件需要这个ack回应，所以很多时候mask_ack与mask用的是同一个函数。</p><p>接下来执行init_dma（）函数，如果不支持DMA，可以设置include/asm-armnommu/arch-xxxx/dma.h中的 MAX_DMA_CHANNELS为0，这样在arch/armnommu/kernel/dma.c文件中会根据这个定义使用不同的函数。 </p><ul><li><h3 id="sched-init"><a href="#sched-init" class="headerlink" title="sched_init()"></a>sched_init()</h3></li></ul><p>初始化系统调度进程，主要对定时器机制和时钟中断的Bottom Half的初始化函数进行设置。</p><p>与时间相关的初始化过程主要有两步：</p><blockquote><p>（1）调用 init_timervecs()函数初始化内核定时器机制；</p><p>（2）调用init_bh()函数将BH向量TIMER_BH、TQUEUE_BH和 IMMEDIATE_BH所对应的BH函数分别设置成timer_bh()、tqueue_bh()和immediate_bh()函数 </p></blockquote><ul><li><h3 id="softirq-init"><a href="#softirq-init" class="headerlink" title="softirq_init()"></a>softirq_init()</h3></li></ul><p>内核的软中断机制初始化函数。</p><p>调用tasklet_init初始化tasklet_struct结构，软中断的个数为32个。用于bh的 tasklet_struct结构调用tasklet_init()以后，它们的函数指针func全都指向bh_action()。</p><p>bh_action就是tasklet实现bh机制的代码，但此时具体的bh函数还没有指定。</p><p>HI_SOFTIRQ用于实现bottom half，TASKLET_SOFTIRQ用于公共的tasklet。 </p><pre class="line-numbers language-none"><code class="language-none">open_softirq(TASKLET_SOFTIRQ, tasklet_action, NULL); &#x2F;* 初始化公共的tasklet_struct要用到的软中断 *&#x2F; open_softirq(HI_SOFTIRQ, tasklet_hi_action, NULL); &#x2F;* 初始化tasklet_struct实现的bottom half调用 *&#x2F; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><h3 id="time-init"><a href="#time-init" class="headerlink" title="time_init()"></a>time_init()</h3></li></ul><p>这个函数用来做体系相关的timer的初始化，armnommu的在arch/armnommu/kernel/time.c。</p><p>这里调用了在 include/asm-armnommu/arch-xxxx/time.h中的inline函数setup_timer。</p><p><strong>setup_timer（）</strong>函数的设计与硬件设计紧密相关，主要是根据硬件设计情况设置时钟中断号和时钟频率等。 </p><pre class="line-numbers language-none"><code class="language-none"> 1 void __inline__ setup_timer (void)  2 &#123;  3 &#x2F;*----- disable timer -----*&#x2F;  4 CSR_WRITE(TCR0, xxx);  5  6 CSR_WRITE (AIC_SCR7, xxx); &#x2F;* setting priority level to high *&#x2F;  7 &#x2F;* timer 0: 100 ticks&#x2F;sec *&#x2F;  8 CSR_WRITE(TICR0, xxx);  9 10 timer_irq.handler &#x3D; xxxxxx_timer_interrupt; 11 setup_arm_irq(IRQ_TIMER, &amp;timer_irq); &#x2F;* IRQ_TIMER is the interrupt number *&#x2F; 12 13 INT_ENABLE(IRQ_TIMER); 14 &#x2F;* Clear interrupt flag *&#x2F; 15 CSR_WRITE(TISR, xxx); 16 17 &#x2F;* enable timer *&#x2F; 18 CSR_WRITE(TCR0, xxx); 19 &#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><h3 id="console-init"><a href="#console-init" class="headerlink" title="console_init()"></a>console_init()</h3></li></ul><p>控制台初始化。控制台也是一种驱动程序，由于其特殊性，提前到该处完成初始化，主要是为了提前看到输出信息，据此判断内核运行情况。</p><p>很多嵌入式Linux操作系统由于没有在/dev目录下正确配置console设备，造成启动时发生诸如unable to open an initial console的错误。 </p><ul><li><h3 id="init-modules"><a href="#init-modules" class="headerlink" title="init_modules()"></a>init_modules()</h3></li></ul><p>模块初始化。如果编译内核时使能该选项，则内核支持模块化加载/卸载功能 </p><ul><li><h3 id="kmem-cache-init"><a href="#kmem-cache-init" class="headerlink" title="kmem_cache_init()"></a>kmem_cache_init()</h3></li></ul><p>内核Cache初始化</p><ul><li><h3 id="sti"><a href="#sti" class="headerlink" title="sti()"></a>sti()</h3></li></ul><p><strong>使能中断，这里开始，中断系统开始正常工作。</strong></p><ul><li><h3 id="calibrate-delay"><a href="#calibrate-delay" class="headerlink" title="calibrate_delay()"></a>calibrate_delay()</h3></li></ul><p>近似计算BogoMIPS数字的内核函数。作为第一次估算，calibrate_delay计算出在每一秒内执行多少次__delay循环，也就是每个定时器滴答（timer tick）―百分之一秒内延时循环可以执行多少次。这种计算只是一种估算，结果并不能精确到纳秒，但这个数字供内核使用已经足够精确了。 </p><p>BogoMIPS的数字由内核计算并在系统初始化的时候打印。它近似的给出了每秒钟CPU可以执行一个短延迟循环的次数。在内核中，这个结果主要用于需要等待非常短周期的设备驱动程序――例如，等待几微秒并查看设备的某些信息是否已经可用。 </p><p>计算一个定时器滴答内可以执行多少次循环需要在滴答开始时就开始计数，或者应该尽可能与它接近。全局变量jiffies中存储了从内核开始保持跟踪时间开始到现在已经经过的定时器滴答数， jiffies保持异步更新，在一个中断内——每秒一百次，内核暂时挂起正在处理的内容，更新变量，然后继续刚才的工作。 </p><ul><li><h3 id="kmem-cache-sizes-init"><a href="#kmem-cache-sizes-init" class="headerlink" title="kmem_cache_sizes_init()"></a>kmem_cache_sizes_init()</h3></li></ul><p>内核内存管理器的初始化，也就是初始化cache和SLAB分配机制。</p><ul><li><h3 id="pgtable-cache-init"><a href="#pgtable-cache-init" class="headerlink" title="pgtable_cache_init()"></a>pgtable_cache_init()</h3></li></ul><p>页表cache初始化。</p><ul><li><h3 id="fork-init"><a href="#fork-init" class="headerlink" title="fork_init()"></a>fork_init()</h3></li></ul><p>这里根据硬件的内存情况，如果计算出的max_threads数量太大，可以自行定义。</p><ul><li><h3 id="proc-caches-init"><a href="#proc-caches-init" class="headerlink" title="proc_caches_init();"></a>proc_caches_init();</h3></li></ul><p>为proc文件系统创建高速缓冲 </p><ul><li><h3 id="vfs-caches-init-num-physpages"><a href="#vfs-caches-init-num-physpages" class="headerlink" title="vfs_caches_init(num_physpages);"></a>vfs_caches_init(num_physpages);</h3></li></ul><p>为VFS创建SLAB高速缓冲</p><ul><li><h3 id="buffer-init-num-physpages"><a href="#buffer-init-num-physpages" class="headerlink" title="buffer_init(num_physpages);"></a>buffer_init(num_physpages);</h3></li></ul><p>初始化buffer </p><ul><li><h3 id="page-cache-init-num-physpages"><a href="#page-cache-init-num-physpages" class="headerlink" title="page_cache_init(num_physpages);"></a>page_cache_init(num_physpages);</h3></li></ul><p>页缓冲初始化 </p><ul><li><h3 id="signals-init"><a href="#signals-init" class="headerlink" title="signals_init();"></a>signals_init();</h3></li></ul><p>创建信号队列高速缓冲 </p><ul><li><h3 id="proc-root-init"><a href="#proc-root-init" class="headerlink" title="proc_root_init();"></a>proc_root_init();</h3></li></ul><p><strong>在内存中创建包括根结点在内的所有节点</strong> </p><ul><li><h3 id="check-bugs"><a href="#check-bugs" class="headerlink" title="check_bugs();"></a>check_bugs();</h3></li></ul><p>检查与处理器相关的bug </p><ul><li><h3 id="smp-init"><a href="#smp-init" class="headerlink" title="smp_init();"></a>smp_init();</h3></li><li><h3 id="rest-init"><a href="#rest-init" class="headerlink" title="rest_init();"></a>rest_init();</h3></li></ul><p>*<em>此函数调用*<em>kernel_thread*</em>(init, NULL, CLONE_FS | CLONE_FILES | CLONE_SIGNAL)函数。</em>*</p><h4 id="kernel-thread-函数分析"><a href="#kernel-thread-函数分析" class="headerlink" title="kernel_thread()函数分析"></a>kernel_thread()函数分析</h4><p>这里调用了arch/armnommu/kernel/process.c中的函数kernel_thread，kernel_thread函数中通过**__syscall(clone)** 创建新线程。</p><p>__syscall(clone)函数参见armnommu/kernel目录下的entry- common.S文件。</p><h4 id="init-完成下列功能："><a href="#init-完成下列功能：" class="headerlink" title="init()完成下列功能："></a>init()完成下列功能：</h4><p>**init()**函数通过kernel_thread(init, NULL, CLONE_FS | CLONE_FILES | CLONE_SIGNAL)的回调函数执行，完成下列功能。 </p><p>**do_basic_setup()**在该函数里，sock_init()函数进行网络相关的初始化，占用相当多的内存，如果所开发系统不支持网络功能，可以把该函数的执行注释掉。 </p><p><strong>do_initcalls()<strong>实现驱动的初始化, 这里需要与</strong>vmlinux.lds</strong>联系起来看才能明白其中奥妙。</p><pre class="line-numbers language-none"><code class="language-none">static void __init do_initcalls(void)&#123;　　initcall_t *call;　　call &#x3D; &amp;__initcall_start;　　do &#123;　　　(*call)();　　　call++;　　&#125; while (call &lt; &amp;__initcall_end);　　&#x2F;* Make sure there is no pending stuff from the initcall sequence *&#x2F;　　flush_scheduled_tasks();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>查看 /arch/i386/vmlinux.lds，其中有一段代码</strong></p><pre class="line-numbers language-none"><code class="language-none">__initcall_start &#x3D; .; .initcall.init : &#123; *(.initcall.init) &#125; __initcall_end &#x3D; .; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其含义是__initcall_start指向代码节.initcall.init的节首，而__initcall_end指向.initcall.init的节尾。</p><p><strong>do_initcalls</strong>所作的是系统中有关驱动部分的初始化工作，那么<strong>这些函数指针数据是怎样放到了.initcall.init节呢？</strong></p><p>在include/linux/init.h文件中有如下3个定义： </p><blockquote><ol><li>#define __init_call　　 <strong>attribute</strong> ((unused,<strong>section</strong> (“.initcall.init” )) </li></ol><p>__attribute__的含义就是构建一个在.initcall.init节的指向初始函数的指针。 </p><ol start="2"><li>#define __initcall(fn) static initcall_t _<em>initcall</em>##fn _<em>init_call = fn<br>##意思就是在可变参数使用宏定义的时候构建一个变量名称为所指向的函数的名称，并且在前面加上__initcall</em> </li><li>#define <strong>module_init</strong>(x) __initcall(x);<br><strong>很多驱动中都有类似module_init(usb_init)的代码，通过该宏定义逐层解释存放到.<a href="http://initcall.int/">initcall.int</a>节中。</strong></li></ol></blockquote><h4 id="init执行过程"><a href="#init执行过程" class="headerlink" title="init执行过程"></a>init执行过程</h4><p>在内核引导结束并启动init之后，系统就转入用户态的运行，在这之后创建的一切进程，都是在用户态进行。 </p><p>这里先要清楚一个<strong>概念</strong>：</p><p>就是init进程虽然是从内核开始的，即在前面所讲的init/main.c中的init()函数在启动后就已经是一个核心线程，但在转到执行init程序（如 /sbin/init）之后，内核中的init()就变成了/sbin/init程序，状态也转变成了用户态，也就是说<strong>核心线程变成了一个普通的进程。</strong></p><p>这样一来，内核中的init函数实际上只是用户态init进程的入口，它在执行execve(“/sbin/init”,argv_init, envp_init)时改变成为一个普通的用户进程。这也就是exec函数的乾坤大挪移法，在exec函数调用其他程序时，当前进程被其他进程“灵魂附体”。 </p><p>除此之外，它们的代码来源也有差别，内核中的init()函数的源代码在/init/main.c中，是内核的一部分。而/sbin/init程序的源代码是应用程序。</p><p>init程序启动之后，要完成以下任务：检查文件系统，启动各种后台服务进程，最后为每个终端和虚拟控制台启动一个getty进程供用户登录。由于所有其它用户进程都是由init派生的，因此它又是其它一切用户进程的父进程。 </p><p>init进程启动后，按照/etc/inittab的内容进程系统设置。很多嵌入式系统用的是BusyBox的init，它与一般所使用的init不一样，会先执行/etc/init.d/rcS二百非/etc/rc.d/rc.sysinit。</p><p>kernel_init() -&gt; kernel_init_freeable() -&gt; do_basic_setup() ，其中包括do_initcalls()按照优先级加载各项内核built-in驱动</p><p>再通过run_init_process()启动用户空间的init进程，由init来加载rootfs以及其他各项module驱动 最终进入cpu_idle循环中，至此内核启动完成</p><p><strong>拓展内容：</strong></p><p>内核的初始化过程由start_kernel函数开始，至第一个用户进程init结束，调用了一系列的初始化函数对所有的内核组件进行初始化。其中，start_kernel、rest_init、kernel_init、init_post等4个函数构成了整个初始化过程的主线。</p><ul><li><h3 id="start-kernel-函数：从start-kernel函数开始，内核即进入了C语言部分，它完成了内核的大部分初始化工作。实际上，可以将start-kernel函数看做内核的main函数。"><a href="#start-kernel-函数：从start-kernel函数开始，内核即进入了C语言部分，它完成了内核的大部分初始化工作。实际上，可以将start-kernel函数看做内核的main函数。" class="headerlink" title="start_kernel()函数：从start_kernel函数开始，内核即进入了C语言部分，它完成了内核的大部分初始化工作。实际上，可以将start_kernel函数看做内核的main函数。"></a>start_kernel()函数：从start_kernel函数开始，内核即进入了C语言部分，它完成了内核的大部分初始化工作。实际上，可以将start_kernel函数看做内核的main函数。</h3></li></ul><pre class="line-numbers language-none"><code class="language-none">*513 asmlinkage void __init start_kernel(void)* *514 &#123;* *515   char \* command_line;* *516   extern struct kernel_param __start___param[], __stop___param[];* *517* ​    *&#x2F;** ​     *** *当只有一个**CPU**的时候这个函数就什么都不做，*​     *** *但是如果有多个**CPU**的时候那么它就* ​     *** *返回在启动的时候的那个**CPU**的号* ​     **&#x2F;* *518   smp_setup_processor_id();* *519* *520   &#x2F;** *521   \* Need to run as early as possible, to initialize the* *522   \* lockdep hash:* *523   \*&#x2F;* *524   unwind_init();* *525   lockdep_init();* *526* ​    *&#x2F;** *关闭当前**CPU**的中断* **&#x2F;* *527   local_irq_disable();* *528   early_boot_irqs_off();* ​    *&#x2F;** ​     *** *每一个中断都有一个中断描述符（**struct irq_desc**）来进行描述，这个函数的* ​     *** *作用就是设置所有中断描述符的锁* ​     **&#x2F;* *529   early_init_irq_lock_class();* *530* *531 &#x2F;** *532 \* Interrupts are still disabled. Do necessary setups, then* *533 \* enable them* *534 \*&#x2F;* ​    *&#x2F;** *获取大内核锁，锁定整个内核。* **&#x2F;* *535   lock_kernel();* ​    *&#x2F;** *如果定义了**CONFIG_GENERIC_CLOCKEVENTS**，则注册**clockevents**框架* **&#x2F;* *536   tick_init();* *537   boot_cpu_init();* ​    *&#x2F;** *初始化页地址，使用链表将其链接起来* **&#x2F;* *538   page_address_init();* *539   printk(KERN_NOTICE);* ​    *&#x2F;** *显示内核的版本信息* **&#x2F;* *540   printk(linux_banner);* ​    *&#x2F;** ​     *** *每种体系结构都有自己的**setup_arch()**函数，是体系结构相关的，具体编译哪个* ​     *** *体系结构的**setup_arch()**函数**,**由源码树顶层目录下的**Makefile**中的**ARCH**变量* ​     *** *决定* ​     **&#x2F;* *541   setup_arch(&amp;command_line);* *542   setup_command_line(command_line);* *543   unwind_setup();* ​    *&#x2F;** *每个**CPU**分配**pre-cpu**结构内存，* *并复制**.data.percpu**段的数据* **&#x2F;* *544   setup_per_cpu_areas();* *545   smp_prepare_boot_cpu(); &#x2F;\* arch-specific boot-cpu hooks \*&#x2F;* *546* *547   &#x2F;** *548   \* Set up the scheduler prior starting any interrupts (such as the* *549   \* timer interrupt). Full topology setup happens at smp_init()* *550   \* time - but meanwhile we still have a functioning scheduler.* *551   \*&#x2F;* ​    *&#x2F;** *进程调度器初始化* **&#x2F;* *552   sched_init();* *553   &#x2F;** *554   \* Disable preemption - early bootup scheduling is extremely* *555   \* fragile until we cpu_idle() for the first time.* *556   \*&#x2F;* ​    *&#x2F;** *禁止内核抢占* **&#x2F;* *557   preempt_disable();* *558   build_all_zonelists();* *559   page_alloc_init();* ​    *&#x2F;** *打印**Linux**启动命令行参数* **&#x2F;* *560   printk(KERN_NOTICE &quot;Kernel command line: %s\n&quot;, boot_command_line);* ​    *&#x2F;** *对内核选项的两次解析* **&#x2F;* *561   parse_early_param();* *562   parse_args(&quot;Booting kernel&quot;, static_command_line, __start___param,* *563      __stop___param - __start___param,* *564      &amp;unknown_bootoption);* ​    *&#x2F;** *检查中断是否已经打开，如果已经打开，则关闭中断* **&#x2F;* *565   if (!irqs_disabled()) &#123;* *566     printk(KERN_WARNING &quot;start_kernel(): bug: interrupts were &quot;* *567         &quot;enabled \*very\* early, fixing it\n&quot;);* *568     local_irq_disable();* *569   &#125;* *570   sort_main_extable();* ​    *&#x2F;** ​     ** trap_init**函数完成对系统保留中断向量（异常、非屏蔽中断以及系统调用）*        ​     *** *的初始化，**init_IRQ**函数则完成其余中断向量的初始化* ​     **&#x2F;* *571   trap_init();* ​    *&#x2F;** *初始化**RCU(Read-Copy Update)**机制* **&#x2F;* *572   rcu_init();* *573   init_IRQ();* ​    *&#x2F;** *初始化**hash**表，便于从进程的**PID**获得对应的进程描述符指针* **&#x2F;* *574   pidhash_init();* ​    *&#x2F;** *初始化定时器相关的数据结构* **&#x2F;* *575   init_timers();* ​    *&#x2F;** *对高精度时钟进行初始化* **&#x2F;* *576   hrtimers_init();* ​    *&#x2F;** *初始化**tasklet_softirq**和**hi_softirq \*&#x2F;* *577   softirq_init();* *578   timekeeping_init();* ​    *&#x2F;** *初始化系统时钟源* **&#x2F;* *579   time_init();* ​    *&#x2F;** *对内核的**profile**（一个内核性能调式工具）功能进行初始化* **&#x2F;* *580   profile_init();* *581   if (!irqs_disabled())* *582     printk(&quot;start_kernel(): bug: interrupts were enabled early\n&quot;);* *583   early_boot_irqs_on();* *584   local_irq_enable();* *585* *586   &#x2F;** *587   \* HACK ALERT! This is early. We&#39;re enabling the console before* *588   \* we&#39;ve done PCI setups etc, and console_init() must be aware of* *589   \* this. But we do want output early, in case something goes wrong.* *590   \*&#x2F;* ​      *&#x2F;** ​     *** *初始化控制台以显示**printk**的内容，在此之前调用的**printk* ​     *** *只是把数据存到缓冲区里* ​     **&#x2F;* *591   console_init();* *592   if (panic_later)* *593     panic(panic_later, panic_param);* *594* ​    *&#x2F;** *如果定义了**CONFIG_LOCKDEP**宏，则打印锁依赖信息，否则什么也不做* **&#x2F;* *595   lockdep_info();* *596* *597   &#x2F;** *598   \* Need to run this when irqs are enabled, because it wants* *599   \* to self-test [hard&#x2F;soft]-irqs on&#x2F;off lock inversion bugs* *600   \* too:* *601   \*&#x2F;* *602   locking_selftest();* *603* *604 #ifdef CONFIG_**BLK**_DEV_INITRD* *605   if (initrd_start &amp;&amp; !initrd_below_start_ok &amp;&amp;* *606       initrd_start &lt; min_low_pfn &lt;&lt; PAGE_SHIFT) &#123;* *607     printk(KERN_CRIT &quot;initrd overwritten**(0x%08lx &lt; 0x%08lx) - &quot;* *608       &quot;disabling it.\n&quot;,initrd_start,**min_low_pfn &lt;&lt; PAGE_SHIFT);* *609     initrd_start &#x3D; 0;* *610   &#125;* *611 #endif* ​    *&#x2F;** *虚拟文件系统的初始化* **&#x2F;* *612   vfs_caches_init_early();* *613   cpuset_init_early();* *614   mem_init();* ​    *&#x2F;\* slab**初始化* **&#x2F;* *615   kmem_cache_init();* *616   setup_per_cpu_pageset();* *617   numa_policy_init();* *618   if (late_time_init)* *619     late_time_init();* ​    *&#x2F;** ​     *** *一个非常有趣的**CPU**性能测试函数，可以计算出**CPU**在**1s**内执行了多少次一个* ​     *** *极短的循环，计算出来的值经过处理后得到**BogoMIPS**值（**Bogo**是**Bogus**的意思），* ​     **&#x2F;* *620   calibrate_delay();* *621   pidmap_init();* ​    *&#x2F;** *接下来的函数中，大多数都是为有关的管理机制建立专用的**slab**缓存* **&#x2F;* *622   pgtable_cache_init();* ​    *&#x2F;** *初始化优先级树**index_bits_to_maxindex**数组* **&#x2F;* *623   prio_tree_init();* *624   anon_vma_init();* *625 #ifdef CONFIG_X86* *626   if (efi_enabled)* *627     efi_enter_virtual_mode();* *628 #endif* ​    *&#x2F;** *根据物理内存大小计算允许创建进程的数量* **&#x2F;* *629   fork_init(num_physpages);* ​    *&#x2F;** ​     ** proc_caches_init()**，**buffer_init()**，**unnamed_dev_init()**，* *key_init()* ​     *** ​     **&#x2F;* *630   proc_caches_init();* *631   buffer_init();* *632   unnamed_dev_init();* *633   key_init();* *634   security_init();* *635   vfs_caches_init(num_physpages);* *636   radix_tree_init();* *637   signals_init();* *638   &#x2F;\* rootfs populating might need page-writeback \*&#x2F;* *639   page_writeback_init();* *640 #ifdef CONFIG_PROC_FS* *641   proc_root_init();* *642 #endif* *643   cpuset_init();* *644   taskstats_init_early();* *645   delayacct_init();* *646* ​    *&#x2F;** ​     *** *测试该**CPU**的各种缺陷，记录检测到的缺陷，以便于内核的其他部分以后可以* ​     *** *使用它们的工作。* ​     **&#x2F;* *647   check_bugs();* *648* *649   acpi_early_init(); &#x2F;\* before LAPIC and* *SMP* *init \*&#x2F;* *650* *651   &#x2F;\* Do the rest non-__init&#39;ed, we&#39;re now alive \*&#x2F;* ​    *&#x2F;** *创建**init**进程* **&#x2F;* *652   rest_init();* *653 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><h3 id="reset-init-函数：在start-kernel函数的最后调用了reset-init函数进行后续的初始化。"><a href="#reset-init-函数：在start-kernel函数的最后调用了reset-init函数进行后续的初始化。" class="headerlink" title="reset_init()函数：在start_kernel函数的最后调用了reset_init函数进行后续的初始化。"></a><em>reset_init()函数：在start_kernel函数的最后调用了reset_init函数进行后续的初始化。</em></h3></li></ul><pre class="line-numbers language-none"><code class="language-none">*438 static void noinline __init_refok rest_init(void)* *439   __releases(kernel_lock)* *440 &#123;* *441   int pid;* *442* ​    *&#x2F;\* reset_init()**函数最主要的历史使命就是启动内核线程**kernel_init \*&#x2F;* *443   kernel_thread(kernel_init, NULL, CLONE_FS | CLONE_SIGHAND);* *444   numa_default_policy();* ​    *&#x2F;** *启动内核线程**kthreadd**，运行**kthread_create_list**全局链表中的**kthread \*&#x2F;* *445   pid &#x3D; kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);* *446   kthreadd_task &#x3D; find_task_by_pid(pid);* *447   unlock_kernel();* *448* *449   &#x2F;** *450   \* The boot idle thread must execute schedule()* *451   \* at least once to get things moving:* *452   \*&#x2F;* ​    *&#x2F;** ​     *** *增加**idle**进程的**need_resched**标志，* *并且调用**schedule**释放**CPU,* ​     *** *将其赋给更应该获取**CPU**的进程。* ​     **&#x2F;* *453   init_idle_bootup_task(current);* *454   preempt_enable_no_resched();* *455   schedule();* *456   preempt_disable();* *457* *458   &#x2F;\* Call into cpu_idle with preempt disabled \*&#x2F;* ​    *&#x2F;** ​     *** *进入**idle**循环以消耗空闲的**CPU**时间片，* *该函数从不返回。然而，当有实际工作* ​     *** *要处理时，该函数就会被抢占。* ​     **&#x2F;* *459   cpu_idle();* *460 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><h3 id="kernel-init-函数：kernel-init函数将完成设备驱动程序的初始化，并调用init-post函数启动用户空间的init进程。"><a href="#kernel-init-函数：kernel-init函数将完成设备驱动程序的初始化，并调用init-post函数启动用户空间的init进程。" class="headerlink" title="kernel_init()函数：kernel_init函数将完成设备驱动程序的初始化，并调用init_post函数启动用户空间的init进程。"></a><em>kernel_init()函数：kernel_init函数将完成设备驱动程序的初始化，并调用init_post函数启动用户空间的init进程。</em></h3></li></ul><pre class="line-numbers language-none"><code class="language-none">*813 static int __init kernel_init(void \* unused)* *814 &#123;* *815   lock_kernel();* *816   &#x2F;** *817   \* init can run on any cpu.* *818   \*&#x2F;* ​    *&#x2F;** *修改进程的**CPU**亲和力* **&#x2F;* *819   set_cpus_allowed(current, CPU_MASK_**ALL**);* *820   &#x2F;** *821   \* Tell the world that we&#39;re going to be the grim* *822   \* reaper of innocent orphaned children.* *823   ** *824   \* We don&#39;t want people to have to make incorrect* *825   \* assumptions about where in the task array this* *826   \* can be found.* *827   \*&#x2F;* ​    *&#x2F;** *把当前进程设为接受其他孤儿进程的进程* **&#x2F;* *828   init_pid_ns.child_reaper &#x3D; current;* *829* *830   __set_special_pids(1, 1);* *831   cad_pid &#x3D; task_pid(current);* *832* *833   smp_prepare_cpus(max_cpus);* *834* *835   do_pre_smp_initcalls();* *836* ​    *&#x2F;** *激活**SMP**系统中其他**CPU \*&#x2F;* *837   smp_init();* *838   sched_init_smp();* *839* *840   cpuset_init_smp();* *841* ​    *&#x2F;** ​     *** *此时与体系结构相关的部分已经初始化完成，现在开始调用**do_basic_setup**函数* ​     *** *初始化设备，完成外设及其驱动程序（直接编译进内核的模块）的加载和初始化* ​     **&#x2F;* *842   do_basic_setup();* *843* *844   &#x2F;** *845   \* check if there is an early userspace init. If yes, let it do all* *846   \* the work* *847   \*&#x2F;* *848* *849   if (!ramdisk_execute_command)* *850     ramdisk_execute_command &#x3D; &quot;&#x2F;init&quot;;* *851* *852   if (sys_access((const char __user \*)ramdisk_execute_command, 0) !&#x3D; 0) &#123;* *853     ramdisk_execute_command &#x3D; NULL;* *854     prepare_namespace();* *855   &#125;* *856* *857   &#x2F;** *858   \* Ok, we have completed the initial bootup, and* *859   \* we&#39;re essentially up and running. Get rid of the* *860   \* initmem segments and start the user-mode stuff.* *861   \*&#x2F;* *862   init_post();* *863   return 0;* *864 &#125;*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><h3 id="init-post-函数：到init-post函数为止，内核的初始化已经进入尾声，第一个用户空间进程init将姗姗来迟。"><a href="#init-post-函数：到init-post函数为止，内核的初始化已经进入尾声，第一个用户空间进程init将姗姗来迟。" class="headerlink" title="init_post()函数：到init_post函数为止，内核的初始化已经进入尾声，第一个用户空间进程init将姗姗来迟。"></a><em>init_post()函数：到init_post函数为止，内核的初始化已经进入尾声，第一个用户空间进程init将姗姗来迟。</em></h3></li></ul><pre class="line-numbers language-none"><code class="language-none">*774 static int noinline init_post(void)* *775 &#123;* *776   free_initmem();* *777   unlock_kernel();* *778   mark_rodata_ro();* *779   system_state &#x3D; SYSTEM_RUNNING;* *780   numa_default_policy();* *781* *782   if (sys_open((const char __user \*) &quot;&#x2F;dev&#x2F;console&quot;, O_**RDWR**, 0) &lt; 0)* *783     printk(KERN_WARNING &quot;Warning: unable to open an initial console.\n&quot;);* *784* *785   (void) sys_dup(0);* *786   (void) sys_dup(0);* *787* *788   if (ramdisk_execute_command) &#123;* *789     run_init_process(ramdisk_execute_command);* *790     printk(KERN_WARNING &quot;Failed to execute %s\n&quot;,* *791         ramdisk_execute_command);* *792   &#125;* *793* *794   &#x2F;** *795   \* We try each of these until one succeeds.* *796   ** *797   \* The Bourne shell can be used instead of init if we are* *798   \* trying to recover a really broken machine.* *799   \*&#x2F;* *800   if (execute_command) &#123;* *801     run_init_process(execute_command);* *802     printk(KERN_WARNING &quot;Failed to execute %s. Attempting &quot;* *803           &quot;defaults...\n&quot;, execute_command);* *804   &#125;* *805   run_init_process(&quot;&#x2F;sbin&#x2F;init&quot;);* *806   run_init_process(&quot;&#x2F;etc&#x2F;init&quot;);* *807   run_init_process(&quot;&#x2F;bin&#x2F;init&quot;);* *808   run_init_process(&quot;&#x2F;bin&#x2F;sh&quot;);* *809* *810   panic(&quot;No init found. Try passing init&#x3D; option to kernel.&quot;);* *811 &#125;*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ps："><a href="#ps：" class="headerlink" title="ps："></a><em>ps：</em></h3><blockquote><ul><li>第776行，到此，内核初始化已经接近尾声了，所有的初始化函数都已经被调用，因此free_initmem函数可以舍弃内存的__init_begin至__init_end（包括.init.setup、.initcall.init等节）之间的数据。所有使用__init标记过的函数和使用__initdata标记过的数据，在free_initmem函数执行后，都不能使用，它们曾经获得的内存现在可以重新用于其他目的。</li><li>第782行，如果可能，打开控制台设备，这样init进程就拥有一个控制台，并可以从中读取输入信息，也可以向其中写入信息。实际上init进程除了打印错误信息以外，并不使用控制台，但是如果调用的是shell或者其他需要交互的进程，而不是init，那么就需要一个可以交互的输入源。如果成功执行open，/dev/console即成为init的标准输入源（文件描述符0）。</li><li>第785～786行，调用dup打开/dev/console文件描述符两次。这样，该控制台设备就也可以供标准输出和标准错误使用（文件描述符1和2）。假设第782行的open成功执行（正常情况），init进程现在就拥有3个文件描述符–标准输入、标准输出以及标准错误。</li><li>第788～804行，如果内核命令行中给出了到init进程的直接路径（或者别的可替代的程序），这里就试图执行init。因为当kernel_execve函数成功执行目标程序时并不返回，只有失败时，才能执行相关的表达式。接下来的几行会在几个地方查找init，按照可能性由高到低的顺序依次是： /sbin/init，这是init标准的位置；/etc/init和/bin/init，两个可能的位置。</li><li>第805～807行，这些是init可能出现的所有地方。如果在这3个地方都没有发现init，也就无法找到它的同名者了，系统可能就此崩溃。因此，第808行会试图建立一个交互的shell（/bin/sh）来代替，希望root用户可以修复这种错误并重新启动机器。</li><li>第810行，由于某些原因，init甚至不能创建shell。当前面的所有情况都失败时，调用panic。这样内核就会试图同步磁盘，确保其状态一致。如果超过了内核选项中定义的时间，它也可能会重新启动机器。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JNI层学习</title>
      <link href="2021/05/21/0-ri-chang-xue-xi/jni-ceng-xue-xi/"/>
      <url>2021/05/21/0-ri-chang-xue-xi/jni-ceng-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="理解JNI需要理解以下问题："><a href="#理解JNI需要理解以下问题：" class="headerlink" title="理解JNI需要理解以下问题："></a><strong>理解JNI需要理解以下问题：</strong></h1><ul><li><p>JNI的认识</p></li><li><p>JNI库的加载、相关native函数分析和总结</p></li><li><p>JNI函数注册</p></li><li><p>JNIEnv的认识</p></li></ul><h2 id="一、JNI的认识"><a href="#一、JNI的认识" class="headerlink" title="一、JNI的认识"></a><strong>一、JNI的认识</strong></h2><p><img src="/2021/05/21/0-ri-chang-xue-xi/jni-ceng-xue-xi/11.png"></p><p>JNI是Java Native Interface的缩写，它提供了若干的API实现了Java和其他语言的通信（主要是C&amp;C++）。在安卓中，主要做到以下两点：</p><blockquote><p>1）Java程序中函数可以调用Native语言写的函数，Native一般指C/C++编写的函数</p><p>2）Native函数也可以反过来调用Java层函数</p></blockquote><p>Java平台中，为什么需要创建一个与Native相关的JNI技术呢？是不是破坏了Java的平台无关特性，其实主要考虑到如下方面：</p><blockquote><p>1）Java世界的虚拟机使用Native语言写的，虚拟机又运行在具体的平台上，所有虚拟机是无法做到平台无关的。但是，JNI技术可以针对Java层屏蔽不同操作系统之间的差异，这样就能够实现平台无关特性。</p><p>2）C/C++语音已经有了很多成熟的模块，Java只需要直接调用即可。还有一些追求效率和速度的场合，需要Native语言参与的。</p></blockquote><p>在Android平台上，JNI就是一座将Native世界和Java世界的天堑变通途的桥。</p><h3 id="本文从源码中的MediaScanner中来初步窥视JNI用法"><a href="#本文从源码中的MediaScanner中来初步窥视JNI用法" class="headerlink" title="本文从源码中的MediaScanner中来初步窥视JNI用法"></a><strong>本文从源码中的</strong>MediaScanner<strong>中来初步窥视</strong>JNI<strong>用法</strong></h3><p><img src="/2021/05/21/0-ri-chang-xue-xi/jni-ceng-xue-xi/15-1621568639139.png"></p><p>上图可以看到Java层 、JNI层、Native层之间的架构，JNI是中间层【这里区分了<a href="http://libmedia_jni.so/">libmedia_jni.so</a>、<a href="http://libmedia.so/">libmedia.so</a>:平常开发直接用一个.so 文件。这里区分为了说明JNI层和Native层】</p><blockquote><ul><li>Java世界对于的是MediaScanner,他内部的一些函数是需要由Native层来实现的。</li><li>JNI层对于的是so 。Android平台基本上都是采用“lib模块名_jni.so”的命名方式。</li><li>Native层对应的是so 这个库完成了实际的功能。</li><li>MediaScanner将通过JNI层的so和Native层的<a href="http://libmedia.so/">libmedia.so</a>交互</li></ul></blockquote><p>源码位置：android\frameworks\base\media\java\android\media\MediaScanner.java</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MediaScanner</span><span class="token punctuation">&#123;</span><span class="token operator">*</span><span class="token comment">//1**、静态代码块*</span><span class="token keyword">static</span> <span class="token punctuation">&#123;</span>​    <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">loadLibrary</span><span class="token punctuation">(</span><span class="token string">"media_jni"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token operator">*</span><span class="token comment">//**导入库*</span>​    <span class="token function">native_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">*</span><span class="token comment">//**初始化操作**,**是一个**native**方法*</span> <span class="token punctuation">&#125;</span><span class="token operator">*</span><span class="token comment">//2**、普通方法【非**native**方法】*</span><span class="token annotation punctuation">@Override</span>​    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">scanFile</span><span class="token punctuation">(</span><span class="token class-name">String</span> path<span class="token punctuation">,</span> <span class="token keyword">long</span> lastModified<span class="token punctuation">,</span> <span class="token keyword">long</span> fileSize<span class="token punctuation">,</span>​        <span class="token keyword">boolean</span> isDirectory<span class="token punctuation">,</span> <span class="token keyword">boolean</span> noMedia<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>​    <span class="token operator">*</span><span class="token comment">// This is the callback funtion from native codes.*</span>​        <span class="token operator">*</span><span class="token comment">// Log.v(TAG, "scanFile: "+path);*</span>​       <span class="token function">doScanFile</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> lastModified<span class="token punctuation">,</span> fileSize<span class="token punctuation">,</span> isDirectory<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> noMedia<span class="token punctuation">)</span><span class="token punctuation">;</span>​    <span class="token punctuation">&#125;</span><span class="token operator">*</span><span class="token comment">//3**、**native* *方法【它的具体实现实在**JNI**层完成的】*</span><span class="token keyword">private</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">processDirectory</span><span class="token punctuation">(</span><span class="token class-name">String</span> path<span class="token punctuation">,</span> <span class="token class-name">MediaScannerClient</span> client<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">processFile</span><span class="token punctuation">(</span><span class="token class-name">String</span> path<span class="token punctuation">,</span> <span class="token class-name">String</span> mimeType<span class="token punctuation">,</span> <span class="token class-name">MediaScannerClient</span> client<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">setLocale</span><span class="token punctuation">(</span><span class="token class-name">String</span> locale<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">extractAlbumArt</span><span class="token punctuation">(</span><span class="token class-name">FileDescriptor</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">native_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">private</span> <span class="token keyword">native</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">native_setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">private</span> <span class="token keyword">native</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">native_finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面可以看到三点：1）加载JNI库 2）初始化Native层 3）声明native方法，具体实现在JNI层实现，应用层只需要声明native方法，程序中直接使用</p><h2 id="二、JNI库的加载"><a href="#二、JNI库的加载" class="headerlink" title="二、JNI库的加载"></a><strong>二、JNI</strong>库的加载</h2><p>加载jni库其实很简单，如上面MediaScanner源码中，静态代码块中直接调用System.loadLibrary方法就可以了。其参数就是动态库的名字，即media_jni.系统会根据不同的平台拓展成动态库文件，Linux系统会拓展成<a href="http://libmedia_jni.so/">libmedia_jni.so</a>,而在Windows平台会拓展成media_jni.dll</p><p>通过MediaScanner.java 的native函数刨根问底，追一下native_init() 和 processFile(String path, String mimeType, MediaScannerClient client)</p><p>源码位置：android\frameworks\base\media\jni\android_media_MediaScanner.cpp</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">*</span><span class="token comment">// This function gets a field ID, which in turn causes class initialization.*</span><span class="token operator">*</span><span class="token comment">// It is called from a static block in MediaScanner, which won't run until the*</span><span class="token operator">*</span><span class="token comment">// first time an instance of this class is used.*</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">android_media_MediaScanner_native_init</span><span class="token punctuation">(</span>JNIEnv <span class="token operator">*</span>env<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  jclass clazz <span class="token operator">=</span> env<span class="token operator">-></span><span class="token function">FindClass</span><span class="token punctuation">(</span>kClassMediaScanner<span class="token punctuation">)</span><span class="token punctuation">;</span>  fields<span class="token punctuation">.</span>context <span class="token operator">=</span> env<span class="token operator">-></span><span class="token function">GetFieldID</span><span class="token punctuation">(</span>clazz<span class="token punctuation">,</span> <span class="token string">"mNativeContext"</span><span class="token punctuation">,</span> <span class="token string">"I"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>fields<span class="token punctuation">.</span>context <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>​    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token operator">*</span><span class="token comment">//native* *方法**processFile**的实现*</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">android_media_MediaScanner_processFile</span><span class="token punctuation">(</span>​    JNIEnv <span class="token operator">*</span>env<span class="token punctuation">,</span> jobject thiz<span class="token punctuation">,</span> jstring path<span class="token punctuation">,</span>​    jstring mimeType<span class="token punctuation">,</span> jobject client<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  MediaScanner <span class="token operator">*</span>mp <span class="token operator">=</span> <span class="token function">getNativeScanner_l</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> thiz<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathStr <span class="token operator">=</span> env<span class="token operator">-></span><span class="token function">GetStringUTFChars</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>pathStr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token operator">*</span><span class="token comment">// Out of memory*</span>​    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>mimeTypeStr <span class="token operator">=</span>​    <span class="token punctuation">(</span>mimeType <span class="token operator">?</span> env<span class="token operator">-></span><span class="token function">GetStringUTFChars</span><span class="token punctuation">(</span>mimeType<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  MyMediaScannerClient <span class="token function">myClient</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> client<span class="token punctuation">)</span><span class="token punctuation">;</span>  MediaScanResult result <span class="token operator">=</span> mp<span class="token operator">-></span><span class="token function">processFile</span><span class="token punctuation">(</span>pathStr<span class="token punctuation">,</span> mimeTypeStr<span class="token punctuation">,</span> myClient<span class="token punctuation">)</span><span class="token punctuation">;</span>  env<span class="token operator">-></span><span class="token function">ReleaseStringUTFChars</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> pathStr<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>mimeType<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>​    env<span class="token operator">-></span><span class="token function">ReleaseStringUTFChars</span><span class="token punctuation">(</span>mimeType<span class="token punctuation">,</span> mimeTypeStr<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="JNI函数注册"><a href="#JNI函数注册" class="headerlink" title="JNI函数注册"></a><strong>JNI</strong>函数注册</h2><p>所谓JNI函数注册就是将JNI层的native层的native函数和JNI层对于的实现函数关联起来，有了这种关联，在调用Java层测native函数时候，就能够顺利到JNI层对应的函数执行了。JNI函数注册有两种，我们主要分析第二种。</p><h3 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a><strong>静态注册</strong></h3><p>静态注册就是直接在Java文件里写个native方法 然后再c/c++文件中实现这个方法就行了！流程如下：</p><blockquote><p>1）编写 java 代码；</p><p>2）利用 javah 指令生成对应的 .h 文件；</p><p>3）对 .h 中的声明进行实现;</p></blockquote><p>比如如下实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">JNIEXPORT jstring JNICALL<span class="token class-name">Java_com_example_efan_jni_1learn2_MainActivity_stringFromJNI</span><span class="token punctuation">(</span>​    <span class="token class-name">JNIEnv</span> <span class="token operator">*</span>env<span class="token punctuation">,</span>​    jobject <span class="token operator">*</span><span class="token operator">/</span>\<span class="token operator">*</span> <span class="token keyword">this</span> \<span class="token operator">*</span><span class="token comment">/*) &#123;  std::string hello = "Hello from C++";  return env->NewStringUTF(hello.c_str());&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么有哪些弊端呢：</p><blockquote><p>1）编写不方便，JNI 方法名字必须遵循规则且名字很长；<br>2）编写过程步骤多，不方便；<br>3）程序运行效率低，因为初次调用native函数时需要根据根据函数名在JNI层中搜索对应的本地函数，然后建立对应关系，这个过程比较耗时</p></blockquote><h3 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a><strong>动态注册</strong></h3><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a><strong>原理：</strong></h4><p>利用 RegisterNatives 方法来注册 java 方法与 JNI 函数的一一对应关系</p><h4 id="实现流程："><a href="#实现流程：" class="headerlink" title="实现流程："></a><strong>实现流程：</strong></h4><blockquote><p>1） 利用结构体 JNINativeMethod 数组记录 java 方法与 JNI 函数的对应关系；<br>2）实现 JNI_OnLoad 方法，在加载动态库后，执行动态注册；<br>3）调用 FindClass 方法，获取 java 对象；<br>4）调用 RegisterNatives 方法，传入 java 对象，以及 JNINativeMethod 数组，以及注册数目完成注册；</p></blockquote><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a><strong>优点：</strong></h4><blockquote><p>1）流程更加清晰可控；<br>2）效率更高；</p></blockquote><p>静态改动态注册，只需要改JNI层代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">jstring <span class="token function">stringFromJNI</span><span class="token punctuation">(</span><span class="token class-name">JNIEnv</span> <span class="token operator">*</span>env<span class="token punctuation">,</span> jobject thiz<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  std<span class="token operator">::</span><span class="token function">string</span> hello <span class="token operator">=</span> <span class="token string">"Hello from C++"</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> env<span class="token operator">-></span><span class="token class-name">NewStringUTF</span><span class="token punctuation">(</span>hello<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token class-name">JNINativeMethod</span> gMethods<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>​    <span class="token punctuation">&#123;</span><span class="token string">"stringFromJNI"</span><span class="token punctuation">,</span> <span class="token string">"()Ljava/lang/String;"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>jstring<span class="token operator">*</span><span class="token punctuation">)</span>stringFromJNI<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>JNIEXPORT jint <span class="token class-name">JNI_OnLoad</span><span class="token punctuation">(</span><span class="token class-name">JavaVM</span><span class="token operator">*</span> vm<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> reserved<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">__android_log_print</span><span class="token punctuation">(</span>ANDROID_LOG_INFO<span class="token punctuation">,</span> <span class="token string">"native"</span><span class="token punctuation">,</span> <span class="token string">"Jni_OnLoad"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token class-name">JNIEnv</span><span class="token operator">*</span> env <span class="token operator">=</span> NULL<span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>vm<span class="token operator">-></span><span class="token class-name">GetEnv</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>env<span class="token punctuation">,</span> JNI_VERSION_1_4<span class="token punctuation">)</span> <span class="token operator">!=</span> JNI_OK<span class="token punctuation">)</span> <span class="token operator">*</span><span class="token comment">//**从**JavaVM**获取**JNIEnv**，一般使用**1.4**的版本*</span>​    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  jclass clazz <span class="token operator">=</span> env<span class="token operator">-></span><span class="token class-name">FindClass</span><span class="token punctuation">(</span><span class="token string">"com/example/efan/jni_learn2/MainActivity"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>clazz<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>​    <span class="token function">__android_log_print</span><span class="token punctuation">(</span>ANDROID_LOG_INFO<span class="token punctuation">,</span> <span class="token string">"native"</span><span class="token punctuation">,</span> <span class="token string">"cannot get class: com/example/efan/jni_learn2/MainActivity"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>​    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>env<span class="token operator">-></span><span class="token class-name">RegisterNatives</span><span class="token punctuation">(</span>clazz<span class="token punctuation">,</span> gMethods<span class="token punctuation">,</span> <span class="token function">sizeof</span><span class="token punctuation">(</span>gMethods<span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">sizeof</span><span class="token punctuation">(</span>gMethods<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>​    <span class="token function">__android_log_print</span><span class="token punctuation">(</span>ANDROID_LOG_INFO<span class="token punctuation">,</span> <span class="token string">"native"</span><span class="token punctuation">,</span> <span class="token string">"register native method failed!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>​    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> JNI_VERSION_1_4<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上是一个简易的动态注册流程。</p><p>Java native函数和JNI函数式一一对应的，其实在在动态注册中直接用一个数据结构来保存这种关联关系的，用一个JNINativeMethod 的结构。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">typedef struct <span class="token punctuation">&#123;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">;</span>     <span class="token operator">*</span><span class="token comment">//name**是**Java**中函数的名字*</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> signature<span class="token punctuation">;</span>  <span class="token operator">*</span><span class="token comment">//signature**，用字符串是描述了函数的参数和返回值*</span><span class="token keyword">void</span><span class="token operator">*</span> fnPtr<span class="token punctuation">;</span>       <span class="token operator">*</span><span class="token comment">//fnPtr**是函数指针，指向**C**函数。*</span><span class="token punctuation">&#125;</span> <span class="token class-name">JNINativeMethod</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再分析下MediaScanner<br>源码位置：master\android\frameworks\base\media\jni\android_media_MediaScanner.cpp</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> JNINativeMethod gMethods<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">&#123;</span>​    <span class="token string">"processDirectory"</span><span class="token punctuation">,</span>​    <span class="token string">"(Ljava/lang/String;Landroid/media/MediaScannerClient;)V"</span><span class="token punctuation">,</span>​    <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>android_media_MediaScanner_processDirectory  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#123;</span>​    <span class="token string">"processFile"</span><span class="token punctuation">,</span>​    <span class="token string">"(Ljava/lang/String;Ljava/lang/String;Landroid/media/MediaScannerClient;)V"</span><span class="token punctuation">,</span>​    <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>android_media_MediaScanner_processFile  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#123;</span>​    <span class="token string">"setLocale"</span><span class="token punctuation">,</span>​    <span class="token string">"(Ljava/lang/String;)V"</span><span class="token punctuation">,</span>​    <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>android_media_MediaScanner_setLocale  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#123;</span>​    <span class="token string">"extractAlbumArt"</span><span class="token punctuation">,</span>​    <span class="token string">"(Ljava/io/FileDescriptor;)[B"</span><span class="token punctuation">,</span>​    <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>android_media_MediaScanner_extractAlbumArt  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#123;</span>​    <span class="token string">"native_init"</span><span class="token punctuation">,</span>​    <span class="token string">"()V"</span><span class="token punctuation">,</span>​    <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>android_media_MediaScanner_native_init  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#123;</span>​    <span class="token string">"native_setup"</span><span class="token punctuation">,</span>​    <span class="token string">"()V"</span><span class="token punctuation">,</span>​    <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>android_media_MediaScanner_native_setup  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#123;</span>​    <span class="token string">"native_finalize"</span><span class="token punctuation">,</span>​    <span class="token string">"()V"</span><span class="token punctuation">,</span>​    <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>android_media_MediaScanner_native_finalize  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中：processDirectory 、 processFile 、 setLocale 、 extractAlbumArt 、 native_init 、native_setup 、 native_finalize 方法为Java中native的方法名。</p><p>AndroidRunTime 类提供了一个registerNativeMethods函数完成注册工作的，如下源码：<br>\master\android\frameworks\base\core\jni\AndroidRuntime.cpp</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">*</span><span class="token comment">/** ** Register native methods using JNI.* **/</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">/</span>\<span class="token operator">*</span><span class="token keyword">static</span>\<span class="token operator">*</span><span class="token comment">/* int AndroidRuntime::registerNativeMethods(JNIEnv* env,  const char* className, const JNINativeMethod* gMethods, int numMethods)&#123;  return jniRegisterNativeMethods(env, className, gMethods, numMethods); */</span><span class="token comment">/**就是这个方法*&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中的jniRegisterNativeMethods是Android平台中为了方便JNI使用而提供的一个帮助函数。</p><p>\master\android\libnativehelper\JNIHelp.cpp</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">extern</span> <span class="token string">"C"</span> <span class="token keyword">int</span> <span class="token function">jniRegisterNativeMethods</span><span class="token punctuation">(</span>C_JNIEnv<span class="token operator">*</span> env<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> className<span class="token punctuation">,</span>  <span class="token keyword">const</span> JNINativeMethod<span class="token operator">*</span> gMethods<span class="token punctuation">,</span> <span class="token keyword">int</span> numMethods<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  JNIEnv<span class="token operator">*</span> e <span class="token operator">=</span> reinterpret_cast<span class="token operator">&lt;</span>JNIEnv<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token punctuation">;</span>  scoped_local_ref<span class="token operator">&lt;</span>jclass<span class="token operator">></span> <span class="token function">c</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> <span class="token function">findClass</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> className<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  \<span class="token operator">--</span><span class="token operator">-</span>  <span class="token operator">*</span><span class="token comment">//**下面的**RegisterNatives* *才是重点方法：真正实现注册的地方*</span>  <span class="token operator">*</span><span class="token comment">//**调用**JNIEnv* *的**RegiisterNatives* *函数，注册关联关系*</span>  <span class="token operator">*</span><span class="token comment">//e* *是**env**指针*  *c.get()**得到**jclass gMethods**是**native**的函数数组* </span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>env<span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">RegisterNatives</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> gMethods<span class="token punctuation">,</span> numMethods<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   \<span class="token operator">--</span><span class="token operator">-</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面就完成了动态注册的流程， 还有一个问题需要考虑：这些动态注册的函数，什么时候和什么地方调用呢？</p><p><strong>当</strong>Java<strong>层通过</strong>System.loadLibrary<strong>加载</strong>JNI<strong>动态库后，紧接着会查找该库中的一个叫</strong>JNI_OnLoad的函数，如果有就调用它，而动态注册的工作就是在这里完成的。</p><p>所以，如果想使用动态注册的方法，必须实现JNI_OnLoad函数，只有在这个函数中才有机会去完成动态注册的工作，有一些初始化工作可以在这里做的。<br>对于<a href="http://libmediia_jni.so/">libmediia_jni.so</a>的JNI_OnLoad函数实在哪里实现？多媒体系统很多地方都用了JNI，所以源码里面放在了android_media_MediaPlayer.cpp中。<br>\master\android\frameworks\base\media\jni\android_media_MediaPlayer.cpp</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">jint <span class="token function">JNI_OnLoad</span><span class="token punctuation">(</span>JavaVM<span class="token operator">*</span> vm<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> reserved<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token operator">*</span><span class="token comment">//**第一个参数类型是**JavaVM,**这可是虚拟机在**JNI**层的代表，每个进程中只有一个这样的**JavaVM*</span>  JNIEnv<span class="token operator">*</span> env <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  jint result <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token function">assert</span><span class="token punctuation">(</span>env <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">*</span><span class="token comment">//**动态注册**MediaScanner* *的**JNII**函数*</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">register_android_media_MediaScanner</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>​    <span class="token function">ALOGE</span><span class="token punctuation">(</span><span class="token string">"ERROR: MediaScanner native registration failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>​    <span class="token keyword">goto</span> bail<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token operator">*</span><span class="token operator">/</span>\<span class="token operator">*</span> success <span class="token operator">--</span> <span class="token keyword">return</span> valid version number \<span class="token operator">*</span><span class="token comment">/*  result = JNI_VERSION_1_4;bail:  return result;&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结流程如下图所示：</p><p><img src="/2021/05/21/0-ri-chang-xue-xi/jni-ceng-xue-xi/12.png"></p><p><strong>当</strong>Java<strong>层通过调用</strong>System.loadLibrary<strong>加载完</strong>JNI<strong>动态库后，紧接着会查找该库中一个叫</strong>JNI_OnLoad的函数。如果有，就调用他，而动态注册的工作就是在这里完成的。<br>所以，如果想使用动态注册方法，必须实现JNI_OnLoad函数，只有这个函数才有机会完成动态注册的工作，静态注册则没有这个要求。</p><h2 id="四、JNIEnv的认识"><a href="#四、JNIEnv的认识" class="headerlink" title="四、JNIEnv的认识"></a><strong>四、JNIEnv</strong>的认识</h2><p>你会发现在JNI世界里，你是离不开JNIEnv，它就是<strong>一个与线程相关的代表</strong>JNI<strong>环境的结构体</strong>。</p><p><img src="/2021/05/21/0-ri-chang-xue-xi/jni-ceng-xue-xi/13.png"></p><p><img src="/2021/05/21/0-ri-chang-xue-xi/jni-ceng-xue-xi/14.png"></p><p>上图可以看到：JNIEnv提供了一些JNI系统函数，通过这些函数可以</p><blockquote><p>1）调用Java函数【jni层调用java层】</p></blockquote><blockquote><p>2）操作jobject对象等很多事情【jni层调用native】</p><p>前面提到过JNI_OnLoad函数，第一个参数是JavaVM,它是虚拟机在JNI层的代表。</p><p>JNI_OnLoad(JavaVM* vm, void* reserved)</p><p>不论检查中多少个线程，JavaVM独此一份，在任意地方都可以使用它。</p></blockquote><blockquote><p>3）JNI签名介绍</p><p>Java函数支持函数重载，也就是说，可以定义同名但是不同参数的函数，但仅仅根据函数名是没法找到具体函数的。为了解决这个问题，JNI技术就将参数类型和返回值类型的组合作为一个函数的签名信息，有了这个签名和函数名，就能很顺利的找到Java中的函数。</p></blockquote><blockquote><p>4）垃圾回收</p><p>JNI的三种类型引用技术：</p><blockquote><p>4.1 local reference：本地引用，一旦JNI函数返回时，jobject就可能会被回收<br>4.2 Global reference：全局引用，不主动释放不会被回收<br>4.3 Weak Global reference：特殊的全局引用，可能会被回收，每次使用时需要判断是否回收</p></blockquote></blockquote><blockquote><p>5）JNI中的异常处理</p><p>JNIEnv提供了三个函数给予帮助</p><blockquote><p>5.1 ExceptionOccured函数，用来判断是否发生异常<br>5.2 ExceptionClear函数，用来清理JNI层发生的异常。<br>5.3 ThrownNew函数，用来Java层抛出异常。</p></blockquote></blockquote><h3 id="JavaVM和JNIEnv关系："><a href="#JavaVM和JNIEnv关系：" class="headerlink" title="JavaVM和JNIEnv关系："></a><strong>JavaVM</strong>和<strong>JNIEnv</strong>关系：</h3><blockquote><p>1）JavaVM的AttachCurrentThread函数可以得到这个线程的JNIEnv结构体，这样后台就可以毁掉Java函数</p><p>2）后台线程推出前，需要调用JvavVM的DetachCurrentThread函数来释放对应的资源</p></blockquote><p>总结：看看JNI底层实现，分析源码，初步了解JNI。具体实践还需要了解JNI层是怎么操作Java层函数和调用JNI层函数的。</p><h2 id="PS："><a href="#PS：" class="headerlink" title="PS："></a>PS：</h2><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>在Java中调用native函数传递的参数是Java数据类型，如何将他们转化成Native的数据类型</p><p>基本数据类型：</p><table><thead><tr><th align="left">Java</th><th align="left">Native类型</th><th align="left">符号属性</th><th align="left">字长</th></tr></thead><tbody><tr><td align="left">Java</td><td align="left">Native类型</td><td align="left">符号属性</td><td align="left">字长</td></tr><tr><td align="left">boolean</td><td align="left">jboolean</td><td align="left">无符号</td><td align="left">8位</td></tr><tr><td align="left">byte</td><td align="left">jbyte</td><td align="left">无符号</td><td align="left">8位</td></tr><tr><td align="left">char</td><td align="left">jchar</td><td align="left">无符号</td><td align="left">16位</td></tr><tr><td align="left">short</td><td align="left">jshort</td><td align="left">有符号</td><td align="left">16位</td></tr><tr><td align="left">int</td><td align="left">jint</td><td align="left">有符号</td><td align="left">32位</td></tr><tr><td align="left">long</td><td align="left">jlong</td><td align="left">有符号</td><td align="left">64位</td></tr><tr><td align="left">float</td><td align="left">jfloat</td><td align="left">有符号</td><td align="left">32位</td></tr><tr><td align="left">double</td><td align="left">jdouble</td><td align="left">有符号</td><td align="left">64位</td></tr></tbody></table><p>引用类型转换：</p><table><thead><tr><th align="left">Java引用类型</th><th align="left">Native类型</th><th align="left">Java引用类型</th><th align="left">Native类型</th></tr></thead><tbody><tr><td align="left">All object</td><td align="left">jobject</td><td align="left">char[]</td><td align="left">jcharArray</td></tr><tr><td align="left">java.lang.Class实例</td><td align="left">jclass</td><td align="left">short[]</td><td align="left">jshortArray</td></tr><tr><td align="left">java.lang.String实例</td><td align="left">jstring</td><td align="left">int[]</td><td align="left">jintArray</td></tr><tr><td align="left">Object[]</td><td align="left">jobjectArray</td><td align="left">long[]</td><td align="left">jlongArray</td></tr><tr><td align="left">boolean[]</td><td align="left">jbooleanArray</td><td align="left">float[]</td><td align="left">jfloatArray</td></tr><tr><td align="left">byte[]</td><td align="left">jbyteArray</td><td align="left">double[]</td><td align="left">jdoubleArray</td></tr><tr><td align="left">java.lang.Throwable实例</td><td align="left">jthrowable</td><td align="left"></td><td align="left"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HAL层学习</title>
      <link href="2021/05/21/0-ri-chang-xue-xi/hal-ceng-xue-xi/"/>
      <url>2021/05/21/0-ri-chang-xue-xi/hal-ceng-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="Android-HAL-简介"><a href="#Android-HAL-简介" class="headerlink" title="Android HAL 简介"></a>Android HAL 简介</h1><p>Android 系统硬件抽象层（Hardware Abstract Layer）运行在用户空间中，它向下屏蔽了硬件驱动的实现细节，向上提供了硬件访问的服务。通过 HAL 层，Android 系统分为两层来支持硬件设备，其中一层实现在用户空间，另外一层实现在内核空间中，它在 Android 系统框架中的位置如下图所示。传统的 Linux 系统则把对硬件的支持和管理全部放在内核空间中,即把对硬件的全部支持都放在硬件驱动模块当中。</p><p><img src="/2021/05/21/0-ri-chang-xue-xi/hal-ceng-xue-xi/1.png"></p><h1 id="为什么要添加一个-HAL-层？"><a href="#为什么要添加一个-HAL-层？" class="headerlink" title="为什么要添加一个 HAL 层？"></a>为什么要添加一个 HAL 层？</h1><p>Android 在用户空间中新建一个的 HAL 层来支持硬件设备的主要原因还是因为 Android 使用的开源协议是 Apache License，这个协议比较宽松，它允许开发者获取并修改了源码之后，不用把源码公开出来。而 Linux 使用的开源协议 GPL，它的要求限制就比较多，它要求开发者添加或修改了源码之后，必须把添加或修改后的代码公开出来，所以我们在 Linux 内核中的所使用的设备驱动程序都是源码公开的，任何人都可以获取并修改它。</p><p>因此，如果 Android 系统像其他 Linux 系统一样，把对硬件的支持完全实现在 Linux 内核的驱动模块中，那么硬件厂商就必须将这些硬件驱动源码公开，这样就可能损害到移动厂商的利益，因为这相当于暴露了硬件的实现细节和参数。</p><p>所以，Android 就在用户空间搞了一个 HAL 层，将硬件的一些重要的操作都放在这一层中完成，这些操作都封装在厂商所提供的一个动态链接库中，从而达到了避免源码公开的目的，而底层 Linux 内核空间中的设备驱动模块，现在则只提供一些最基本的硬件设备寄存器操作的功能。</p><p>也正是由于这个分层的原因，Android被踢出了Linux内核主线代码树中。大家想想，Android放在内核空间的驱动程序对硬件的支持是不完整的，把Linux内核移植到别的机器上去时，由于缺乏硬件抽象层的支持，硬件就完全不能用了，这也是为什么说Android是开放系统而不是开源系统的原因。</p><h1 id="HAL-模块是如何实现的？"><a href="#HAL-模块是如何实现的？" class="headerlink" title="HAL 模块是如何实现的？"></a>HAL 模块是如何实现的？</h1><p>以音频系统对应的 audio HAL 模块（ 它最终是以 <code>audio.primary.x86.so</code> 的动态链接库形式存在 ）为例来介绍一个 HAL 模块的定义及实现过程。</p><h2 id="HAL-层的三个重要结构体"><a href="#HAL-层的三个重要结构体" class="headerlink" title="HAL 层的三个重要结构体"></a>HAL 层的三个重要结构体</h2><p>Android 系统的 HAL 层其实并不复杂，只要你能理解清楚下面这 3 个结构体的含义：</p><blockquote><ul><li><strong>hw_module_t</strong>：用来描述硬件模块</li><li><strong>hw_device_t</strong>：用来描述硬件设备</li><li><strong>hw_module_methods_t</strong>：用来打开硬件模块中包含硬件设备，获得指向硬件设备结构体的指针</li></ul></blockquote><p>Android 系统中 HAL 层是以<strong>模块</strong>的方式来管理各个硬件访问的接口，每一个硬件模块都对应一个动态链接库文件，而这些动态链接库文件需要符号一定的规范，而上述的这 3 种结构体就是用来建立这种规范。并且一个<strong>硬件模块</strong>可以管理多个<strong>硬件设备</strong>，例如 audio HAL 硬件模块中就管理了扬声器、麦克风等多个硬件设备。</p><p><strong>注意：这里一定区分 hw_module_t 和 hw_device_t 它们所表示的含义</strong></p><h3 id="hw-module-t"><a href="#hw-module-t" class="headerlink" title="hw_module_t"></a>hw_module_t</h3><p>结构体 hw_module_t 定义在 <code>/hardware/libhardware/include/hardware/hardware.h</code> 文件中，其定义如下所示：</p><pre class="line-numbers language-none"><code class="language-none">1. *&#x2F;***2. ** Every hardware module must have a data structure named HAL_MODULE_INFO_SYM*3. ** and the fields of this data structure must begin with hw_module_t*4. ** followed by module specific information.*5. **&#x2F;*6. typedef struct hw_module_t &#123;7. *&#x2F;** tag must be initialized to HARDWARE_MODULE_TAG \*&#x2F;*8. uint32_t tag;9. 10. *&#x2F;***11. ** The API version of the implemented module. The module owner is*12. ** responsible for updating the version when a module interface has*13. ** changed.*14. ***15. ** The derived modules such as gralloc and audio own and manage this field.*16. ** The module user must interpret the version field to decide whether or*17. ** not to inter-operate with the supplied module implementation.*18. ** For example, SurfaceFlinger is responsible for making sure that*19. ** it knows how to manage different versions of the gralloc-module API,*20. ** and AudioFlinger must know how to do the same for audio-module API.*21. ***22. ** The module API version should include a major and a minor component.*23. ** For example, version 1.0 could be represented as 0x0100. This format*24. ** implies that versions 0x0100-0x01ff are all API-compatible.*25. ***26. ** In the future, libhardware will expose a hw_get_module_version()*27. ** (or equivalent) function that will take minimum&#x2F;maximum supported*28. ** versions as arguments and would be able to reject modules with*29. ** versions outside of the supplied range.*30. **&#x2F;*31. uint16_t module_api_version;32. \#define version_major module_api_version33. *&#x2F;***34. ** version_major&#x2F;version_minor defines are supplied here for temporary*35. ** source code compatibility. They will be removed in the next version.*36. ** ALL clients must convert to the new version format.*37. **&#x2F;*38. 39. *&#x2F;***40. ** The API version of the HAL module interface. This is meant to*41. ** version the hw_module_t, hw_module_methods_t, and hw_device_t*42. ** structures and definitions.*43. ***44. ** The HAL interface owns this field. Module users&#x2F;implementations*45. ** must NOT rely on this value for version information.*46. ***47. ** Presently, 0 is the only valid value.*48. **&#x2F;*49. uint16_t hal_api_version;50. \#define version_minor hal_api_version51. 52. *&#x2F;** Identifier of module \*&#x2F;*53. const char *id;54. 55. *&#x2F;** Name of this module \*&#x2F;*56. const char *name;57. 58. *&#x2F;** Author&#x2F;owner&#x2F;implementor of the module \*&#x2F;*59. const char *author;60. 61. *&#x2F;** Modules methods \*&#x2F;*62. struct hw_module_methods_t* methods;63. 64. *&#x2F;** module&#39;s dso \*&#x2F;*65. void* dso;66. 67. \#ifdef __LP64__68. uint64_t reserved[32-7];69. \#else70. *&#x2F;** padding to 128 bytes, reserved for future use \*&#x2F;*71. uint32_t reserved[32-7];72. \#endif73. 74. &#125; hw_module_t;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们先看下结构体 hw_module_t 定义最前面的一段注释说明，它的意思是：</p><blockquote><p>每个硬件模块中都要定义一个名字叫做 HAL_MODULE_INFO_SYM 结构体变量，而这结构体变量中的第一个成员必须是 hw_module_t 类型。也就是说，每个硬件模块都要自己实现一个结构体，但是这个结构体的第一个成员必须是 hw_module_t 结构体类型。</p></blockquote><p><strong>其实这里蕴含着一种面向对象中继承的思想，hw_module_t 就是一个基类，描述所有硬件模块都应该具有的一些属性，然后具体到某个特定的硬件模块实现时，都需要继承自 hw_module_t 结构体。也就是说 hw_module_t 是所有特定硬件模块的父类。</strong></p><p>有关结构体 hw_module_t 中各个成员的具体含义，这里就不一一进行说明了，相信大家从它们的注释说明中就能了解到每一个成员所表示的含义，这里就挑一些重要的结构体成员来进一步说明。</p><blockquote><ul><li>id：这个成员用一个字符串来表示硬件模块的，用来区别于其他硬件模块。</li><li>methods：这个成员是一个 hw_module_methods_t 指针，它表示硬件模块所包含的方法集（其实里面就一个 open 函数指针，用来打开 hw_device_t 硬件设备，获得指向对应的硬件设备的结构体对象的指针）。</li><li>dso：我们前面提到，HAL 层中的<strong>硬件模块</strong>是用动态链接库表示的，所以 dso 指针就是系统使用 dlopen() 函数打开共享动态共享链接库之后获得的句柄。</li></ul></blockquote><h3 id="hw-device-t"><a href="#hw-device-t" class="headerlink" title="hw_device_t"></a>hw_device_t</h3><p>结构体 hw_device_t 定义在 <code>/hardware/libhardware/include/hardware/hardware.h</code> 文件中，其定义如下所示：</p><pre class="line-numbers language-none"><code class="language-none">1. *&#x2F;***2. ** Every device data structure must begin with hw_device_t*3. ** followed by module specific public methods and attributes.*4. **&#x2F;*5. typedef struct hw_device_t &#123;6. *&#x2F;** tag must be initialized to HARDWARE_DEVICE_TAG \*&#x2F;*7. uint32_t tag;8. 9. *&#x2F;***10. ** Version of the module-specific device API. This value is used by*11. ** the derived-module user to manage different device implementations.*12. ***13. ** The module user is responsible for checking the module_api_version*14. ** and device version fields to ensure that the user is capable of*15. ** communicating with the specific module implementation.*16. ***17. ** One module can support multiple devices with different versions. This*18. ** can be useful when a device interface changes in an incompatible way*19. ** but it is still necessary to support older implementations at the same*20. ** time. One such example is the Camera 2.0 API.*21. ***22. ** This field is interpreted by the module user and is ignored by the*23. ** HAL interface itself.*24. **&#x2F;*25. uint32_t version;26. 27. *&#x2F;** reference to the module this device belongs to \*&#x2F;*28. struct hw_module_t* module;29. 30. *&#x2F;** padding reserved for future use \*&#x2F;*31. \#ifdef __LP64__32. uint64_t reserved[12];33. \#else34. uint32_t reserved[12];35. \#endif36. 37. *&#x2F;** Close this device \*&#x2F;*38. int (*close)(struct hw_device_t* device);39. 40. &#125; hw_device_t;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>和 hw_module_t 类似，hw_device_t 也可以看做是一个基类，它描述了所有硬件设备都应该具有的属性，然后具体到某个特定的硬件设备（例如，音频播放时需要的扬声器设备）实现时，都需要继承自 audio_device 结构体。所以，每个 HAL 层中硬件设备对应的结构体中的第一个成员必须是 hw_device_t。</strong></p><p>下面还是简单提一下结构体 hw_device_t 比较关键的几个成员：</p><blockquote><ul><li>module：这个成员是一个 hw_module_t 指针，表示该结构体 hw_device_t 表示的<strong>硬件设备</strong>是由哪个 hw_module_t 表示的<strong>硬件模块</strong>进行管理的。（在这里所以一定要区分清楚==<strong>硬件设备</strong>==和==<strong>硬件模块</strong>==的区别！）</li><li>close：这是一个函数指针，表示如何关闭打开的硬件设备，通常==打开硬件设备的操作==在 hw_module_t 中包含的 hw_module_methods_t 函数列表中的 <strong>open()</strong> 函数中打开的。</li></ul></blockquote><h3 id="hw-module-methods-t"><a href="#hw-module-methods-t" class="headerlink" title="hw_module_methods_t"></a>hw_module_methods_t</h3><p>结构体 hw_module_methods_t 定义在 <code>/hardware/libhardware/include/hardware/hardware.h</code> 文件中，其定义如下所示：</p><pre class="line-numbers language-none"><code class="language-none">1. typedef struct hw_module_methods_t &#123;2. *&#x2F;** Open a specific device \*&#x2F;*3. int (*open)(const struct hw_module_t* module, const char* id,4. struct hw_device_t** device);5. 6. &#125; hw_module_methods_t;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结构体 hw_module_methods_t 就比较简单了，它里面就只有一个 <strong>open</strong> 函数指针，用来打开 module 硬件模块==所管理==的硬件设备id值为 id 的硬件设备，最后将打开的==硬件设备（用 hw_device_t 结构体来描述）==通过 device 返回。</p><p>*<em>注意：这个 open 函数明确指出第三个参数的类型为 struct hw_device_t*<em>，这主要是为了统一不同硬件设备向上层提供的硬件接口，然后在具体使用到某中硬件设备时，再转换成特定硬件设备的结构体类型。</em></em></p><h1 id="Audio-HAL-模块的实现"><a href="#Audio-HAL-模块的实现" class="headerlink" title="Audio HAL 模块的实现"></a>Audio HAL 模块的实现</h1><h3 id="Step-1：定义-struct-audio-module-模块"><a href="#Step-1：定义-struct-audio-module-模块" class="headerlink" title="Step 1：定义 struct audio_module 模块"></a>Step 1：定义 struct audio_module 模块</h3><p>我们前面在结构体 hw_module_t 介绍时，有提到具体的<strong>硬件模块</strong>要定义一个新的结构体并且这个结构体的==第一个成员必须是 hw_module_t 类型==，所以根据这个规则，audio_module 的定义如下所示：</p><p>代码路径：<code>/hardware/libhardware/include/hardware/audio.h</code></p><pre class="line-numbers language-none"><code class="language-none">1. struct audio_module &#123;2. struct hw_module_t common;3. &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="step-2：定义-struct-audio-module-类型的-HAL-MODULE-INFO-SYM-变量"><a href="#step-2：定义-struct-audio-module-类型的-HAL-MODULE-INFO-SYM-变量" class="headerlink" title="step 2：定义 struct audio_module 类型的 HAL_MODULE_INFO_SYM 变量"></a>step 2：定义 struct audio_module 类型的 HAL_MODULE_INFO_SYM 变量</h3><p>HAL_MODULE_INFO_SYM 其实是一个宏，它定义如下所示：</p><p>代码路径：<code>/hardware/libhardware/include/hardware/hardware.h</code></p><pre class="line-numbers language-none"><code class="language-none">1. *&#x2F;***2. ** Name of the hal_module_info*3. **&#x2F;*4. \#define HAL_MODULE_INFO_SYM HMI5. 6. *&#x2F;***7. ** Name of the hal_module_info as a string*8. **&#x2F;*9. \#define HAL_MODULE_INFO_SYM_AS_STR &quot;HMI&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而 struct audio_module 类型名为 <code>HAL_MODULE_INFO_SYM</code> 变量的定义如下所示：</p><p>代码路径：<code>&lt;aosp&gt;/generic/goldfish/audio/audio_hw.c</code></p><pre class="line-numbers language-none"><code class="language-none">1. struct audio_module HAL_MODULE_INFO_SYM &#x3D; &#123;2. .common &#x3D; &#123;3. .tag &#x3D; HARDWARE_MODULE_TAG,4. .module_api_version &#x3D; AUDIO_MODULE_API_VERSION_0_1,5. .hal_api_version &#x3D; HARDWARE_HAL_API_VERSION,6. .id &#x3D; AUDIO_HARDWARE_MODULE_ID,7. .name &#x3D; &quot;Generic audio HW HAL&quot;,8. .author &#x3D; &quot;The Android Open Source Project&quot;,9. .methods &#x3D; &amp;hal_module_methods,10. &#125;,11. &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>但是我们为什么要在每个硬件模块中都定义一个变量名为 HAL_MODULE_INFO_SYM 的变量呢？</strong></p><p>原因是<strong>为了统一标准的接口</strong>。这个硬件模块类型的变量主要是在 HAL 动态链接库加载时用到，它使得上层的 Framework 层打开所有的 HAL 动态链接库时都能找到名为 HAL_MODULE_INFO_SYM（也就是 hmi）的硬件模块类型变量，然后通过这个变量再来打开它所管理的硬件设备，从而与之进行交互。这么做的好处就是 Framework 层中只需要用相同的 API，就能处理各个厂商所提供的不同的 HAL 动态链接库。</p><p>在上面音频硬件设备结构体 <code>audio_hw_device</code> 的定义中，第一个结构体成员就是 <code>struct hw_device_t</code>类型的，而其他的结构体成员都是函数指针，例如 <code>open_output_stream</code> 函数就是用来打开播放音频的扬声器设备，<code>open_input_stream</code> 函数则是用来打开录音用的麦克风设备。</p><h3 id="step-3：定义-struct-audio-hw-device-硬件设备结构体"><a href="#step-3：定义-struct-audio-hw-device-硬件设备结构体" class="headerlink" title="step 3：定义 struct audio_hw_device 硬件设备结构体"></a>step 3：定义 struct audio_hw_device 硬件设备结构体</h3><p>每个硬件设备都需要通过一个结构体来表示，并且这个结构体的第一个成员必须是 hw_device_t 类型。而有关的对底层硬件设备的有关操作的函数指针接口，也是在这个结构体中定义。 struct audio_hw_device 硬件设备结构体的定义如下所示：</p><p>代码路径：<code>/hardware/libhardware/include/hardware/audio.h</code></p><pre class="line-numbers language-none"><code class="language-none">1. struct audio_hw_device &#123;2. *&#x2F;***3. ** Common methods of the audio device. This \*must\* be the first member of audio_hw_device*4. ** as users of this structure will cast a hw_device_t to audio_hw_device pointer in contexts*5. ** where it&#39;s known the hw_device_t references an audio_hw_device.*6. **&#x2F;*7. struct hw_device_t common;8. 9. ......10. 11. *&#x2F;\* Returns audio input buffer size according to parameters passed or*12. ** 0 if one of the parameters is not supported.*13. ** See also get_buffer_size which is for a particular stream.*14. **&#x2F;*15. size_t (*get_input_buffer_size)(const struct audio_hw_device *dev,16. const struct audio_config *config);17. 18. *&#x2F;** This method creates and opens the audio hardware output stream.*19. ** The &quot;address&quot; parameter qualifies the &quot;devices&quot; audio device type if needed.*20. ** The format format depends on the device type:*21. ** - Bluetooth devices use the MAC address of the device in the form &quot;00:11:22:AA:BB:CC&quot;*22. ** - USB devices use the ALSA card and device numbers in the form &quot;card&#x3D;X;device&#x3D;Y&quot;*23. ** - Other devices may use a number or any other string.*24. **&#x2F;*25. 26. int (*open_output_stream)(struct audio_hw_device *dev,27. audio_io_handle_t handle,28. audio_devices_t devices,29. audio_output_flags_t flags,30. struct audio_config *config,31. struct audio_stream_out **stream_out,32. const char *address);33. 34. void (*close_output_stream)(struct audio_hw_device *dev,35. struct audio_stream_out* stream_out);36. 37. *&#x2F;** This method creates and opens the audio hardware input stream \*&#x2F;*38. int (*open_input_stream)(struct audio_hw_device *dev,39. audio_io_handle_t handle,40. audio_devices_t devices,41. struct audio_config *config,42. struct audio_stream_in **stream_in,43. audio_input_flags_t flags,44. const char *address,45. audio_source_t source);46. 47. void (*close_input_stream)(struct audio_hw_device *dev,48. struct audio_stream_in *stream_in);49. 50. ......51. 52. &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="step-4：定义-struct-hw-module-methods-t-函数列表变量"><a href="#step-4：定义-struct-hw-module-methods-t-函数列表变量" class="headerlink" title="step 4：定义 struct hw_module_methods_t 函数列表变量"></a>step 4：定义 struct hw_module_methods_t 函数列表变量</h3><p>在前面介绍的结构体 hw_module_t 的定义中就有一个 hw_module_methods_t 函数指针类型的成员<code>open</code>，该函数的作用就是让<strong>硬件模块</strong>打开<strong>硬件设备</strong>，然后对特定硬件设备（例如上面的 struct audio_device_t结构体）中定义函数指针变量进行赋值绑定，所以在每个<strong>硬件模块</strong>都要实现这样一个变量。</p><p>struct audio_module 结构体中 <code>struct hw_module_t 类型的成员 common</code>中的 hw_module_methods_t 函数指针成员的实现绑定如下所示：</p><p>代码路径：<code>&lt;aosp&gt;/generic/goldfish/audio/audio_hw.c</code></p><pre class="line-numbers language-none"><code class="language-none">1. static struct hw_module_methods_t hal_module_methods &#x3D; &#123;2. .open &#x3D; adev_open,3. &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看到，在 audio HAL 模块中使用了 <code>adev_open</code> 函数来初始化了 struct hw_module_methods_t 中的 <code>open</code> 函数指针成员。我们现在回过头来看 <strong>step 2</strong>中 <strong>struct audio_module HAL_MODULE_INFO_SYM</strong> 变量的定义中，audio_module 中的第一个成员 common中的结构体变量 methods 的指针就是被初始化指向了现在这里定义的 <code>hal_module_methods</code> 变量。</p><h3 id="step-5：adev-open-函数的实现"><a href="#step-5：adev-open-函数的实现" class="headerlink" title="step 5：adev_open 函数的实现"></a>step 5：adev_open 函数的实现</h3><p>最后，我们来看看 <code>adev_open</code> 函数的实现，看看它是如何通过 audio_module 硬件模块对象来打开 audio_hw_device 硬件设备对象。</p><p>代码路径：<code>&lt;aosp&gt;/generic/goldfish/audio/audio_hw.c</code></p><pre class="line-numbers language-none"><code class="language-none">1. static int adev_open(const hw_module_t* module, const char* name,2. hw_device_t** device)3. &#123;4. struct generic_audio_device *adev;5. int fd;6. 7. if (strcmp(name, AUDIO_HARDWARE_INTERFACE) !&#x3D; 0)8. return -EINVAL;9. 10. fd &#x3D; open(AUDIO_DEVICE_NAME, O_RDWR);11. if (fd &lt; 0)12. return -ENOSYS;13. 14. adev &#x3D; calloc(1, sizeof(struct generic_audio_device));15. 16. adev-&gt;fd &#x3D; fd;17. 18. adev-&gt;device.common.tag &#x3D; HARDWARE_DEVICE_TAG;19. adev-&gt;device.common.version &#x3D; AUDIO_DEVICE_API_VERSION_2_0;20. adev-&gt;device.common.module &#x3D; (struct hw_module_t *) module;21. adev-&gt;device.common.close &#x3D; adev_close;22. 23. adev-&gt;device.init_check &#x3D; adev_init_check;24. adev-&gt;device.set_voice_volume &#x3D; adev_set_voice_volume;25. adev-&gt;device.set_master_volume &#x3D; adev_set_master_volume;26. adev-&gt;device.get_master_volume &#x3D; adev_get_master_volume;27. adev-&gt;device.set_master_mute &#x3D; adev_set_master_mute;28. adev-&gt;device.get_master_mute &#x3D; adev_get_master_mute;29. adev-&gt;device.set_mode &#x3D; adev_set_mode;30. adev-&gt;device.set_mic_mute &#x3D; adev_set_mic_mute;31. adev-&gt;device.get_mic_mute &#x3D; adev_get_mic_mute;32. adev-&gt;device.set_parameters &#x3D; adev_set_parameters;33. adev-&gt;device.get_parameters &#x3D; adev_get_parameters;34. adev-&gt;device.get_input_buffer_size &#x3D; adev_get_input_buffer_size;35. adev-&gt;device.open_output_stream &#x3D; adev_open_output_stream;36. adev-&gt;device.close_output_stream &#x3D; adev_close_output_stream;37. adev-&gt;device.open_input_stream &#x3D; adev_open_input_stream;38. adev-&gt;device.close_input_stream &#x3D; adev_close_input_stream;39. adev-&gt;device.dump &#x3D; adev_dump;40. 41. *device &#x3D; &amp;adev-&gt;device.common;42. 43. return 0;44. &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里再补充一个小的定义，<code>struct generic_audio_device</code> 中的第一个成员 <code>device</code> 就是我们前面提到的 <code>struct audio_hw_device</code> 结构体，它的定义如下:</p><p>代码路径：<code>/hardware/libaudio/audio_hw.c</code></p><pre class="line-numbers language-none"><code class="language-none">1. struct generic_audio_device &#123;2. struct audio_hw_device device;3. pthread_mutex_t lock;4. struct audio_stream_out *output;5. struct audio_stream_in *input;6. int fd;7. bool mic_mute;8. &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以从 <code>adev_open</code> 函数中的实现中看到，它里面的主要工作就是做一些对 <code>struct audio_hw_device</code>对象的初始化，将其定义的函数指针指向对应的已经实现好的函数中。例如，这里将<code>struct audio_hw_device</code>中定义的 <code>open_output_stream</code> 函数指针成员指向了 <code>adev_open_output_stream</code> 函数。这样在 Framework 层调用的 <code>struct audio_hw_device</code> 对象的 <code>open_output_stream</code> 函数，其实最终调用的是 <code>adev_open_output_stream</code>函数。</p><p><strong>这里，还有一点需要特别注意的就是我们所打开的硬件设备对象是怎么返回的？</strong> 答案就是它是通过 <code>open</code>函数中的第三个参数 <code>hw_device_t** device</code>返回的。在 open 函数初始化并打开特定的硬件设备之后，它就将硬件设备结构体中的第一个成员 <code>struct audio_hw_device</code> 类型的 common 对象返回。</p><p><em><em>那么为什么这里返回的是 hw_device_t*</em> 类型的硬件设备，而不是audio_hw_device*</em> 类型呢？** 其实这个问题在前面在介绍 <code>hw_module_methods_t</code> 中的 <code>open</code> 函数时已经提到过了。这里主要也蕴含着面向对象编程中的另外一种重要思想<strong>多态</strong>，这使得使用的 hw_device_t 指针就可以访问到子类中继承了父类的属性和方法，如果要获得某个子类所特有的属性，那么只要将其进行类型的强制转换即可。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>理解 Android HAL 层最关键的还是要弄清楚 hw_module_t 、 hw_device_t、 hw_module_methods_t 这三个结构体的含义即关系，以及如何基于这三个结构体来实现特定硬件的<strong>硬件模块结构体</strong>、<strong>硬件设备结构体</strong>、<strong>硬件模块方法列表结构体</strong>。其实从面向对象编程的角度来考虑，前面三者和后面三者之间的关系，就好比是父类和子类的关系。</p>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android编译流程</title>
      <link href="2021/05/21/0-ri-chang-xue-xi/android-bian-yi-liu-cheng/"/>
      <url>2021/05/21/0-ri-chang-xue-xi/android-bian-yi-liu-cheng/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/05/21/0-ri-chang-xue-xi/android-bian-yi-liu-cheng/11.png"></p> <center>图一 编译流程（旧）取自Google官方的<a href="http://developer.android.com/sdk/installing/studio-build.html#detailed-build">[Build System Overview]</a></center><p>注解：</p><ul><li>图中绿色标注为其中用到的相应工具，蓝色代表的是中间生成的各类文件类型；</li><li>首先aapt工具会将资源文件进行转化，生成对应资源ID的R文件和资源文件；</li><li>adil工具会将其中的aidl接口转化成Java的接口；</li><li>至此，Java Compiler开始进行Java文件向class文件的转化，将R文件，Java源代码，由aidl转化来的Java接口，统一转化成.class文件；</li><li>通过dx工具将class文件转化为dex文件；</li><li>此时我们得到了经过处理后的资源文件和一个dex文件，当然，还会存在一些其它的资源文件，这个时候，就是将其打包成一个类似apk的文件，但还并不是直接可以安装在Android系统上的APK文件；</li><li>通过签名工具对其进行签名；</li><li>通过Zipalign进行优化，提升运行速度；</li><li>最终生成一个可以安装在我们手机上的APK；</li></ul><p><img src="/2021/05/21/0-ri-chang-xue-xi/android-bian-yi-liu-cheng/12.png"></p> <center>图二 编译流程（新）取自Google官方<a href="http://tools.android.com/tech-docs/new-build-system/build-workflow">New Build System</a>的Build WorkFlow</center><p>按照上述构建过程进行具体分析：</p><p>第1步：aapt打包资源文件，生成R.java和编译后的资源（二进制文件）</p><p>注解：Android中的资源文件有那些呢?Android应用程序资源可以分为两大类，分别是assets和res：</p><p>1）assets类资源放在工程根目录的assets子目录下，它里面保存的是一些原始的文件，可以以任何方式来进行组织。这些文件最终会被原装不动地打包在apk文件中。如果我们要在程序中访问这些文件，那么就需要指定文件名来访问。例如，假设在assets目录下有一个名称为filename的文件，那么就可以使用以下代码来访问它：</p><blockquote><p>AssetManager am= getAssets();  </p><p>InputStream is = assset.open(“filename”); </p></blockquote><p>2）res类资源放在工程根目录的res子目录下，它里面保存的文件大多数都会被编译，并且都会被赋予资源ID。这样我们就可以在程序中通过ID来访问res类的资源。res类资源按照不同的用途可以进一步划分为以下10种子类型：</p><p>layout(布局文件)，drawable，xml，value，menu，raw，color，anim，animator，mipmap。</p><p>为了使得一个应用程序能够在运行时同时支持不同的大小和密度的屏幕，以及支持国际化，即支持不同的国家地区和语言，Android应用程序资源的组织方式有18个维度，每一个维度都代表一个配置信息，从而可以使得应用程序能够根据设备的当前配置信息来找到最匹配的资源来展现在UI上，从而提高用户体验。由于Android应用程序资源的组织方式可以达到18个维度，因此就要求Android资源管理框架能够快速定位最匹配设备当前配置信息的资源来展现在UI上，否则的话，就会影响用户体验。为了支持Android资源管理框架快速定位最匹配资源，Android资源打包工具aapt在编译和打包资源的过程中，会执行以下两个额外的操作：</p><blockquote><p>1）赋予每一个非assets资源一个ID值，这些ID值以常量的形式定义在一个R.java文件中。</p><p>2）生成一个resources.arsc文件，用来描述那些具有ID值的资源的配置信息，它的内容就相当于是一个资源索引表。包含了所有的id值的数据集合。在该文件中，如果某个id对应的是string，那么该文件会直接包含该值，如果id对应的资源是某个layout或者drawable资源，那么该文件会存入对应资源的路径。</p></blockquote><p>第2步：进行aidl（Android Interface Definition Language，即Android接口定义语言。是我们在编写进程间通信的代码的时候，定义的接口）转换</p><blockquote><p>输入：aidl后缀的文件；</p><p>输出：可用于进程通信的C/S端java代码，位于build/generated/source/aidl；</p></blockquote><p>第3步：Java源码编译</p><p>使用javac将R.java和aidl生成的Java文件，加上工程的源代码进行正常的java编译生成class文件；</p><blockquote><p>输入：java source的文件夹（另外还包括了build/generated下的：R.java, aidl生成的java文件，以及BuildConfig.java）；</p><p>输出：对于gradle编译，可以在build/intermediates/classes里，看到输出的class文件。</p></blockquote><p>第4步：代码混淆（proguard）</p><p>源码编译之后，我们可能还会对其进行代码的混淆，混淆的作用是增加反编译的难度，同时也将一些代码的命名进行了缩短，减少代码占用的空间。混淆完成之后，会生成一个混淆前后的映射表，这个是用来在反应我们的应用执行的时候的一些堆栈信息，可以将混淆后的信息转化为我们混淆前实际代码中的内容。</p><p>而这个过程使用的工具就是ProGuard，是一个开源的Java代码混淆器（obfuscation）。ADT r8开始它被默认集成到了Android SDK中。 其具备三个主要功能。</p><blockquote><p>1）压缩 - 移除无效的类、属性、方法等</p><p>2）优化 - 优化bytecode移除没用的结构</p><p>3）混淆 - 把类名、属性名、方法名替换为晦涩难懂的1到2个字母的名字</p></blockquote><p>当然它也只能混淆Java代码，Android工程中Native代码，资源文件（图片、xml），它是无法混淆的。而且对于Java的常量值也是无法混淆的，所以不要使用常量定义平文的密码等重要信息。同时对于混淆，我们可以通过代码制定去混淆那些，不去混淆那些。</p><p>-keep public class com.rensanning.example.Test</p><p>第5步：转化为dex</p><p>调用dx.bat将所有的class文件转化为classes.dex文件，dx会将class转换为Dalvik字节码，生成常量池，消除冗余数据等。由于dalvik是一种针对嵌入式设备而特殊设计的java虚拟机，所以dex文件与标准的class文件在结构设计上有着本质的区别,当java程序编译成class后，使用dx工具将所有的class文件整合到一个dex文件，目的是其中各个类能够共享数据，在一定程度上降低了冗余，同时也是文件结构更加经凑，实验表明，dex文件是传统jar文件大小的50%左右。class文件结构和dex文件结构比对。</p><p>第6步：apkbuilder</p><p>打包生成APK文件。旧的apkbuilder脚本已经废弃，现在都已经通过sdklib.jar的ApkBuilder类进行打包了。输入为我们之前生成的包含resources.arcs的.ap_文件，上一步生成的dex文件，以及其他资源如jni、.so文件。大致步骤为以包含resources.arcs的.ap_文件为基础，new一个ApkBuilder，设置debugMode</p><blockquote><p>apkBuilder.addZipFile(f);</p><p>apkBuilder.addSourceFolder(f);</p><p>apkBuilder.addResourcesFromJar(f);</p><p>apkBuilder.addNativeLibraries(nativeFileList);</p><p>apkBuilder.sealApk(); // 关闭apk文件</p><p>generateDependencyFile(depFile,inputPaths,outputFile.getAbsolutePath());</p></blockquote><p>第7步：对APK签名</p><p>对APK文件进行签名。Android系统在安装APK的时候，首先会检验APK的签名，如果发现签名文件不存在或者校验签名失败，则会拒绝安装，所以应用程序在发布之前一定要进行签名。签名信息中包含有开发者信息，在一定程度上可以防止应用被伪造。对一个APK文件签名之后，APK文件根目录下会增加META-INF目录，该目录下增加三个文件：</p><blockquote><p>MANIFEST.MF</p><p>[CERT].RSA</p><p>[CERT]</p></blockquote><p>Android系统就是根据这三个文件的内容对APK文件进行签名检验的。签名过程主要利用apksign.jar或者jarsinger.jar两个工具。将根据我们提供的Debug和Release两个版本的Keystore进行相应的签名。</p><p>MANIFEST.MF中包含对apk中除了/META-INF文件夹外所有文件的签名值，签名方法是先SHA1()(或其他hash方法)在base64()。存储形式是：Name加[SHA1]-Digest。</p><p>[CERT].SF是对MANIFEST.MF文件整体签名以及其中各个条目的签名。一般地，如果是使用工具签名，还多包括一项。就是对MANIFEST.MF头部信息的签名。</p><p>[CERT].RSA包含用私钥对[CERT].SF的签名以及包含公钥信息的数字证书。</p><p>第8步：zipalign优化</p><p>Zipalign是一个Android平台上整理APK文件的工具，它首次被引入是在Android 1.6版本的SDK软件开发工具包中。它能够对打包的Android应用程序进行优化， 以使Android操作系统与应用程序之间的交互作用更有效率，这能够让应用程序和整个系统运行得更快。用Zipalign处理过的应用程序执行时间达到最低限度，当设备运行APK应用程序时占更少的RAM。</p><p>Zipalign如何进行优化的呢？调用buildtoolszipalign，对签名后的APK文件进行对齐处理，使APK中所有资源文件距离文件起始偏移为4字节的整数倍，从而在通过内存映射访问APK文件时会更快。同时也减少了在设备上运行时的内存消耗。</p><p>至此，一个完整的Android APK就生成了。</p>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>商业模式新生代</title>
      <link href="2021/05/20/0-du-shu-bi-ji/shang-ye-mo-shi-xin-sheng-dai/"/>
      <url>2021/05/20/0-du-shu-bi-ji/shang-ye-mo-shi-xin-sheng-dai/</url>
      
        <content type="html"><![CDATA[<ol><li>CS客户细分–customer segments：任何一个组织都会服务于一个或多个客户群体</li><li>VP价值主张–value propositions：一个组织的价值主张在于解决客户的问题和满足客户的需求</li><li>CH渠道通路–channels：价值主张通过沟通、分发以及销售渠道传递给客户</li><li>CR客户关系–customer relationships：客户关系以客户群体为单位建立和维护</li><li>R$收入来源–revenue streams：收入来源于将价值主张成功地提供给客户</li><li>KR核心资源–key resources：核心资源是指为实现上述各项元素的供给和交付而必须的资源</li><li>KA关键业务–key activities：为实现供给和交付所需完成的关键业务活动</li><li>KP重要合作–key partnerships：部分活动需要外包，部分资源需要从其他企业获得</li><li>C$成本结构–cost structure：成本结构取决于经济模式中的各项元素</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>身体语言密码</title>
      <link href="2021/05/20/0-du-shu-bi-ji/shen-ti-yu-yan-mi-ma/"/>
      <url>2021/05/20/0-du-shu-bi-ji/shen-ti-yu-yan-mi-ma/</url>
      
        <content type="html"><![CDATA[<ul><li>绝大多数的男性和将近半数的女性并不知道自己脖子以下的身体究竟是何种模样。</li></ul><ul><li>20 世纪 50 年代的一位研究肢体语言的先锋人物阿尔伯特·麦拉宾发现：一条信息所产生的全部影响力中 7%来自于语言（仅指文字），38%来自于声音（其中包括语音、音调以及其他声音），剩下的 55%则全部来自于无声的肢体语言。</li></ul><ul><li>所谓“感知力强”，也就是指能够通过观察发现人们的话语和他们的肢体语言之间的矛盾之处。</li></ul><ul><li>正确解读身体语言的三大规则：</li></ul><ol><li>连贯地理解</li><li>寻找一致性</li><li>结合语境来理解</li></ol><ul><li>投降的小狗会吐出舌头以示友好，人则会亮出自己的手掌</li></ul><ul><li>男性的手臂稍稍向内侧弯曲，而女性的手臂则恰恰相反。稍稍向内侧弯曲的手臂使得男性在瞄准和投掷时能够更加准确，而女性略微向外侧张开的手臂则使得她们能在抱孩子时更加平稳。</li></ul><ul><li>正在撒谎——他的嘴唇在颤抖</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>横向领导力</title>
      <link href="2021/05/20/0-du-shu-bi-ji/heng-xiang-ling-dao-li/"/>
      <url>2021/05/20/0-du-shu-bi-ji/heng-xiang-ling-dao-li/</url>
      
        <content type="html"><![CDATA[<ul><li>培养个人技能，明确目标，影响他人</li></ul><ul><li>我们遇到问题时总是喜欢责怪别人，取得成绩时则喜欢把荣誉据为己有，这是人类的通病。</li></ul><ol><li>根据你想要实现的结果制定目标</li><li>有条理地思考，从数据，到分析，到方向，再到具体行动</li><li>在经验中学习，随时学习，随时总结</li><li>通过接受具有挑战性的任务，充分投入到工作中</li><li>对于应该坚持的工作方法和需要改进的工作方法提供和寻求反馈</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="2021/05/12/ji-suan-ji-wang-luo/"/>
      <url>2021/05/12/ji-suan-ji-wang-luo/</url>
      
        <content type="html"><![CDATA[<ul><li>互联网之所以能够向用户提供许多服务，就是因为互联网具有两个重要基本特点，即连通性和共享。</li></ul><blockquote><p>电路交换——整个报文的比特流连续地从源点直达终点，好像在一个管道中传送。</p><p>报文交换——整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。</p><p>分组交换——单个分组（这只是整个报文的一部分）传送到相邻结点，存储下来后查找转发表，转发到下一个结点。</p><p>若要连续传送大量的数据，且其传送时间远大于连接建立时间，则电路交换的传输效率较快。报文交换和分组交换不需要预先分配传输带宽，在传送突发数据时可提高整个网络的信道利用率。由于一个分组的长度往往远小于整个报文的长度，因此分组交换比报文交换的时延小，同时也具有更好的灵活性。</p></blockquote><ul><li>对于高速网络链路，我们提高的仅仅是数据的发送速率而不是比特在链路上的传播速率，传播速率只取决于通信线路的介质材料。因此，通常说的“光纤信道的传输速率高”是指可以用很高的速率向光纤信道发送数据，而光纤信道的传播速率实际上还要比铜线的传播速率略低一些。</li></ul><ul><li>信道或网络的利用率过高会产生非常大的时延。</li></ul><ul><li>能够占领市场的就是标准。</li></ul><ul><li>看一台计算机网络协议是否正确，不能只看在正常情况下是否正确，而且还必须非常仔细地检查这个协议能否应付各种异常情况。</li></ul><ul><li>在任何信道中，码元传输的速率是有上限的，传输速率超过此上限，就会出现严重的码间串扰的问题，使接收端对码元的判决（即识别）成为不可能。</li></ul><ul><li>信号应当有足够大的振幅，以便在噪声干扰下能够在接收端正确地被检测出来。</li></ul><ul><li>时分复用更有利于数字信号的传输</li></ul><ul><li>把电话分离器做成无源的是为了在停电时不影响传统电话的使用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>产品经理必懂的技术那点事儿</title>
      <link href="2021/05/11/0-du-shu-bi-ji/chan-pin-jing-li-bi-dong-de-ji-zhu-na-dian-shi-er/"/>
      <url>2021/05/11/0-du-shu-bi-ji/chan-pin-jing-li-bi-dong-de-ji-zhu-na-dian-shi-er/</url>
      
        <content type="html"><![CDATA[<ul><li>产品思维侧重从用户和商业视角出发，技术思维侧重在技术实现和系统框架层面，两种思维方式也有交叉点，那就是产品的需求、设计和产品功能。</li></ul><ul><li>产品定位是否清晰直接决定了产品以什么样的形态呈现给用户使用。</li></ul><ul><li>产品经理必现回答的8个问题：<ol><li>产品的目标用户是谁？</li><li>产品为目标用户解决了一个什么核心问题？</li><li>产品的核心功能是什么？</li><li>产品的使用场景是什么？</li><li>产品给目标用户带来的价值是什么？</li><li>如何用一句话介绍产品是什么？</li><li>与同类产品的定位差异是什么？</li><li>产品的盈利模式是什么？</li></ol></li></ul><ul><li>懂技术不如懂产品，去理解产品、理解用户才是真正把产品做好的决定性条件。</li></ul><ul><li>在现在竞争激烈且同质化竞争严重的环境下，快速响应能力会成为一款产品的制胜要诀。应对快速响应有一个理论方法可以采用，那就是MVP（minimum viable product，最小可行性产品）。做MVP需要化繁为简的能力，抓住本质核心，把关键路径上的节点做好后再去做细节分支。很多时候，人都有求全的心理，觉得没有这个会怎样，没有那个会怎样，实际却是不会怎样。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chrome更新书签策略</title>
      <link href="2021/04/26/0-ri-chang-xue-xi/chrome-geng-xin-shu-qian-ce-lue/"/>
      <url>2021/04/26/0-ri-chang-xue-xi/chrome-geng-xin-shu-qian-ce-lue/</url>
      
        <content type="html"><![CDATA[<h5 id="A：这个主要比对的是云端最后一次操作时间和你机器上的最后一次操作时间。（本地修改文件会自动更新修改日期）"><a href="#A：这个主要比对的是云端最后一次操作时间和你机器上的最后一次操作时间。（本地修改文件会自动更新修改日期）" class="headerlink" title="A：这个主要比对的是云端最后一次操作时间和你机器上的最后一次操作时间。（本地修改文件会自动更新修改日期）"></a>A：这个主要比对的是云端最后一次操作时间和你机器上的最后一次操作时间。（本地修改文件会自动更新修改日期）</h5><p>如果某机器的最后一次操作时间比云端的最后一次操作时间要早，那么云端的配置比本地的配置要新，这时采用云端覆盖本地的操作，即下载。</p><p>如果某机器的最后一次登录时间比云端的最后一次操作时间要晚，那么本地的配置比云端的配置要新，这时采用本地覆盖云端的操作，即上传。</p><h5 id="B：目前采用的策略并非“最新的版本全替换”策略，而是“增量合并更新”的方式。"><a href="#B：目前采用的策略并非“最新的版本全替换”策略，而是“增量合并更新”的方式。" class="headerlink" title="B：目前采用的策略并非“最新的版本全替换”策略，而是“增量合并更新”的方式。"></a>B：目前采用的策略并非“最新的版本全替换”策略，而是“增量合并更新”的方式。</h5><p>即当A计算机的版本有更新时，在B计算机上存在旧版本的状态下，在B计算机上打开chrome同步，会采取增量更新合并的方式，即保留B计算机上的内容，同时同步获得A计算机上更新的内容。这样做的目的大概是为了保证本地（B计算机上）内容不因在A计算机的修改发生丢失，同时能够获得A计算机上更新的全部内容。这样的策略可以避免因为在A计算机上的误操作而导致B计算机上书签的丢失，保证了安全性，但是同时损失了书签的简洁性，增加了冗余性。个人还是推荐Google书签同步使用”最新版本全替换”的策略，同时增加书签“历史版本”，便于回滚和找回。</p>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WPS表格无法多窗口打开文件</title>
      <link href="2021/04/26/0-yi-nan-za-zheng/wps-biao-ge-wu-fa-duo-chuang-kou-da-kai-wen-jian/"/>
      <url>2021/04/26/0-yi-nan-za-zheng/wps-biao-ge-wu-fa-duo-chuang-kou-da-kai-wen-jian/</url>
      
        <content type="html"><![CDATA[<p>双击WPS表格EXE打开多个窗口后选择对应的文件打开</p>]]></content>
      
      
      <categories>
          
          <category> 疑难杂症 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>知乎不支持转载的文章怎样复制文字?</title>
      <link href="2021/04/26/0-yi-nan-za-zheng/zhi-hu-bu-zhi-chi-zhuan-zai-de-wen-zhang-zen-yang-fu-zhi-wen-zi/"/>
      <url>2021/04/26/0-yi-nan-za-zheng/zhi-hu-bu-zhi-chi-zhuan-zai-de-wen-zhang-zen-yang-fu-zhi-wen-zi/</url>
      
        <content type="html"><![CDATA[<p>只要从你要复制的最后开始往前选，一直选到开头的X人赞同的同字（包括同字），然后Ctrl+C，万事大吉（谷歌浏览器亲测有效，其余浏览器未测试）</p><p><img src="/2021/04/26/0-yi-nan-za-zheng/zhi-hu-bu-zhi-chi-zhuan-zai-de-wen-zhang-zen-yang-fu-zhi-wen-zi/da914189dbf73cea21ca53fecdc81c5f_720w.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 疑难杂症 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>日常学习01</title>
      <link href="2021/04/25/ri-chang-xue-xi-01/"/>
      <url>2021/04/25/ri-chang-xue-xi-01/</url>
      
        <content type="html"><![CDATA[<ul><li>宏病毒：鉴于绝大多数人都不需要或者不会使用宏功能，所以可以得出一个相对重要的结论：如果office文档在打开时，系统给出一个宏病毒警告框，就应该对这个文档保持高度警惕，它被感染的可能性极大。</li></ul><ul><li>解压缩：以往的压缩工具通常是将计算机中的资料或文档进行压缩，用来缩小存储空间，但是压缩后就不能再运行了，如果想运行必须解压缩。而ASPack是专门对Win32可执行程序进行压缩的工具，压缩后程序仍能正常运行，丝毫不会受到任何影响。</li></ul><ul><li>SQL注入：SQL注入通过网页修改网站数据库，它能够直接在数据库中添加具有管理员权限的用户，最终获得系统管理员权限。黑客利用获得的管理员权限任意获得网站上的文件或者在网页上加挂木马和各种恶意程序，对网站的正常运营和访问该网页的用户都带来巨大危害。</li></ul><ul><li>#define 是宏定义，它不能定义常量，但宏定义可以实现在字面意义上和其它定义常量相同的功能，本质的区别就在于 #define 不为宏名分配内存，而 const 也不为常量分配内存，怎么回事呢，其实 const 并不是去定义一个常量，而是去改变一个变量的存储类，把该变量所占的内存变为只读！</li></ul><ul><li>文件后缀名与封装是什么关系？文件后缀名就是封装的代名词，一般是对应关系，如mkv后缀名就表示的是mkv封装的文件。</li></ul><ul><li>文件后缀名修改后还能不能播放？早期的一些播放器用后缀名识别文件封装格式的，改掉后缀名后不能正常识别文件，现在很多播放器都是读取文件头信息来识别封装格式的，改掉是可以播放的。</li></ul><ul><li>git是用于Linux内核开发的版本控制工具。与CVS、Subversion一類的集中式版本控制工具不同，它采用了分布式版本库的作法，不需要服务器端软件，就可以運作版本控制，使得源代码的发布和交流极其方便。git的速度很快，这对于诸如Linux内核这样的大项目来说自然很重要。git最为出色的是它的合并追踪（merge tracing）能力</li></ul><ul><li>SVN更适用于项目管理， Git仅适用于代码管理</li></ul><ul><li>整个主机板上面最重要的就是芯片组了！而芯片组通常又分为两个桥接器来控制各组件的沟通，分别是：(1)北桥：负责连结速度较快的CPU、主内存与显示卡等组件；(2)南桥：负责连接速度较慢的周边介面，包括硬盘、USB、网络卡等等</li></ul><ul><li>假设你今天购买了500GB的硬盘一颗，但是格式化完毕后却只剩下460GB左右的容量，这是什么原因？答：因为一般硬盘制造商会使用十进位的单位，所以500GByte代表为500<em>1000</em>1000*1000Byte之意。转成档案的容量单位时使用二进位(1024为底)，所以就成为466GB左右的容量了。硬盘厂商并非要骗人，只是因为硬盘的最小物理量为512Bytes，最小的组成单位为磁区(sector)， 通常硬盘容量的计算采用『多少个sector』，所以才会使用十进位来处理的</li></ul>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>U盘病毒制作过程曝光</title>
      <link href="2021/04/25/u-pan-bing-du-zhi-zuo-guo-cheng-pu-guang/"/>
      <url>2021/04/25/u-pan-bing-du-zhi-zuo-guo-cheng-pu-guang/</url>
      
        <content type="html"><![CDATA[<h3 id="步骤1：将病毒或木马复制到U盘中"><a href="#步骤1：将病毒或木马复制到U盘中" class="headerlink" title="步骤1：将病毒或木马复制到U盘中"></a>步骤1：将病毒或木马复制到U盘中</h3><h3 id="步骤2：在U盘中新建文本文档，并重命名为“Autorun-inf”"><a href="#步骤2：在U盘中新建文本文档，并重命名为“Autorun-inf”" class="headerlink" title="步骤2：在U盘中新建文本文档，并重命名为“Autorun.inf”"></a>步骤2：在U盘中新建文本文档，并重命名为“Autorun.inf”</h3><h3 id="步骤3：用记事本打开“Autorun-inf”，编辑文件代码，使得双击U盘图标后运行制定木马程序"><a href="#步骤3：用记事本打开“Autorun-inf”，编辑文件代码，使得双击U盘图标后运行制定木马程序" class="headerlink" title="步骤3：用记事本打开“Autorun.inf”，编辑文件代码，使得双击U盘图标后运行制定木马程序"></a>步骤3：用记事本打开“Autorun.inf”，编辑文件代码，使得双击U盘图标后运行制定木马程序</h3><pre class="line-numbers language-none"><code class="language-none">[AutoRun]OPEN&#x3D;腾讯QQ.batshellexecute&#x3D;腾讯QQ.batshell\Auto\command&#x3D;腾讯QQ.bat]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2021/04/25/u-pan-bing-du-zhi-zuo-guo-cheng-pu-guang/image-20210425181201257.png"></p><h3 id="步骤4：将病毒或木马文件和“Autorun-inf”文件隐藏——在“属性”→“常规”界面勾选“隐藏”复选框"><a href="#步骤4：将病毒或木马文件和“Autorun-inf”文件隐藏——在“属性”→“常规”界面勾选“隐藏”复选框" class="headerlink" title="步骤4：将病毒或木马文件和“Autorun.inf”文件隐藏——在“属性”→“常规”界面勾选“隐藏”复选框"></a>步骤4：将病毒或木马文件和“Autorun.inf”文件隐藏——在“属性”→“常规”界面勾选“隐藏”复选框</h3><h3 id="最终：将U盘接入计算机中，右击U盘对应的图标，在快捷菜单中回到Auto命令，表示设置成功"><a href="#最终：将U盘接入计算机中，右击U盘对应的图标，在快捷菜单中回到Auto命令，表示设置成功" class="headerlink" title="最终：将U盘接入计算机中，右击U盘对应的图标，在快捷菜单中回到Auto命令，表示设置成功"></a>最终：将U盘接入计算机中，右击U盘对应的图标，在快捷菜单中回到Auto命令，表示设置成功</h3>]]></content>
      
      
      <categories>
          
          <category> 牛刀小试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 黑客尝试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令积累</title>
      <link href="2021/04/25/linux-ming-ling-ji-lei/"/>
      <url>2021/04/25/linux-ming-ling-ji-lei/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关机病毒制作</title>
      <link href="2021/04/22/0-niu-dao-xiao-shi/guan-ji-bing-du-zhi-zuo/"/>
      <url>2021/04/22/0-niu-dao-xiao-shi/guan-ji-bing-du-zhi-zuo/</url>
      
        <content type="html"><![CDATA[<h4 id="步骤1：打开新建的记事本，输入“shutdown-p”命令，即自动重启本地计算机，保存，重命名文本文档为“腾讯QQ-bat”"><a href="#步骤1：打开新建的记事本，输入“shutdown-p”命令，即自动重启本地计算机，保存，重命名文本文档为“腾讯QQ-bat”" class="headerlink" title="步骤1：打开新建的记事本，输入“shutdown -p”命令，即自动重启本地计算机，保存，重命名文本文档为“腾讯QQ.bat”"></a>步骤1：打开新建的记事本，输入“shutdown -p”命令，即自动重启本地计算机，保存，重命名文本文档为“腾讯QQ.bat”</h4><p><img src="/2021/04/22/0-niu-dao-xiao-shi/guan-ji-bing-du-zhi-zuo/image-20210425164750463.png"></p><h4 id="步骤2：右键单击“腾讯QQ-bat”图标，在弹出的菜单中单击“创建快捷方式命令”"><a href="#步骤2：右键单击“腾讯QQ-bat”图标，在弹出的菜单中单击“创建快捷方式命令”" class="headerlink" title="步骤2：右键单击“腾讯QQ.bat”图标，在弹出的菜单中单击“创建快捷方式命令”"></a>步骤2：右键单击“腾讯QQ.bat”图标，在弹出的菜单中单击“创建快捷方式命令”</h4><h4 id="步骤3：右键单击“腾讯QQ-bat-快捷方式”图标，在弹出的菜单中单击“属性”命令"><a href="#步骤3：右键单击“腾讯QQ-bat-快捷方式”图标，在弹出的菜单中单击“属性”命令" class="headerlink" title="步骤3：右键单击“腾讯QQ.bat-快捷方式”图标，在弹出的菜单中单击“属性”命令"></a>步骤3：右键单击“腾讯QQ.bat-快捷方式”图标，在弹出的菜单中单击“属性”命令</h4><h4 id="步骤4：切换至“快捷方式”选项卡，单击“更改图标”按钮，改成腾讯QQ的图标"><a href="#步骤4：切换至“快捷方式”选项卡，单击“更改图标”按钮，改成腾讯QQ的图标" class="headerlink" title="步骤4：切换至“快捷方式”选项卡，单击“更改图标”按钮，改成腾讯QQ的图标"></a>步骤4：切换至“快捷方式”选项卡，单击“更改图标”按钮，改成腾讯QQ的图标</h4><p><img src="/2021/04/22/0-niu-dao-xiao-shi/guan-ji-bing-du-zhi-zuo/image-20210425162955428.png"></p><h4 id="步骤5：右键单击“腾讯QQ-bat”图标，在弹出的菜单中单击“属性”，切换到“常规”选项卡，勾选“隐藏”勾选框"><a href="#步骤5：右键单击“腾讯QQ-bat”图标，在弹出的菜单中单击“属性”，切换到“常规”选项卡，勾选“隐藏”勾选框" class="headerlink" title="步骤5：右键单击“腾讯QQ.bat”图标，在弹出的菜单中单击“属性”，切换到“常规”选项卡，勾选“隐藏”勾选框"></a>步骤5：右键单击“腾讯QQ.bat”图标，在弹出的菜单中单击“属性”，切换到“常规”选项卡，勾选“隐藏”勾选框</h4><p><img src="/2021/04/22/0-niu-dao-xiao-shi/guan-ji-bing-du-zhi-zuo/image-20210425163106991.png"></p><h4 id="最终：可看到桌面上未显示“腾讯QQ-bat”图标，只显示了“腾讯QQ”图标，用户一旦双击该图标计算机便会关机"><a href="#最终：可看到桌面上未显示“腾讯QQ-bat”图标，只显示了“腾讯QQ”图标，用户一旦双击该图标计算机便会关机" class="headerlink" title="最终：可看到桌面上未显示“腾讯QQ.bat”图标，只显示了“腾讯QQ”图标，用户一旦双击该图标计算机便会关机"></a>最终：可看到桌面上未显示“腾讯QQ.bat”图标，只显示了“腾讯QQ”图标，用户一旦双击该图标计算机便会关机</h4><p><img src="/2021/04/22/0-niu-dao-xiao-shi/guan-ji-bing-du-zhi-zuo/image-20210425165826248.png"></p><h4 id="关机相关命令介绍："><a href="#关机相关命令介绍：" class="headerlink" title="关机相关命令介绍："></a>关机相关命令介绍：</h4><p>一段时间后关机：shutdown -s -t 秒数效果是倒计时到该秒数后关机，例如shutdown -s -t 3600就是3600秒后关机，也就是一小时后关机</p><p>立即关机命令：shutdown -p关闭本地计算机，效果是马上关机，而不进行倒计时；也可以使用shutdown -s -t 0设置0秒后关机，也就是立即关机的意思</p><p>一段时间后重启：shutdown -r -t 秒数，效果是倒计时该秒数后重启，例如shutdown -r -t 0倒数0秒后重启，也就是立即重启的意思，如果没有加-t参数则会倒计时默认的秒数后关机，一般是一分钟</p><p>休眠命令：shutdown -h,这条指令让计算机休眠，也就是完全断电，但是会保存当前电脑的状态，下次启动时这些打开过的程序都还在。类似虚拟机的挂起功能</p><p>睡眠指令：睡眠和休眠的不同的地方是，睡眠没有完全掉电，电脑中其他的耗电部分都关闭，只留下内存供电，下次在唤醒电脑的时候，恢复到睡眠之前的状态。这点和休眠类似，睡眠的好处就是启动快。短时间离开电脑的话可以睡眠，如果时间间隔比较久的话用休眠。休眠和关机一样是不耗电的，而睡眠因为还有给内存供电，所以睡眠还是耗电的</p><p>启用屏幕保护：cmd下输入rundll32.exe user32.dll LockWorkStation，可以启动屏幕保护功能，这样要再次使用电脑的时候要输入密码。可以在短时间离开的时候，防止别人动你电脑</p><p>显示shutdown命令语法：输入shutdown -help显示shutdown指令的用法</p><p>shutdown -a表示取消关机，或者取消重启。在shutdown -s或者shutdown -r倒计时结束之前执行shutdown -a可以取消关机或者重启操作</p>]]></content>
      
      
      <categories>
          
          <category> 牛刀小试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 黑客尝试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下删除文件的几种方法及速度比较</title>
      <link href="2021/04/22/0-ri-chang-xue-xi/linux-xia-shan-chu-wen-jian-de-ji-chong-fang-fa-ji-su-du-bi-jiao/"/>
      <url>2021/04/22/0-ri-chang-xue-xi/linux-xia-shan-chu-wen-jian-de-ji-chong-fang-fa-ji-su-du-bi-jiao/</url>
      
        <content type="html"><![CDATA[<h3 id="方法汇总："><a href="#方法汇总：" class="headerlink" title="方法汇总："></a>方法汇总：</h3><p>场景：删除/tmp下的所有文件</p><p>方法一：直接使用rm——rm -f /tmp/*</p><p>方法二：使用find 和 rm——find /tmp/ -type f  -exec rm {} \</p><p>方法三： 使用find——find /tmp/ -type f -delete</p><p>方法四：使用rsync，rsync是linux下文件同步和数据传输的命令。通过构造一个空文件夹并且和目标文件夹进行同步，就可以把目标文件夹的内容给删除了：</p><p>mkdir blankfiles<br>rsync –delete-before -d blanktest/  /tmp/</p><h3 id="速度比较："><a href="#速度比较：" class="headerlink" title="速度比较："></a>速度比较：</h3><table><thead><tr><th align="left">COMMAND</th><th align="left">TIME TAKEN</th></tr></thead><tbody><tr><td align="left">RM Command</td><td align="left">Is not capable of deleting large number of files</td></tr><tr><td align="left">Find Command with -exec</td><td align="left">14 Minutes for half a million files</td></tr><tr><td align="left">Find Command with -delete</td><td align="left">5 Minutes for half a million files</td></tr><tr><td align="left">Perl</td><td align="left">1 Minute for half a million files</td></tr><tr><td align="left">RSYNC with -delete</td><td align="left">2 Minute 56 seconds for half a million files</td></tr></tbody></table><hr><center> 详情请见大佬说明文档：<a href="https://www.slashroot.in/which-is-the-fastest-method-to-delete-files-in-linux">Which is the fastest method to delete files in Linux</a> </center><p>Creating, deleting, and modifying files is one of the common task that a user does in any operating system. This kind of task comes under a day to day list of tasks that a user does. Although it is quite fast and seamless operation when it comes to deleting a single or a handful of files in Linux or any other operating system. But if the number of files is quite large, then the deletion operation takes quite long to complete.</p><p><a href="http://www.slashroot.in/how-does-file-deletion-work-linux">What happens when you delete a file in Linux</a>, depends on the kind of file system, on which the file you want to delete resides. There are many operational differences in deleting files under different types of file system. When we talk about files in Linux, its all about inodes rather than files. How an inode gets modified, during file deletion is an important aspect to understand.</p><p>Inodes are the building blocks of Linux operating system. If you are interested in understanding inodes, i would recommend reading the below post, before going ahead, as we will not be discussing inode related details in this post.</p><p><strong>Read:</strong> <a href="http://www.slashroot.in/inode-and-its-structure-linux">What is an inode in Linux</a></p><p>I am writing this post, to find out the fastest method to delete large number of files in Linux. We will begin this tutorial with some simple file deletion methods, and then will compare the speed with which different method completed the task of file deletion. Another major reason for writing this post is the time i spend on one of our crawler servers, to delete millions of files with very small size (few KBs).</p><p>As i told, if you are dealing with small number of files, then the operation will be fast compared to a large number of files which are of very small size. Let’s begin this with some simple commands in Linux used to delete files.</p><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="Commands-to-delete-files-in-Linux-and-their-example-usage"><a href="#Commands-to-delete-files-in-Linux-and-their-example-usage" class="headerlink" title="Commands to delete files in Linux and their example usage"></a>Commands to delete files in Linux and their example usage</h2><p>To delete files in Linux, the most commonly used command is rm command. Let’s see some example’s of rm command.</p><pre class="line-numbers language-none"><code class="language-none">[root@myvm1 ~]# rm -f testfile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>-f</strong> used in the above command, will delete the file forcefully without asking for a confirmation.</p><pre class="line-numbers language-none"><code class="language-none">[root@myvm1 ~]# rm -rf testdirectory<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>The above command will delete the directory named “<strong>testdirectory</strong>“ as well as all the contents inside that directory(-r option used is to delete files recursively)</p><pre class="line-numbers language-none"><code class="language-none">[root@myvm1 ~]# rmdir testdirectory<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>The above command rmdir, will only delete the directory if its empty.</p><p>Let’s now have a look at some different methods of deleting files in Linux. One of my favorite methods out there is to use find command. Find commands is a very handy tool that can be used to search files according to its type, size, created date, modified date, and much more different criteria. To find out more about this wonderful searching tool in Linux, read the below post.</p><p><strong>Read:<a href="http://www.slashroot.in/find-command-usage-and-examples-linux"> </a></strong><a href="http://www.slashroot.in/find-command-usage-and-examples-linux">Usage examples of find command in Linux</a></p><pre class="line-numbers language-none"><code class="language-none">[root@myvm1 &#x2F;]# find &#x2F;test -type f -exec rm &#123;&#125; \;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>The above shown command, will delete all the files inside /test directory. First the find command will look for all files inside the directory, and then for each result, it will execute and rm.</p><p>Let’s see some different methods that can be used with find command, to delete files.</p><pre class="line-numbers language-none"><code class="language-none">[root@myvm1 &#x2F;]# find &#x2F;test -mtime +7 -exec rm &#123;&#125; \;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>In the above shown example, find command will search all those files inside the /test directory which are modified 7 days ago, and then delete each of them.</p><pre class="line-numbers language-none"><code class="language-none">[root@myvm1 &#x2F;]# find &#x2F;test -size +7M -exec rm &#123;&#125; \;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Above shown example, will search for all those files in the directory /test which are larger than 7M, and then delete each of them.</p><p>In all of the above shown examples of find command, rm command is invoked for each and every file in the list. For example, in the last find command shown above, if the result is 50 files which are bigger than 7M, then 50 rm commands are invoked for deleting each of them. This will take a much longer time.</p><p>Instead of using the above command of rm with the help of -exec argument in find, there is a better alternative. We will see the alternative and then calculate the difference between speed in each of them.</p><p>As i told before, the main idea behind finding the deletion speed, is when you delete large number of files. So lets first create half a million files with the help of a simple bash for loop. And after creating half a million files, we will try to delete it with rm command, find command with exec argument and then will see a better find command alternative.</p><pre class="line-numbers language-none"><code class="language-none">[root@myvm1 test]# for i in $(seq 1 500000); do echo testing &gt;&gt; $i.txt; done<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>The above command will create 5 lakh files (half a million) in the current working directory, with the name 1.txt to 500000.txt, and each file contains the text <strong>“testing”,</strong> so the file size will be at least in the range of some kilo bytes. Let’s now test the speed of deleting these number of files with different commands. First let’s use the simple rm command, and then will use find command with -exec and then delete option to calculate the time taken to delete these number of files.</p><pre class="line-numbers language-none"><code class="language-none">[root@myvm1 test]# time rm -f *-bash: &#x2F;bin&#x2F;rm: Argument list too longreal  0m11.126suser  0m9.673ssys   0m1.278s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>If you see the above rm command i ran on the test directory, containing half a million files, it gave me a message saying <strong>/bin/rm: Argument list too long</strong>. Which means the command didn’t complete the deletion, because the number of files given to rm command was too big to complete. So rm command didn’t even stand the test, because it gave up. Don’t pay attention to the time displayed by the time command, because rm command didn’t complete its operation, and time command displays the output without bothering about the end result of the command.</p><p>Now let’s use our previously seen find command with -exec argument.</p><pre class="line-numbers language-none"><code class="language-none">[root@myvm1 test]# time find .&#x2F; -type f -exec rm &#123;&#125; \;real  14m51.735suser  2m24.330ssys   9m48.743s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>From the output we got by using time command, it is clear that it took 14 minutes and 51 seconds to delete 5 lakh files from a single directory. This is quite a long time, because for each file a separate rm command is executed, until the complete list of files gets deleted.</p><p>Now lets test the time consumed, by using <strong>-delete,</strong> option in find command.</p><pre class="line-numbers language-none"><code class="language-none">[root@myvm1 test]# time find .&#x2F; -type f -deletereal  5m11.937suser  0m1.259ssys   0m28.441s[root@myvm1 test]#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Wow you saw that result!! -delete option only took 5 minutes 11 seconds. That’s a wonderful improvement in the speed, when you delete millions of files in Linux.</p><p>Let’s now have a look at how deleting files using Perl language works, and its speed compared to other options we saw earlier.</p><pre class="line-numbers language-none"><code class="language-none">[root@myvm1 test]# time perl -e &#39;for(&lt;*&gt;)&#123;((stat)[9]&lt;(unlink))&#125;&#39;real  1m0.488suser  0m7.023ssys   0m27.403s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>That’s insanely fast compared to other find command, and rm command options we saw earlier. Till now this seems to be the best method that can be used to delete all the files in a directory. That’s a remarkable achievement in speed for deleting files in Linux. If you see the output Perl only took around 1 minute to delete half a million files in that directory.</p><p>But yeah if you are interested in finding more complex options while using Perl, you need to have some good hands on with Perl regular expressions.</p><p>There is one more lesser used and less known method that can be used to delete large number of files inside a folder. This method is none other than our famous tool <strong>RSYNC</strong> used for transferring and synchronizing files between two local as well as remote locations in Linux.</p><p>Let’s have a look at that method of deleting all files inside a folder with the help of RSYNC command. The method and logic used behind deleting files with the help of rsync is based on the fact that rsync is commonly used for synchronizing files between two different locations.</p><p>This can be achieved by simply synchronizing a target directory which has the large number of files, with an empty directory. In our case <strong>test</strong> directory has half a million files, lets create a directory called as <strong>blanktest</strong>, which will be kept empty for the purpose of simply synchronization. Now along with this we will be using -delete option in rsync, which will delete all those files in the target directory, which are are not present in the source(in our case the source is an empty directory, so all the files in the destination directory will be deleted.)</p><p><strong>Empty Directory</strong>: /home/blanktest</p><p><strong>Directory to be emptied:</strong> /test</p><pre class="line-numbers language-none"><code class="language-none">[root@myvm1 home]# time rsync -a --delete blanktest&#x2F; test&#x2F;real  2m52.502suser  0m2.772ssys   0m32.649s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>The results are pretty impressive, so its much better to use rsync if you want to empty a directory containing millions of files, compared to find command.</p><p>The below shown table summarizes the speed for file deletion in Linux, using different methods in Linux.</p><table><thead><tr><th align="left">COMMAND</th><th align="left">TIME TAKEN</th></tr></thead><tbody><tr><td align="left">RM Command</td><td align="left">Is not capable of deleting large number of files</td></tr><tr><td align="left">Find Command with -exec</td><td align="left">14 Minutes for half a million files</td></tr><tr><td align="left">Find Command with -delete</td><td align="left">5 Minutes for half a million files</td></tr><tr><td align="left">Perl</td><td align="left">1 Minute for half a million files</td></tr><tr><td align="left">RSYNC with -delete</td><td align="left">2 Minute 56 seconds for half a million files</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主题美化</title>
      <link href="2021/04/21/zhu-ti-mei-hua/"/>
      <url>2021/04/21/zhu-ti-mei-hua/</url>
      
        <content type="html"><![CDATA[<center>详情请见官方文档：<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">hexo-theme-matery</a></center><h3 id="不蒜子"><a href="#不蒜子" class="headerlink" title="不蒜子"></a>不蒜子</h3><h4 id="live2d看板娘插件和busuanzi不蒜子冲突导致计数失效不显示的解决办法"><a href="#live2d看板娘插件和busuanzi不蒜子冲突导致计数失效不显示的解决办法" class="headerlink" title="live2d看板娘插件和busuanzi不蒜子冲突导致计数失效不显示的解决办法"></a>live2d看板娘插件和busuanzi不蒜子冲突导致计数失效不显示的解决办法</h4><p>首先是将不蒜子的js插件保存到本地，我的主题中位于<code>\themes\hexo-theme-matery\source\libs\others\busuanzi.pure.mini.js</code>。如果使用的是来自外网的js文件，也请下载到本地。将js文件更改为如下：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> bszCaller<span class="token punctuation">,</span>bszTag<span class="token punctuation">;</span><span class="token operator">!</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">var</span> c<span class="token punctuation">,</span>d<span class="token punctuation">,</span>e<span class="token punctuation">,</span>a<span class="token operator">=</span><span class="token operator">!</span><span class="token number">1</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function-variable function">ready</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">c</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> a<span class="token operator">||</span><span class="token string">"interactive"</span><span class="token operator">===</span>document<span class="token punctuation">.</span>readyState<span class="token operator">||</span><span class="token string">"complete"</span><span class="token operator">===</span>document<span class="token punctuation">.</span>readyState<span class="token operator">?</span><span class="token function">c</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token operator">:</span>b<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">c</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token function-variable function">d</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> a<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>c<span class="token operator">=</span>b<span class="token punctuation">.</span>length<span class="token punctuation">;</span>c<span class="token operator">></span>a<span class="token punctuation">;</span>a<span class="token operator">++</span><span class="token punctuation">)</span>b<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">;</span>b<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token function-variable function">e</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>a<span class="token operator">||</span><span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token operator">!</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token function">d</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">,</span>document<span class="token punctuation">.</span>removeEventListener<span class="token operator">?</span>document<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">"DOMContentLoaded"</span><span class="token punctuation">,</span>e<span class="token punctuation">,</span><span class="token operator">!</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">:</span>document<span class="token punctuation">.</span>attachEvent<span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">detachEvent</span><span class="token punctuation">(</span><span class="token string">"onreadystatechange"</span><span class="token punctuation">,</span>e<span class="token punctuation">)</span><span class="token punctuation">,</span>window<span class="token operator">==</span>window<span class="token punctuation">.</span>top<span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span><span class="token function">clearInterval</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span>c<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>document<span class="token punctuation">.</span>addEventListener<span class="token operator">?</span>document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"DOMContentLoaded"</span><span class="token punctuation">,</span>e<span class="token punctuation">,</span><span class="token operator">!</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">:</span>document<span class="token punctuation">.</span>attachEvent<span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">attachEvent</span><span class="token punctuation">(</span><span class="token string">"onreadystatechange"</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">loaded|complete</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>readyState<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token function">e</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>window<span class="token operator">==</span>window<span class="token punctuation">.</span>top<span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>c<span class="token operator">=</span><span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">try</span><span class="token punctuation">&#123;</span>a<span class="token operator">||</span>document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span><span class="token function">doScroll</span><span class="token punctuation">(</span><span class="token string">"left"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token function">e</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>bszCaller<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token function-variable function">fetch</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">var</span> c<span class="token operator">=</span><span class="token string">"BusuanziCallback_"</span><span class="token operator">+</span>Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token number">1099511627776</span><span class="token operator">*</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>window<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">evalCall</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span>a<span class="token operator">=</span>a<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"=BusuanziCallback"</span><span class="token punctuation">,</span><span class="token string">"="</span><span class="token operator">+</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span>scriptTag<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"SCRIPT"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>scriptTag<span class="token punctuation">.</span>type<span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token punctuation">,</span>scriptTag<span class="token punctuation">.</span>defer<span class="token operator">=</span><span class="token operator">!</span><span class="token number">0</span><span class="token punctuation">,</span>scriptTag<span class="token punctuation">.</span>src<span class="token operator">=</span>a<span class="token punctuation">,</span>document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">"HEAD"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>scriptTag<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token function-variable function">evalCall</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">b</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">ready</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">try</span><span class="token punctuation">&#123;</span><span class="token function">a</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span>scriptTag<span class="token punctuation">.</span>parentElement<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>scriptTag<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>bszTag<span class="token punctuation">.</span><span class="token function">hides</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>bszCaller<span class="token punctuation">.</span><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">"//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback"</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>bszTag<span class="token punctuation">.</span><span class="token function">texts</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span>bszTag<span class="token punctuation">.</span><span class="token function">shows</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>bszTag<span class="token operator">=</span><span class="token punctuation">&#123;</span>bszs<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">"site_pv"</span><span class="token punctuation">,</span><span class="token string">"page_pv"</span><span class="token punctuation">,</span><span class="token string">"site_uv"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token function-variable function">texts</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>bszs<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">b</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">var</span> c<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"busuanzi_value_"</span><span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>c<span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>innerHTML<span class="token operator">=</span>a<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token function-variable function">hides</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>bszs<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">var</span> b<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"busuanzi_container_"</span><span class="token operator">+</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>b<span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>style<span class="token punctuation">.</span>display<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token function-variable function">shows</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>bszs<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">var</span> b<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"busuanzi_container_"</span><span class="token operator">+</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>b<span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>style<span class="token punctuation">.</span>display<span class="token operator">=</span><span class="token string">"inline"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>操作其实就是把其中的<code>b.style.display=&quot;none&quot;</code>中<code>none</code>去掉。</p><h4 id="busuanzi不蒜子链接地址更新"><a href="#busuanzi不蒜子链接地址更新" class="headerlink" title="busuanzi不蒜子链接地址更新"></a>busuanzi不蒜子链接地址更新</h4><center>详情请见官方文档：<a href="http://busuanzi.ibruce.info/">busuanzi</a></center><center>详细代码请见：<a href="http://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">busuanzi.pure.mini.js</a></center><center>使用方法请见：<a href="http://ibruce.info/2015/04/04/busuanzi/">不蒜子使用方法</a></center><h4 id="不蒜子简介"><a href="#不蒜子简介" class="headerlink" title="不蒜子简介"></a>不蒜子简介</h4><blockquote><p>评论有 “多说”，计数有 “不蒜”！ （虽然多说已经没了）</p></blockquote><p>静态网站建站现在有很多快速的技术和平台，静态的缺点是，一些动态的内容如评论、计数等等模块就需要借助外来平台。不蒜子就是一款优秀的极简计数模块。</p><p><strong>不蒜子</strong> 与百度统计谷歌分析等有区别：不蒜子可直接将访问次数显示在您在网页上（也可不显示）；对于已经上线一段时间的网站，不蒜子允许您初始化首次数据。</p><h4 id="不蒜子的使用方法"><a href="#不蒜子的使用方法" class="headerlink" title="不蒜子的使用方法"></a>不蒜子的使用方法</h4><h5 id="设置站点的访问量统计"><a href="#设置站点的访问量统计" class="headerlink" title="设置站点的访问量统计"></a>设置站点的访问量统计</h5><p>站点的访问量有两种算法可选：</p><p>算法a：pv 的方式，单个用户连续点击 n 篇文章，记录 n 次访问量。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>span id<span class="token operator">=</span><span class="token string">"busuanzi\_container\_site\_pv"</span><span class="token operator">></span>     本站总访问量<span class="token operator">&lt;</span>span id<span class="token operator">=</span><span class="token string">"busuanzi\_value\_site\_pv"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span>次 <span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>算法b：uv 的方式，单个用户连续点击 n 篇文章，只记录 1 次访客数。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>span id<span class="token operator">=</span><span class="token string">"busuanzi\_container\_site\_uv"</span><span class="token operator">></span>     本站访客数<span class="token operator">&lt;</span>span id<span class="token operator">=</span><span class="token string">"busuanzi\_value\_site\_uv"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span>人次 <span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>代码中文字是可以修改的，只要保留id正确即可。</p></blockquote><h5 id="设置文章的访问量统计"><a href="#设置文章的访问量统计" class="headerlink" title="设置文章的访问量统计"></a>设置文章的访问量统计</h5><p>要显示每篇文章的访问量，复制以下代码添加到你需要显示的位置。</p><p>仅有一种算法：pv 的方式，单个用户点击 1 篇文章，本篇文章记录 1 次阅读量。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>span id<span class="token operator">=</span><span class="token string">"busuanzi_container_page_pv"</span><span class="token operator">></span>      本文总阅读量<span class="token operator">&lt;</span>span id<span class="token operator">=</span><span class="token string">"busuanzi_value_page_pv"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span>次 <span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>busuanzi_value_site_pv</strong> 的作用是异步回填访问数，这个id一定要正确。</li><li><strong>busuanzi_container_site_pv</strong>的作用是为防止计数服务访问出错或超时（3秒）的情况下，使整个标签自动隐藏显示，带来更好的体验。这个id可以省略。</li></ul><h5 id="无数据则隐藏"><a href="#无数据则隐藏" class="headerlink" title="无数据则隐藏"></a>无数据则隐藏</h5><p>在访问量数据未取回来之前，我不想让页面显示为诸如“本站总访问量 次”，显得太low，怎么办？ 只需要如下css，不蒜子执行完毕会自动将标签显示出来，其他以此类推：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>span id<span class="token operator">=</span><span class="token string">"busuanzi_container_site_pv"</span> style<span class="token operator">=</span><span class="token string">'display:none'</span><span class="token operator">></span>     本站总访问量<span class="token operator">&lt;</span>span id<span class="token operator">=</span><span class="token string">"busuanzi_value_site_pv"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span>次<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="待完成事项"><a href="#待完成事项" class="headerlink" title="待完成事项"></a>待完成事项</h3><ul><li>待增添留言板功能</li></ul><blockquote><p><strong>注</strong>：本留言板功能依赖于第三方评论系统，请<strong>激活</strong>你的评论系统才有效果。并且在主题的 <code>_config.yml</code> 文件中，第 <code>19</code> 至 <code>21</code> 行的“<strong>菜单</strong>”配置，取消关于留言板的注释即可。</p></blockquote><ul><li>更改头像</li></ul><ul><li>修改关于页面</li></ul><ul><li>待添加域名和备案</li></ul>]]></content>
      
      
      <categories>
          
          <category> 个人博客设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac怎样查看隐藏文件</title>
      <link href="2021/04/21/0-yi-nan-za-zheng/mac-zen-yang-cha-kan-yin-cang-wen-jian/"/>
      <url>2021/04/21/0-yi-nan-za-zheng/mac-zen-yang-cha-kan-yin-cang-wen-jian/</url>
      
        <content type="html"><![CDATA[<p>现代人的隐私保护意识越来越强。而电脑做为日常生活和工作资料的储存箱，会存放很多涉及个人隐私的内容。所以有人喜欢在Mac上隐藏文件和文件夹，来保护自己的个人隐私。</p><p>但是隐藏之后，有些用户却不知道如何让隐藏文件再显示出来，今天就来教大家如何在Mac上显示隐藏文件的几种办法。</p><p>在我们说明办法之前，先普及一下隐藏文件的一些知识。</p><h2 id="什么是隐藏文件以及它们在Mac上的位置？"><a href="#什么是隐藏文件以及它们在Mac上的位置？" class="headerlink" title="什么是隐藏文件以及它们在Mac上的位置？"></a>什么是隐藏文件以及它们在Mac上的位置？</h2><p>其实在我们的电脑中，默认情况下就会有很多隐藏文件和文件夹。这样用户在使用的过程中就不会意外的将其删除或者修改他们。</p><p>因为这些默认隐藏的文件和文件夹都是一些支撑Mac运行的重要文件，总之是很重要的东西。</p><p>在Mac中，隐藏文件不会显示在正常的文件和文件夹列表中。它们以“.”命名。在他们的名字之前隐藏文件可以是任何类型，例如，它可以是.bash_profile，.htaccess文件或.svn目录。如果希望，还可以隐藏/ bin，/ usr和/ etc等文件夹。大多数隐藏的文件都存在于Library文件夹（〜/ Library）中。</p><h2 id="如何在Mac上显示隐藏文件？"><a href="#如何在Mac上显示隐藏文件？" class="headerlink" title="如何在Mac上显示隐藏文件？"></a>如何在Mac上显示隐藏文件？</h2><p>现在您已经了解了隐藏文件和文件夹的基本知识，那么隐藏文件和文件夹要怎么重新显示出来呢？</p><h3 id="方法1：使用Finder查看Mac隐藏文件"><a href="#方法1：使用Finder查看Mac隐藏文件" class="headerlink" title="方法1：使用Finder查看Mac隐藏文件"></a>方法1：使用Finder查看Mac隐藏文件</h3><p>在最新的macOS Sierra中，Apple包含了Finder快捷键。这允许用户快速显示隐藏的文件夹Mac。</p><p>操作步骤如下：</p><ul><li><p>打开Finder，然后点击主文件夹。您可以访问左栏中“设备”下的主文件夹。</p></li><li><p>按键盘键Cmd + Shift +。 （点）。只要按下此组合键，就会看到所有隐藏的文件夹和文件。</p><p><img src="/2021/04/21/0-yi-nan-za-zheng/mac-zen-yang-cha-kan-yin-cang-wen-jian/finder.jpg"></p></li><li><p>如果您需要再次隐藏这些文件，您只需再次按下该组合即可。</p></li></ul><h3 id="方法2：直接在库中查找隐藏文件夹"><a href="#方法2：直接在库中查找隐藏文件夹" class="headerlink" title="方法2：直接在库中查找隐藏文件夹"></a>方法2：直接在库中查找隐藏文件夹</h3><p>还有一种办法是直接在〜/ Library文件夹中进行查找</p><ul><li><p>首先打开Finder。按Alt（选项）键。现在，从按下键后丢弃的菜单栏中选择Go。</p></li><li><p>您现在可以使用Home文件夹下面的〜/ Library文件夹。</p></li><li><p>您也可以转到Finder &gt;&gt; Go查看该文件夹。现在选择“转到文件夹”选项或只需按Shift + Cmd + G组合键。现在输入〜/ Library并点击Go。</p><p><img src="/2021/04/21/0-yi-nan-za-zheng/mac-zen-yang-cha-kan-yin-cang-wen-jian/library.jpg"></p></li></ul><p>这将显示所有隐藏的文件和文件夹。此外，它还将授予您访问这些文件夹的权限。</p><h3 id="方法3：使用命令查找隐藏文件和文件夹"><a href="#方法3：使用命令查找隐藏文件和文件夹" class="headerlink" title="方法3：使用命令查找隐藏文件和文件夹"></a>方法3：使用命令查找隐藏文件和文件夹</h3><p>如果你还想尝试一些更极客的办法，那么你可以使用命令查找</p><p>如果你是一个极客并且非常清楚使用终端，那么这个解决方案可能会激发你的兴趣。您所要做的就是按照以下步骤进行操作。</p><ul><li><p>首先要打开终端。</p></li><li><p>在终端中，运行以下提到的脚本：</p></li><li><p>$ defaults写com.apple.Finder AppleShowAllFiles true $ killall Finder您的隐藏文件夹将可见。</p></li><li><p>如果要隐藏起来，只需要运行相同的脚本，将“true”值更改为“false”</p><p><img src="/2021/04/21/0-yi-nan-za-zheng/mac-zen-yang-cha-kan-yin-cang-wen-jian/terminal.jpg"></p></li><li><p>如前所述，默认情况下会隐藏某些文件夹和文件。这是为了避免用户可能错误地对它们执行的修改。修改这些文件会损坏您的Mac系统，并且是不可逆的。</p></li><li><p>由于该过程不可逆转，所以在操作时需谨慎处理。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 疑难杂症 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac电脑使用技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建</title>
      <link href="2021/04/21/0-ge-ren-bo-ke-she-ji/bo-ke-da-jian/"/>
      <url>2021/04/21/0-ge-ren-bo-ke-she-ji/bo-ke-da-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><h4 id="GitHub-pages设置"><a href="#GitHub-pages设置" class="headerlink" title="GitHub pages设置"></a>GitHub pages设置</h4><ol><li>注册GitHub账号</li><li>打开<a href="https://github.com/%EF%BC%8C%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%EF%BC%9A">https://github.com/，新建一个项目：</a></li></ol><p><img src="/2021/04/21/0-ge-ren-bo-ke-she-ji/bo-ke-da-jian/1.jpg"></p><p>然后如下图所示，输入自己的项目名字，后面一定要加<code>.github.io</code>后缀，README初始化也要勾上</p><p><strong>名称一定要和你的github名字完全一样，比如你github名字叫<code>abc</code>，那么仓库名字一定要是<code>abc.github.io</code></strong></p><p><img src="/2021/04/21/0-ge-ren-bo-ke-she-ji/bo-ke-da-jian/2.jpg"></p><p>然后项目就建成了，点击<code>Settings</code>，向下拉到最后有个<code>GitHub Pages</code>，点击<code>Choose a theme</code>选择一个主题。然后等一会儿，再回到<code>GitHub Pages</code>，会变成下面这样：</p><p><img src="/2021/04/21/0-ge-ren-bo-ke-she-ji/bo-ke-da-jian/3.jpg"></p><p>浏览器输入链接”yourname.github.io”，就会出现自己的网页啦，效果如下：</p><p><img src="/2021/04/21/0-ge-ren-bo-ke-she-ji/bo-ke-da-jian/4.jpg"></p><h4 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h4><ol><li><p>去官网下载最新稳定版<a href="https://nodejs.org/en/">Node.js</a></p></li><li><p>安装选项全部默认，一路点击<code>Next</code></p></li><li><p>最后安装好之后，按<code>Win+R</code>打开命令提示符，输入<code>node -v</code>和<code>npm -v</code>，如果出现版本号，那么就安装成功了</p></li></ol><h4 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h4><ol><li><p>为了把本地的网页文件上传到github上面去，我们需要用到分布式版本控制工具————Git[<a href="https://git-scm.com/download/win">下载地址]</a></p></li><li><p>安装选项还是全部默认，只不过最后一步添加路径时选择<code>Use Git from the Windows Command Prompt</code>，这样我们就可以直接在命令提示符里打开git了</p></li><li><p>安装完成后在命令提示符中输入<code>git --version</code>验证是否安装成功</p></li></ol><h2 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h2><h4 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h4><ol><li><p>在合适的地方新建一个文件夹，用来存放自己的博客文件，比如存放在<code>D:\blog</code>目录下</p></li><li><p>在该目录下右键点击<code>Git Bash Here</code>，打开git的控制台窗口（以后我们所有的操作都在git控制台进行，就不要用Windows自带的控制台了）</p></li><li><p>定位到该目录下，输入<code>npm i hexo-cli -g</code>安装Hexo（会有几个报错，无视它就行）</p></li><li><p>安装完后输入<code>hexo -v</code>验证是否安装成功</p></li><li><p>然后就要初始化我们的网站，输入<code>hexo init</code>初始化文件夹，接着输入<code>npm install</code>安装必备的组件</p></li><li><p>这样本地的网站配置也弄好啦，输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>打开本地服务器，然后浏览器打开<a href="http://localhost:4000/%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E6%88%91%E4%BB%AC%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%95%A6%EF%BC%8C%E6%95%88%E6%9E%9C%E5%A6%82%E4%B8%8B%EF%BC%9A%EF%BC%88%E6%8C%89%60ctrl+c%60%E5%85%B3%E9%97%AD%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89">http://localhost:4000/，就可以看到我们的博客啦，效果如下：（按`ctrl+c`关闭本地服务器）</a></p></li></ol><p><img src="/2021/04/21/0-ge-ren-bo-ke-she-ji/bo-ke-da-jian/5.jpg"></p><h4 id="连接GitHub与本地"><a href="#连接GitHub与本地" class="headerlink" title="连接GitHub与本地"></a>连接GitHub与本地</h4><ol><li>首先右键打开git bash，然后输入下面命令：（用户名和邮箱根据你注册github的信息自行修改）</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config --global user.name <span class="token string">"yourname"</span><span class="token function">git</span> config --global user.email <span class="token string">"youremail"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li>然后生成密钥SSH key：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen -t rsa -C <span class="token string">"youremail"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>打开<a href="http://github.com/">github</a>，在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个SSH，名字随便</li></ol><blockquote><p>git bash中输入</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> ~/.ssh/id_rsa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>将输出的内容复制到框中，点击确定保存。</p></blockquote><ol start="4"><li>输入<code>ssh -T git@github.com</code>，如果如下图所示，出现你的用户名，那就成功了！</li></ol><p><img src="/2021/04/21/0-ge-ren-bo-ke-she-ji/bo-ke-da-jian/6.jpg"></p><p>备注：打开博客根目录下的<code>_config.yml</code>文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息：</p><blockquote><p>修改最后一行的配置：</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">deploy:  type: <span class="token function">git</span>  repository: https://github.com/godweiyang/godweiyang.github.io  branch: main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>repository修改为你自己的github项目地址</p></blockquote><h4 id="写文章、发布文章"><a href="#写文章、发布文章" class="headerlink" title="写文章、发布文章"></a>写文章、发布文章</h4><ol><li><p>首先在博客根目录下右键打开git bash，安装一个扩展<code>npm i hexo-deployer-git</code></p></li><li><p>然后输入<code>hexo new &quot;article title&quot;</code>，新建一篇文章</p></li><li><p>然后打开<code>D:\blog\source\_posts</code>的目录，可以发现下面多了一个<code>.md</code>文件，就是你的文章文件啦</p></li><li><p>编写完markdown文件后，根目录下输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>可以本地预览效果，最后输入<code>hexo d</code>上传到github上，这时打开你的github.io主页就能看到发布的文章啦！</p></li></ol><h4 id="绑定个人域名"><a href="#绑定个人域名" class="headerlink" title="绑定个人域名"></a>绑定个人域名</h4><p>现在默认的域名还是<code>xxx.github.io</code>，是不是很没有牌面？</p><p>想不想也像我一样弄一个专属域名呢，首先你得购买一个域名，xx云都能买，看你个人喜好了</p><blockquote><p>以我的百度云为例，如下图所示，添加两条解析记录：</p></blockquote><p><img src="/2021/04/21/0-ge-ren-bo-ke-she-ji/bo-ke-da-jian/7.jpg"></p><blockquote><p>然后打开你的github博客项目，点击<code>settings</code>，拉到下面<code>Custom domain</code>处，填上你自己的域名，保存：</p></blockquote><p><img src="/2021/04/21/0-ge-ren-bo-ke-she-ji/bo-ke-da-jian/8.jpg"></p><blockquote><p>这时候你的项目根目录应该会出现一个名为<code>CNAME</code>的文件了。如果没有的话，打开你本地博客<code>/source</code>目录，我的是<code>D:\blog\source</code>，新建<code>CNAME</code>文件，注意没有后缀。然后在里面写上你的域名，保存</p><p>最后运行<code>hexo g</code>、<code>hexo d</code>上传到github</p></blockquote><h4 id="备份博客源文件"><a href="#备份博客源文件" class="headerlink" title="备份博客源文件"></a>备份博客源文件</h4><p>有时候我们想换一台电脑继续写博客，这时候就可以将博客目录下的所有源文件都上传到github上面</p><blockquote><p>首先在github博客仓库下新建一个分支<code>hexo</code>，然后<code>git clone</code>到本地，把<code>.git</code>文件夹拿出来，放在博客根目录下</p></blockquote><blockquote><p>然后<code>git checkout hexo</code>切换到<code>hexo</code>分支，然后<code>git add .</code>，然后<code>git commit -m &quot;xxx&quot;</code>，最后<code>git push origin hexo</code>提交就行了</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 个人博客设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文章初始化设置</title>
      <link href="2021/04/20/wen-zhang-chu-shi-hua-she-zhi/"/>
      <url>2021/04/20/wen-zhang-chu-shi-hua-she-zhi/</url>
      
        <content type="html"><![CDATA[<h3 id="初始化文章的Front-matter"><a href="#初始化文章的Front-matter" class="headerlink" title="初始化文章的Front-matter"></a>初始化文章的<code>Front-matter</code></h3><p>修改”/scaffolds/post.md”</p><center>初始状态</center><pre class="line-numbers language-none"><code class="language-none">title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><center>修改后的状态</center><pre class="line-numbers language-none"><code class="language-none">title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;top: true#推荐文章（文章是否置顶）如果 top 值为 true，则会作为首页推荐文章;不置顶则将该行删除cover: flase#版本新增，表示该文章是否需要加入到首页轮播封面中;默认关闭，不需要的话删除该行，需要的话将flase改成truesummary: this is the summary #文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要keywords: this is the keywords #文章关键字，SEO 时需要;默认为文章标题tags:- new#标签项，此项待修改categories: new#分类项，此项待修改<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>备注：author项已在根_config.yml中修改</p><h3 id="引用图片"><a href="#引用图片" class="headerlink" title="引用图片"></a>引用图片</h3><p>使用 markdown 语法插入相对路径的图片，可以利用插件。设置 <code>post_asset_folder:true</code> 后，在根目录下执行：</p><pre class="line-numbers language-none"><code class="language-none">npm install https:&#x2F;&#x2F;github.com&#x2F;CodeFalling&#x2F;hexo-asset-image --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>确保在 source/_posts 下创建和 markdown 文件同名的目录，里面存放需要的图片，然后在 markdown 中插入图片：</p><pre class="line-numbers language-none"><code class="language-none">_posts    |- hexo.md    |_ hexo        |_ image.png<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">! [] (hexo&#x2F;image.png)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成的页面中图片引用路径</p><pre class="line-numbers language-none"><code class="language-none">&lt;img src&#x3D;&quot;&#x2F;2016&#x2F;11&#x2F;25&#x2F;hexo&#x2F;image.png&quot; alt&#x3D;&quot;hexo image&quot;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>至此，用 markdown 完美实现本地图片插入</p>]]></content>
      
      
      <categories>
          
          <category> 个人博客设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超链接居中</title>
      <link href="2021/04/20/0-ri-chang-xue-xi/chao-lian-jie-ju-zhong/"/>
      <url>2021/04/20/0-ri-chang-xue-xi/chao-lian-jie-ju-zhong/</url>
      
        <content type="html"><![CDATA[<p>*markdown本身不支持，但可以使用html：</p><ol><li>方法一：</li></ol><pre class="line-numbers language-none"><code class="language-none">&lt;center&gt;[链接名称](链接地址)&lt;&#x2F;center&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>示例：</p></blockquote><center>[链接名称](链接地址)</center><ol start="2"><li>方法二：</li></ol><pre class="line-numbers language-none"><code class="language-none">&lt;center&gt;&lt;a href&#x3D;链接地址&gt;链接名称&lt;&#x2F;a&gt;&lt;&#x2F;center&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>示例：</p></blockquote><center><a href="链接地址">链接名称</a></center><ol start="3"><li>方法三：</li></ol><pre class="line-numbers language-none"><code class="language-none">&lt;div align&#x3D;center &gt;&lt;a href&#x3D;链接地址&gt;链接名称&lt;&#x2F;a&gt;&lt;&#x2F;div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>示例：</p></blockquote><div align="center"><a href="链接地址">链接名称</a></div><p>备注：方法一当有回车符时可能会失效</p>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown编写技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文章Front-matter介绍</title>
      <link href="2021/04/20/0-ge-ren-bo-ke-she-ji/wen-zhang-front-matter-jie-shao/"/>
      <url>2021/04/20/0-ge-ren-bo-ke-she-ji/wen-zhang-front-matter-jie-shao/</url>
      
        <content type="html"><![CDATA[<center> 详情请见官方说明文档：<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">hexo-theme-matery</a> </center><hr><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><blockquote><p><strong>注意</strong>:</p><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章的特色图<strong>各有特色</strong>。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="http://tool.oschina.net/encrypt?type=2">开源中国在线工具</a>、<a href="http://encode.chahuo.com/">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx">站长工具</a>。</li><li>您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则</li></ol></blockquote><p>以下为文章的 <code>Front-matter</code> 示例。</p><h3 id="最简示例"><a href="#最简示例" class="headerlink" title="最简示例"></a>最简示例</h3><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="最全示例"><a href="#最全示例" class="headerlink" title="最全示例"></a>最全示例</h3><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;top: true#推荐文章（文章是否置顶）如果 top 值为 true，则会作为首页推荐文章;不置顶则将该行删除cover: flase#版本新增，表示该文章是否需要加入到首页轮播封面中;默认关闭，不需要的话删除该行，需要的话将flase改成truesummary: this is the summary #文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要tags:<span class="token list punctuation">-</span> new#标签项，此项待修改categories: new#分类项，此项待修改<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 个人博客设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编写和发布新文章</title>
      <link href="2021/04/20/bian-xie-he-fa-bu-xin-wen-zhang/"/>
      <url>2021/04/20/bian-xie-he-fa-bu-xin-wen-zhang/</url>
      
        <content type="html"><![CDATA[<h3 id="新建文章的方法"><a href="#新建文章的方法" class="headerlink" title="新建文章的方法"></a>新建文章的方法</h3><h5 id="方法一：进入博客目录，在-source-posts-文件夹下直接建立一个-md文件"><a href="#方法一：进入博客目录，在-source-posts-文件夹下直接建立一个-md文件" class="headerlink" title="方法一：进入博客目录，在 /source/_posts 文件夹下直接建立一个.md文件"></a>方法一：进入博客目录，在 /source/_posts 文件夹下直接建立一个.md文件</h5><h5 id="方法二：进入博客目录，右键选择-“-Git-Bash-Here-“-进入命令窗口，输入下面代码"><a href="#方法二：进入博客目录，右键选择-“-Git-Bash-Here-“-进入命令窗口，输入下面代码" class="headerlink" title="方法二：进入博客目录，右键选择 “ Git Bash Here “ 进入命令窗口，输入下面代码:"></a>方法二：进入博客目录，右键选择 “ Git Bash Here “ 进入命令窗口，输入下面代码:</h5><pre class="line-numbers language-none"><code class="language-none">hexo new &quot;新建文章名称&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时，在” /source/_posts”文件夹里便有了”新建文章名称.md”文件。</p><h3 id="发布新建文章"><a href="#发布新建文章" class="headerlink" title="发布新建文章"></a>发布新建文章</h3><p>在该博客项目文件夹下右键选择 “ Git Bash Here “ 进入命令窗口，输入如下代码：</p><pre class="line-numbers language-none"><code class="language-none">hexo g -d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意事项：</p><ul><li><p>部署到GitHub时，可能因为网速、被墙等原因，需要多次运行”hexo deploy”；也可以运行”hexo clean”后在运行上述代码</p></li><li><p>.md文件不要用记事本打开，建议使用具有markdown语法的程序打开</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 个人博客设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主题修改</title>
      <link href="2021/04/20/0-ge-ren-bo-ke-she-ji/zhu-ti-xiu-gai/"/>
      <url>2021/04/20/0-ge-ren-bo-ke-she-ji/zhu-ti-xiu-gai/</url>
      
        <content type="html"><![CDATA[<h3 id="挑个好看的主题"><a href="#挑个好看的主题" class="headerlink" title="挑个好看的主题"></a>挑个好看的主题</h3><p>全凭个人喜好，在网上能找到很多好看的主题供你下载</p><p>知乎话题：<a href="https://www.zhihu.com/question/24422335">有哪些好看的 Hexo 主题？</a></p><p>Hexo官方：<a href="https://hexo.io/themes/">Themes</a></p><h3 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h3><p>用git bash，进入到博客的本地目录中：</p><pre class="line-numbers language-none"><code class="language-none">$ cd 你的博客目录路径<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2021/04/20/0-ge-ren-bo-ke-she-ji/zhu-ti-xiu-gai/1460000012780333"></p><p>然后使用clone的方法将想要的主题下载下来：（这里选用的是NexT主题）</p><pre class="line-numbers language-none"><code class="language-none">$ git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="修改配置文件，安装"><a href="#修改配置文件，安装" class="headerlink" title="修改配置文件，安装"></a>修改配置文件，安装</h3><p>git克隆完成后，打开当前目录下的“_config.yml”配置文件</p><p>找到theme的配置选项，一般在文件的最后</p><p>之后，将theme选项配置为我们新下载好的next主题即可（“：”冒号之后空格不可少）</p><p><img src="/2021/04/20/0-ge-ren-bo-ke-she-ji/zhu-ti-xiu-gai/1460000012780334"></p><h3 id="调试，发布"><a href="#调试，发布" class="headerlink" title="调试，发布"></a>调试，发布</h3><p>回到git bash，输入调试命令：</p><pre class="line-numbers language-none"><code class="language-none">$ hexo server --debug<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如图，在浏览器中输入localhost:4000查看：</p><p><img src="/2021/04/20/0-ge-ren-bo-ke-she-ji/zhu-ti-xiu-gai/1460000012780335"></p><p>在本地查看无误之后，输入生成和发布命令,就可已将新主题发布到自己的博客网站上了</p><pre class="line-numbers language-none"><code class="language-none">$ hexo g -d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>*如出现缓存引起的异常，可以在生成命令前执行清除缓存命令：</p><pre class="line-numbers language-none"><code class="language-none">$ hexo clean<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h3><p>做完这些之后，就可以打开你的博客网站，查看新更换的主题效果！</p>]]></content>
      
      
      <categories>
          
          <category> 个人博客设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题修改 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
