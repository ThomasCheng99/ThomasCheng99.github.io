<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JNI层学习</title>
      <link href="2021/05/21/jni-ceng-xue-xi/"/>
      <url>2021/05/21/jni-ceng-xue-xi/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> new </category>
          
      </categories>
      
      
        <tags>
            
            <tag> new </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HAL层学习</title>
      <link href="2021/05/21/hal-ceng-xue-xi/"/>
      <url>2021/05/21/hal-ceng-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="Android-HAL-简介"><a href="#Android-HAL-简介" class="headerlink" title="Android HAL 简介"></a>Android HAL 简介</h1><p>Android 系统硬件抽象层（Hardware Abstract Layer）运行在用户空间中，它向下屏蔽了硬件驱动的实现细节，向上提供了硬件访问的服务。通过 HAL 层，Android 系统分为两层来支持硬件设备，其中一层实现在用户空间，另外一层实现在内核空间中，它在 Android 系统框架中的位置如下图所示。传统的 Linux 系统则把对硬件的支持和管理全部放在内核空间中,即把对硬件的全部支持都放在硬件驱动模块当中。</p><p><img src="/2021/05/21/hal-ceng-xue-xi/1.png"></p><h1 id="为什么要添加一个-HAL-层？"><a href="#为什么要添加一个-HAL-层？" class="headerlink" title="为什么要添加一个 HAL 层？"></a>为什么要添加一个 HAL 层？</h1><p>Android 在用户空间中新建一个的 HAL 层来支持硬件设备的主要原因还是因为 Android 使用的开源协议是 Apache License，这个协议比较宽松，它允许开发者获取并修改了源码之后，不用把源码公开出来。而 Linux 使用的开源协议 GPL，它的要求限制就比较多，它要求开发者添加或修改了源码之后，必须把添加或修改后的代码公开出来，所以我们在 Linux 内核中的所使用的设备驱动程序都是源码公开的，任何人都可以获取并修改它。</p><p>因此，如果 Android 系统像其他 Linux 系统一样，把对硬件的支持完全实现在 Linux 内核的驱动模块中，那么硬件厂商就必须将这些硬件驱动源码公开，这样就可能损害到移动厂商的利益，因为这相当于暴露了硬件的实现细节和参数。</p><p>所以，Android 就在用户空间搞了一个 HAL 层，将硬件的一些重要的操作都放在这一层中完成，这些操作都封装在厂商所提供的一个动态链接库中，从而达到了避免源码公开的目的，而底层 Linux 内核空间中的设备驱动模块，现在则只提供一些最基本的硬件设备寄存器操作的功能。</p><p>也正是由于这个分层的原因，Android被踢出了Linux内核主线代码树中。大家想想，Android放在内核空间的驱动程序对硬件的支持是不完整的，把Linux内核移植到别的机器上去时，由于缺乏硬件抽象层的支持，硬件就完全不能用了，这也是为什么说Android是开放系统而不是开源系统的原因。</p><h1 id="HAL-模块是如何实现的？"><a href="#HAL-模块是如何实现的？" class="headerlink" title="HAL 模块是如何实现的？"></a>HAL 模块是如何实现的？</h1><p>以音频系统对应的 audio HAL 模块（ 它最终是以 <code>audio.primary.x86.so</code> 的动态链接库形式存在 ）为例来介绍一个 HAL 模块的定义及实现过程。</p><h2 id="HAL-层的三个重要结构体"><a href="#HAL-层的三个重要结构体" class="headerlink" title="HAL 层的三个重要结构体"></a>HAL 层的三个重要结构体</h2><p>Android 系统的 HAL 层其实并不复杂，只要你能理解清楚下面这 3 个结构体的含义：</p><blockquote><ul><li><strong>hw_module_t</strong>：用来描述硬件模块</li><li><strong>hw_device_t</strong>：用来描述硬件设备</li><li><strong>hw_module_methods_t</strong>：用来打开硬件模块中包含硬件设备，获得指向硬件设备结构体的指针</li></ul></blockquote><p>Android 系统中 HAL 层是以<strong>模块</strong>的方式来管理各个硬件访问的接口，每一个硬件模块都对应一个动态链接库文件，而这些动态链接库文件需要符号一定的规范，而上述的这 3 种结构体就是用来建立这种规范。并且一个<strong>硬件模块</strong>可以管理多个<strong>硬件设备</strong>，例如 audio HAL 硬件模块中就管理了扬声器、麦克风等多个硬件设备。</p><p><strong>注意：这里一定区分 hw_module_t 和 hw_device_t 它们所表示的含义</strong></p><h3 id="hw-module-t"><a href="#hw-module-t" class="headerlink" title="hw_module_t"></a>hw_module_t</h3><p>结构体 hw_module_t 定义在 <code>/hardware/libhardware/include/hardware/hardware.h</code> 文件中，其定义如下所示：</p><pre class="line-numbers language-none"><code class="language-none">1. *&#x2F;***2. ** Every hardware module must have a data structure named HAL_MODULE_INFO_SYM*3. ** and the fields of this data structure must begin with hw_module_t*4. ** followed by module specific information.*5. **&#x2F;*6. typedef struct hw_module_t &#123;7. *&#x2F;** tag must be initialized to HARDWARE_MODULE_TAG \*&#x2F;*8. uint32_t tag;9. 10. *&#x2F;***11. ** The API version of the implemented module. The module owner is*12. ** responsible for updating the version when a module interface has*13. ** changed.*14. ***15. ** The derived modules such as gralloc and audio own and manage this field.*16. ** The module user must interpret the version field to decide whether or*17. ** not to inter-operate with the supplied module implementation.*18. ** For example, SurfaceFlinger is responsible for making sure that*19. ** it knows how to manage different versions of the gralloc-module API,*20. ** and AudioFlinger must know how to do the same for audio-module API.*21. ***22. ** The module API version should include a major and a minor component.*23. ** For example, version 1.0 could be represented as 0x0100. This format*24. ** implies that versions 0x0100-0x01ff are all API-compatible.*25. ***26. ** In the future, libhardware will expose a hw_get_module_version()*27. ** (or equivalent) function that will take minimum&#x2F;maximum supported*28. ** versions as arguments and would be able to reject modules with*29. ** versions outside of the supplied range.*30. **&#x2F;*31. uint16_t module_api_version;32. \#define version_major module_api_version33. *&#x2F;***34. ** version_major&#x2F;version_minor defines are supplied here for temporary*35. ** source code compatibility. They will be removed in the next version.*36. ** ALL clients must convert to the new version format.*37. **&#x2F;*38. 39. *&#x2F;***40. ** The API version of the HAL module interface. This is meant to*41. ** version the hw_module_t, hw_module_methods_t, and hw_device_t*42. ** structures and definitions.*43. ***44. ** The HAL interface owns this field. Module users&#x2F;implementations*45. ** must NOT rely on this value for version information.*46. ***47. ** Presently, 0 is the only valid value.*48. **&#x2F;*49. uint16_t hal_api_version;50. \#define version_minor hal_api_version51. 52. *&#x2F;** Identifier of module \*&#x2F;*53. const char *id;54. 55. *&#x2F;** Name of this module \*&#x2F;*56. const char *name;57. 58. *&#x2F;** Author&#x2F;owner&#x2F;implementor of the module \*&#x2F;*59. const char *author;60. 61. *&#x2F;** Modules methods \*&#x2F;*62. struct hw_module_methods_t* methods;63. 64. *&#x2F;** module&#39;s dso \*&#x2F;*65. void* dso;66. 67. \#ifdef __LP64__68. uint64_t reserved[32-7];69. \#else70. *&#x2F;** padding to 128 bytes, reserved for future use \*&#x2F;*71. uint32_t reserved[32-7];72. \#endif73. 74. &#125; hw_module_t;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们先看下结构体 hw_module_t 定义最前面的一段注释说明，它的意思是：</p><blockquote><p>每个硬件模块中都要定义一个名字叫做 HAL_MODULE_INFO_SYM 结构体变量，而这结构体变量中的第一个成员必须是 hw_module_t 类型。也就是说，每个硬件模块都要自己实现一个结构体，但是这个结构体的第一个成员必须是 hw_module_t 结构体类型。</p></blockquote><p><strong>其实这里蕴含着一种面向对象中继承的思想，hw_module_t 就是一个基类，描述所有硬件模块都应该具有的一些属性，然后具体到某个特定的硬件模块实现时，都需要继承自 hw_module_t 结构体。也就是说 hw_module_t 是所有特定硬件模块的父类。</strong></p><p>有关结构体 hw_module_t 中各个成员的具体含义，这里就不一一进行说明了，相信大家从它们的注释说明中就能了解到每一个成员所表示的含义，这里就挑一些重要的结构体成员来进一步说明。</p><blockquote><ul><li>id：这个成员用一个字符串来表示硬件模块的，用来区别于其他硬件模块。</li><li>methods：这个成员是一个 hw_module_methods_t 指针，它表示硬件模块所包含的方法集（其实里面就一个 open 函数指针，用来打开 hw_device_t 硬件设备，获得指向对应的硬件设备的结构体对象的指针）。</li><li>dso：我们前面提到，HAL 层中的<strong>硬件模块</strong>是用动态链接库表示的，所以 dso 指针就是系统使用 dlopen() 函数打开共享动态共享链接库之后获得的句柄。</li></ul></blockquote><h3 id="hw-device-t"><a href="#hw-device-t" class="headerlink" title="hw_device_t"></a>hw_device_t</h3><p>结构体 hw_device_t 定义在 <code>/hardware/libhardware/include/hardware/hardware.h</code> 文件中，其定义如下所示：</p><pre class="line-numbers language-none"><code class="language-none">1. *&#x2F;***2. ** Every device data structure must begin with hw_device_t*3. ** followed by module specific public methods and attributes.*4. **&#x2F;*5. typedef struct hw_device_t &#123;6. *&#x2F;** tag must be initialized to HARDWARE_DEVICE_TAG \*&#x2F;*7. uint32_t tag;8. 9. *&#x2F;***10. ** Version of the module-specific device API. This value is used by*11. ** the derived-module user to manage different device implementations.*12. ***13. ** The module user is responsible for checking the module_api_version*14. ** and device version fields to ensure that the user is capable of*15. ** communicating with the specific module implementation.*16. ***17. ** One module can support multiple devices with different versions. This*18. ** can be useful when a device interface changes in an incompatible way*19. ** but it is still necessary to support older implementations at the same*20. ** time. One such example is the Camera 2.0 API.*21. ***22. ** This field is interpreted by the module user and is ignored by the*23. ** HAL interface itself.*24. **&#x2F;*25. uint32_t version;26. 27. *&#x2F;** reference to the module this device belongs to \*&#x2F;*28. struct hw_module_t* module;29. 30. *&#x2F;** padding reserved for future use \*&#x2F;*31. \#ifdef __LP64__32. uint64_t reserved[12];33. \#else34. uint32_t reserved[12];35. \#endif36. 37. *&#x2F;** Close this device \*&#x2F;*38. int (*close)(struct hw_device_t* device);39. 40. &#125; hw_device_t;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>和 hw_module_t 类似，hw_device_t 也可以看做是一个基类，它描述了所有硬件设备都应该具有的属性，然后具体到某个特定的硬件设备（例如，音频播放时需要的扬声器设备）实现时，都需要继承自 audio_device 结构体。所以，每个 HAL 层中硬件设备对应的结构体中的第一个成员必须是 hw_device_t。</strong></p><p>下面还是简单提一下结构体 hw_device_t 比较关键的几个成员：</p><blockquote><ul><li>module：这个成员是一个 hw_module_t 指针，表示该结构体 hw_device_t 表示的<strong>硬件设备</strong>是由哪个 hw_module_t 表示的<strong>硬件模块</strong>进行管理的。（在这里所以一定要区分清楚==<strong>硬件设备</strong>==和==<strong>硬件模块</strong>==的区别！）</li><li>close：这是一个函数指针，表示如何关闭打开的硬件设备，通常==打开硬件设备的操作==在 hw_module_t 中包含的 hw_module_methods_t 函数列表中的 <strong>open()</strong> 函数中打开的。</li></ul></blockquote><h3 id="hw-module-methods-t"><a href="#hw-module-methods-t" class="headerlink" title="hw_module_methods_t"></a>hw_module_methods_t</h3><p>结构体 hw_module_methods_t 定义在 <code>/hardware/libhardware/include/hardware/hardware.h</code> 文件中，其定义如下所示：</p><pre class="line-numbers language-none"><code class="language-none">1. typedef struct hw_module_methods_t &#123;2. *&#x2F;** Open a specific device \*&#x2F;*3. int (*open)(const struct hw_module_t* module, const char* id,4. struct hw_device_t** device);5. 6. &#125; hw_module_methods_t;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结构体 hw_module_methods_t 就比较简单了，它里面就只有一个 <strong>open</strong> 函数指针，用来打开 module 硬件模块==所管理==的硬件设备id值为 id 的硬件设备，最后将打开的==硬件设备（用 hw_device_t 结构体来描述）==通过 device 返回。</p><p>*<em>注意：这个 open 函数明确指出第三个参数的类型为 struct hw_device_t*<em>，这主要是为了统一不同硬件设备向上层提供的硬件接口，然后在具体使用到某中硬件设备时，再转换成特定硬件设备的结构体类型。</em></em></p><h1 id="Audio-HAL-模块的实现"><a href="#Audio-HAL-模块的实现" class="headerlink" title="Audio HAL 模块的实现"></a>Audio HAL 模块的实现</h1><h3 id="Step-1：定义-struct-audio-module-模块"><a href="#Step-1：定义-struct-audio-module-模块" class="headerlink" title="Step 1：定义 struct audio_module 模块"></a>Step 1：定义 struct audio_module 模块</h3><p>我们前面在结构体 hw_module_t 介绍时，有提到具体的<strong>硬件模块</strong>要定义一个新的结构体并且这个结构体的==第一个成员必须是 hw_module_t 类型==，所以根据这个规则，audio_module 的定义如下所示：</p><p>代码路径：<code>/hardware/libhardware/include/hardware/audio.h</code></p><pre class="line-numbers language-none"><code class="language-none">1. struct audio_module &#123;2. struct hw_module_t common;3. &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="step-2：定义-struct-audio-module-类型的-HAL-MODULE-INFO-SYM-变量"><a href="#step-2：定义-struct-audio-module-类型的-HAL-MODULE-INFO-SYM-变量" class="headerlink" title="step 2：定义 struct audio_module 类型的 HAL_MODULE_INFO_SYM 变量"></a>step 2：定义 struct audio_module 类型的 HAL_MODULE_INFO_SYM 变量</h3><p>HAL_MODULE_INFO_SYM 其实是一个宏，它定义如下所示：</p><p>代码路径：<code>/hardware/libhardware/include/hardware/hardware.h</code></p><pre class="line-numbers language-none"><code class="language-none">1. *&#x2F;***2. ** Name of the hal_module_info*3. **&#x2F;*4. \#define HAL_MODULE_INFO_SYM HMI5. 6. *&#x2F;***7. ** Name of the hal_module_info as a string*8. **&#x2F;*9. \#define HAL_MODULE_INFO_SYM_AS_STR &quot;HMI&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而 struct audio_module 类型名为 <code>HAL_MODULE_INFO_SYM</code> 变量的定义如下所示：</p><p>代码路径：<code>&lt;aosp&gt;/generic/goldfish/audio/audio_hw.c</code></p><pre class="line-numbers language-none"><code class="language-none">1. struct audio_module HAL_MODULE_INFO_SYM &#x3D; &#123;2. .common &#x3D; &#123;3. .tag &#x3D; HARDWARE_MODULE_TAG,4. .module_api_version &#x3D; AUDIO_MODULE_API_VERSION_0_1,5. .hal_api_version &#x3D; HARDWARE_HAL_API_VERSION,6. .id &#x3D; AUDIO_HARDWARE_MODULE_ID,7. .name &#x3D; &quot;Generic audio HW HAL&quot;,8. .author &#x3D; &quot;The Android Open Source Project&quot;,9. .methods &#x3D; &amp;hal_module_methods,10. &#125;,11. &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>但是我们为什么要在每个硬件模块中都定义一个变量名为 HAL_MODULE_INFO_SYM 的变量呢？</strong></p><p>原因是<strong>为了统一标准的接口</strong>。这个硬件模块类型的变量主要是在 HAL 动态链接库加载时用到，它使得上层的 Framework 层打开所有的 HAL 动态链接库时都能找到名为 HAL_MODULE_INFO_SYM（也就是 hmi）的硬件模块类型变量，然后通过这个变量再来打开它所管理的硬件设备，从而与之进行交互。这么做的好处就是 Framework 层中只需要用相同的 API，就能处理各个厂商所提供的不同的 HAL 动态链接库。</p><p>在上面音频硬件设备结构体 <code>audio_hw_device</code> 的定义中，第一个结构体成员就是 <code>struct hw_device_t</code>类型的，而其他的结构体成员都是函数指针，例如 <code>open_output_stream</code> 函数就是用来打开播放音频的扬声器设备，<code>open_input_stream</code> 函数则是用来打开录音用的麦克风设备。</p><h3 id="step-3：定义-struct-audio-hw-device-硬件设备结构体"><a href="#step-3：定义-struct-audio-hw-device-硬件设备结构体" class="headerlink" title="step 3：定义 struct audio_hw_device 硬件设备结构体"></a>step 3：定义 struct audio_hw_device 硬件设备结构体</h3><p>每个硬件设备都需要通过一个结构体来表示，并且这个结构体的第一个成员必须是 hw_device_t 类型。而有关的对底层硬件设备的有关操作的函数指针接口，也是在这个结构体中定义。 struct audio_hw_device 硬件设备结构体的定义如下所示：</p><p>代码路径：<code>/hardware/libhardware/include/hardware/audio.h</code></p><pre class="line-numbers language-none"><code class="language-none">1. struct audio_hw_device &#123;2. *&#x2F;***3. ** Common methods of the audio device. This \*must\* be the first member of audio_hw_device*4. ** as users of this structure will cast a hw_device_t to audio_hw_device pointer in contexts*5. ** where it&#39;s known the hw_device_t references an audio_hw_device.*6. **&#x2F;*7. struct hw_device_t common;8. 9. ......10. 11. *&#x2F;\* Returns audio input buffer size according to parameters passed or*12. ** 0 if one of the parameters is not supported.*13. ** See also get_buffer_size which is for a particular stream.*14. **&#x2F;*15. size_t (*get_input_buffer_size)(const struct audio_hw_device *dev,16. const struct audio_config *config);17. 18. *&#x2F;** This method creates and opens the audio hardware output stream.*19. ** The &quot;address&quot; parameter qualifies the &quot;devices&quot; audio device type if needed.*20. ** The format format depends on the device type:*21. ** - Bluetooth devices use the MAC address of the device in the form &quot;00:11:22:AA:BB:CC&quot;*22. ** - USB devices use the ALSA card and device numbers in the form &quot;card&#x3D;X;device&#x3D;Y&quot;*23. ** - Other devices may use a number or any other string.*24. **&#x2F;*25. 26. int (*open_output_stream)(struct audio_hw_device *dev,27. audio_io_handle_t handle,28. audio_devices_t devices,29. audio_output_flags_t flags,30. struct audio_config *config,31. struct audio_stream_out **stream_out,32. const char *address);33. 34. void (*close_output_stream)(struct audio_hw_device *dev,35. struct audio_stream_out* stream_out);36. 37. *&#x2F;** This method creates and opens the audio hardware input stream \*&#x2F;*38. int (*open_input_stream)(struct audio_hw_device *dev,39. audio_io_handle_t handle,40. audio_devices_t devices,41. struct audio_config *config,42. struct audio_stream_in **stream_in,43. audio_input_flags_t flags,44. const char *address,45. audio_source_t source);46. 47. void (*close_input_stream)(struct audio_hw_device *dev,48. struct audio_stream_in *stream_in);49. 50. ......51. 52. &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="step-4：定义-struct-hw-module-methods-t-函数列表变量"><a href="#step-4：定义-struct-hw-module-methods-t-函数列表变量" class="headerlink" title="step 4：定义 struct hw_module_methods_t 函数列表变量"></a>step 4：定义 struct hw_module_methods_t 函数列表变量</h3><p>在前面介绍的结构体 hw_module_t 的定义中就有一个 hw_module_methods_t 函数指针类型的成员<code>open</code>，该函数的作用就是让<strong>硬件模块</strong>打开<strong>硬件设备</strong>，然后对特定硬件设备（例如上面的 struct audio_device_t结构体）中定义函数指针变量进行赋值绑定，所以在每个<strong>硬件模块</strong>都要实现这样一个变量。</p><p>struct audio_module 结构体中 <code>struct hw_module_t 类型的成员 common</code>中的 hw_module_methods_t 函数指针成员的实现绑定如下所示：</p><p>代码路径：<code>&lt;aosp&gt;/generic/goldfish/audio/audio_hw.c</code></p><pre class="line-numbers language-none"><code class="language-none">1. static struct hw_module_methods_t hal_module_methods &#x3D; &#123;2. .open &#x3D; adev_open,3. &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看到，在 audio HAL 模块中使用了 <code>adev_open</code> 函数来初始化了 struct hw_module_methods_t 中的 <code>open</code> 函数指针成员。我们现在回过头来看 <strong>step 2</strong>中 <strong>struct audio_module HAL_MODULE_INFO_SYM</strong> 变量的定义中，audio_module 中的第一个成员 common中的结构体变量 methods 的指针就是被初始化指向了现在这里定义的 <code>hal_module_methods</code> 变量。</p><h3 id="step-5：adev-open-函数的实现"><a href="#step-5：adev-open-函数的实现" class="headerlink" title="step 5：adev_open 函数的实现"></a>step 5：adev_open 函数的实现</h3><p>最后，我们来看看 <code>adev_open</code> 函数的实现，看看它是如何通过 audio_module 硬件模块对象来打开 audio_hw_device 硬件设备对象。</p><p>代码路径：<code>&lt;aosp&gt;/generic/goldfish/audio/audio_hw.c</code></p><pre class="line-numbers language-none"><code class="language-none">1. static int adev_open(const hw_module_t* module, const char* name,2. hw_device_t** device)3. &#123;4. struct generic_audio_device *adev;5. int fd;6. 7. if (strcmp(name, AUDIO_HARDWARE_INTERFACE) !&#x3D; 0)8. return -EINVAL;9. 10. fd &#x3D; open(AUDIO_DEVICE_NAME, O_RDWR);11. if (fd &lt; 0)12. return -ENOSYS;13. 14. adev &#x3D; calloc(1, sizeof(struct generic_audio_device));15. 16. adev-&gt;fd &#x3D; fd;17. 18. adev-&gt;device.common.tag &#x3D; HARDWARE_DEVICE_TAG;19. adev-&gt;device.common.version &#x3D; AUDIO_DEVICE_API_VERSION_2_0;20. adev-&gt;device.common.module &#x3D; (struct hw_module_t *) module;21. adev-&gt;device.common.close &#x3D; adev_close;22. 23. adev-&gt;device.init_check &#x3D; adev_init_check;24. adev-&gt;device.set_voice_volume &#x3D; adev_set_voice_volume;25. adev-&gt;device.set_master_volume &#x3D; adev_set_master_volume;26. adev-&gt;device.get_master_volume &#x3D; adev_get_master_volume;27. adev-&gt;device.set_master_mute &#x3D; adev_set_master_mute;28. adev-&gt;device.get_master_mute &#x3D; adev_get_master_mute;29. adev-&gt;device.set_mode &#x3D; adev_set_mode;30. adev-&gt;device.set_mic_mute &#x3D; adev_set_mic_mute;31. adev-&gt;device.get_mic_mute &#x3D; adev_get_mic_mute;32. adev-&gt;device.set_parameters &#x3D; adev_set_parameters;33. adev-&gt;device.get_parameters &#x3D; adev_get_parameters;34. adev-&gt;device.get_input_buffer_size &#x3D; adev_get_input_buffer_size;35. adev-&gt;device.open_output_stream &#x3D; adev_open_output_stream;36. adev-&gt;device.close_output_stream &#x3D; adev_close_output_stream;37. adev-&gt;device.open_input_stream &#x3D; adev_open_input_stream;38. adev-&gt;device.close_input_stream &#x3D; adev_close_input_stream;39. adev-&gt;device.dump &#x3D; adev_dump;40. 41. *device &#x3D; &amp;adev-&gt;device.common;42. 43. return 0;44. &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里再补充一个小的定义，<code>struct generic_audio_device</code> 中的第一个成员 <code>device</code> 就是我们前面提到的 <code>struct audio_hw_device</code> 结构体，它的定义如下:</p><p>代码路径：<code>/hardware/libaudio/audio_hw.c</code></p><pre class="line-numbers language-none"><code class="language-none">1. struct generic_audio_device &#123;2. struct audio_hw_device device;3. pthread_mutex_t lock;4. struct audio_stream_out *output;5. struct audio_stream_in *input;6. int fd;7. bool mic_mute;8. &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以从 <code>adev_open</code> 函数中的实现中看到，它里面的主要工作就是做一些对 <code>struct audio_hw_device</code>对象的初始化，将其定义的函数指针指向对应的已经实现好的函数中。例如，这里将<code>struct audio_hw_device</code>中定义的 <code>open_output_stream</code> 函数指针成员指向了 <code>adev_open_output_stream</code> 函数。这样在 Framework 层调用的 <code>struct audio_hw_device</code> 对象的 <code>open_output_stream</code> 函数，其实最终调用的是 <code>adev_open_output_stream</code>函数。</p><p><strong>这里，还有一点需要特别注意的就是我们所打开的硬件设备对象是怎么返回的？</strong> 答案就是它是通过 <code>open</code>函数中的第三个参数 <code>hw_device_t** device</code>返回的。在 open 函数初始化并打开特定的硬件设备之后，它就将硬件设备结构体中的第一个成员 <code>struct audio_hw_device</code> 类型的 common 对象返回。</p><p><em><em>那么为什么这里返回的是 hw_device_t*</em> 类型的硬件设备，而不是audio_hw_device*</em> 类型呢？** 其实这个问题在前面在介绍 <code>hw_module_methods_t</code> 中的 <code>open</code> 函数时已经提到过了。这里主要也蕴含着面向对象编程中的另外一种重要思想<strong>多态</strong>，这使得使用的 hw_device_t 指针就可以访问到子类中继承了父类的属性和方法，如果要获得某个子类所特有的属性，那么只要将其进行类型的强制转换即可。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>理解 Android HAL 层最关键的还是要弄清楚 hw_module_t 、 hw_device_t、 hw_module_methods_t 这三个结构体的含义即关系，以及如何基于这三个结构体来实现特定硬件的<strong>硬件模块结构体</strong>、<strong>硬件设备结构体</strong>、<strong>硬件模块方法列表结构体</strong>。其实从面向对象编程的角度来考虑，前面三者和后面三者之间的关系，就好比是父类和子类的关系。</p>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android编译流程</title>
      <link href="2021/05/21/0-ri-chang-xue-xi/android-bian-yi-liu-cheng/"/>
      <url>2021/05/21/0-ri-chang-xue-xi/android-bian-yi-liu-cheng/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/05/21/0-ri-chang-xue-xi/android-bian-yi-liu-cheng/11.png"></p> <center>图一 编译流程（旧）取自Google官方的<a href="http://developer.android.com/sdk/installing/studio-build.html#detailed-build">[Build System Overview]</a></center><p>注解：</p><ul><li>图中绿色标注为其中用到的相应工具，蓝色代表的是中间生成的各类文件类型；</li><li>首先aapt工具会将资源文件进行转化，生成对应资源ID的R文件和资源文件；</li><li>adil工具会将其中的aidl接口转化成Java的接口；</li><li>至此，Java Compiler开始进行Java文件向class文件的转化，将R文件，Java源代码，由aidl转化来的Java接口，统一转化成.class文件；</li><li>通过dx工具将class文件转化为dex文件；</li><li>此时我们得到了经过处理后的资源文件和一个dex文件，当然，还会存在一些其它的资源文件，这个时候，就是将其打包成一个类似apk的文件，但还并不是直接可以安装在Android系统上的APK文件；</li><li>通过签名工具对其进行签名；</li><li>通过Zipalign进行优化，提升运行速度；</li><li>最终生成一个可以安装在我们手机上的APK；</li></ul><p><img src="/2021/05/21/0-ri-chang-xue-xi/android-bian-yi-liu-cheng/12.png"></p> <center>图二 编译流程（新）取自Google官方<a href="http://tools.android.com/tech-docs/new-build-system/build-workflow">New Build System</a>的Build WorkFlow</center><p>按照上述构建过程进行具体分析：</p><p>第1步：aapt打包资源文件，生成R.java和编译后的资源（二进制文件）</p><p>注解：Android中的资源文件有那些呢?Android应用程序资源可以分为两大类，分别是assets和res：</p><p>1）assets类资源放在工程根目录的assets子目录下，它里面保存的是一些原始的文件，可以以任何方式来进行组织。这些文件最终会被原装不动地打包在apk文件中。如果我们要在程序中访问这些文件，那么就需要指定文件名来访问。例如，假设在assets目录下有一个名称为filename的文件，那么就可以使用以下代码来访问它：</p><blockquote><p>AssetManager am= getAssets();  </p><p>InputStream is = assset.open(“filename”); </p></blockquote><p>2）res类资源放在工程根目录的res子目录下，它里面保存的文件大多数都会被编译，并且都会被赋予资源ID。这样我们就可以在程序中通过ID来访问res类的资源。res类资源按照不同的用途可以进一步划分为以下10种子类型：</p><p>layout(布局文件)，drawable，xml，value，menu，raw，color，anim，animator，mipmap。</p><p>为了使得一个应用程序能够在运行时同时支持不同的大小和密度的屏幕，以及支持国际化，即支持不同的国家地区和语言，Android应用程序资源的组织方式有18个维度，每一个维度都代表一个配置信息，从而可以使得应用程序能够根据设备的当前配置信息来找到最匹配的资源来展现在UI上，从而提高用户体验。由于Android应用程序资源的组织方式可以达到18个维度，因此就要求Android资源管理框架能够快速定位最匹配设备当前配置信息的资源来展现在UI上，否则的话，就会影响用户体验。为了支持Android资源管理框架快速定位最匹配资源，Android资源打包工具aapt在编译和打包资源的过程中，会执行以下两个额外的操作：</p><blockquote><p>1）赋予每一个非assets资源一个ID值，这些ID值以常量的形式定义在一个R.java文件中。</p><p>2）生成一个resources.arsc文件，用来描述那些具有ID值的资源的配置信息，它的内容就相当于是一个资源索引表。包含了所有的id值的数据集合。在该文件中，如果某个id对应的是string，那么该文件会直接包含该值，如果id对应的资源是某个layout或者drawable资源，那么该文件会存入对应资源的路径。</p></blockquote><p>第2步：进行aidl（Android Interface Definition Language，即Android接口定义语言。是我们在编写进程间通信的代码的时候，定义的接口）转换</p><blockquote><p>输入：aidl后缀的文件；</p><p>输出：可用于进程通信的C/S端java代码，位于build/generated/source/aidl；</p></blockquote><p>第3步：Java源码编译</p><p>使用javac将R.java和aidl生成的Java文件，加上工程的源代码进行正常的java编译生成class文件；</p><blockquote><p>输入：java source的文件夹（另外还包括了build/generated下的：R.java, aidl生成的java文件，以及BuildConfig.java）；</p><p>输出：对于gradle编译，可以在build/intermediates/classes里，看到输出的class文件。</p></blockquote><p>第4步：代码混淆（proguard）</p><p>源码编译之后，我们可能还会对其进行代码的混淆，混淆的作用是增加反编译的难度，同时也将一些代码的命名进行了缩短，减少代码占用的空间。混淆完成之后，会生成一个混淆前后的映射表，这个是用来在反应我们的应用执行的时候的一些堆栈信息，可以将混淆后的信息转化为我们混淆前实际代码中的内容。</p><p>而这个过程使用的工具就是ProGuard，是一个开源的Java代码混淆器（obfuscation）。ADT r8开始它被默认集成到了Android SDK中。 其具备三个主要功能。</p><blockquote><p>1）压缩 - 移除无效的类、属性、方法等</p><p>2）优化 - 优化bytecode移除没用的结构</p><p>3）混淆 - 把类名、属性名、方法名替换为晦涩难懂的1到2个字母的名字</p></blockquote><p>当然它也只能混淆Java代码，Android工程中Native代码，资源文件（图片、xml），它是无法混淆的。而且对于Java的常量值也是无法混淆的，所以不要使用常量定义平文的密码等重要信息。同时对于混淆，我们可以通过代码制定去混淆那些，不去混淆那些。</p><p>-keep public class com.rensanning.example.Test</p><p>第5步：转化为dex</p><p>调用dx.bat将所有的class文件转化为classes.dex文件，dx会将class转换为Dalvik字节码，生成常量池，消除冗余数据等。由于dalvik是一种针对嵌入式设备而特殊设计的java虚拟机，所以dex文件与标准的class文件在结构设计上有着本质的区别,当java程序编译成class后，使用dx工具将所有的class文件整合到一个dex文件，目的是其中各个类能够共享数据，在一定程度上降低了冗余，同时也是文件结构更加经凑，实验表明，dex文件是传统jar文件大小的50%左右。class文件结构和dex文件结构比对。</p><p>第6步：apkbuilder</p><p>打包生成APK文件。旧的apkbuilder脚本已经废弃，现在都已经通过sdklib.jar的ApkBuilder类进行打包了。输入为我们之前生成的包含resources.arcs的.ap_文件，上一步生成的dex文件，以及其他资源如jni、.so文件。大致步骤为以包含resources.arcs的.ap_文件为基础，new一个ApkBuilder，设置debugMode</p><blockquote><p>apkBuilder.addZipFile(f);</p><p>apkBuilder.addSourceFolder(f);</p><p>apkBuilder.addResourcesFromJar(f);</p><p>apkBuilder.addNativeLibraries(nativeFileList);</p><p>apkBuilder.sealApk(); // 关闭apk文件</p><p>generateDependencyFile(depFile,inputPaths,outputFile.getAbsolutePath());</p></blockquote><p>第7步：对APK签名</p><p>对APK文件进行签名。Android系统在安装APK的时候，首先会检验APK的签名，如果发现签名文件不存在或者校验签名失败，则会拒绝安装，所以应用程序在发布之前一定要进行签名。签名信息中包含有开发者信息，在一定程度上可以防止应用被伪造。对一个APK文件签名之后，APK文件根目录下会增加META-INF目录，该目录下增加三个文件：</p><blockquote><p>MANIFEST.MF</p><p>[CERT].RSA</p><p>[CERT]</p></blockquote><p>Android系统就是根据这三个文件的内容对APK文件进行签名检验的。签名过程主要利用apksign.jar或者jarsinger.jar两个工具。将根据我们提供的Debug和Release两个版本的Keystore进行相应的签名。</p><p>MANIFEST.MF中包含对apk中除了/META-INF文件夹外所有文件的签名值，签名方法是先SHA1()(或其他hash方法)在base64()。存储形式是：Name加[SHA1]-Digest。</p><p>[CERT].SF是对MANIFEST.MF文件整体签名以及其中各个条目的签名。一般地，如果是使用工具签名，还多包括一项。就是对MANIFEST.MF头部信息的签名。</p><p>[CERT].RSA包含用私钥对[CERT].SF的签名以及包含公钥信息的数字证书。</p><p>第8步：zipalign优化</p><p>Zipalign是一个Android平台上整理APK文件的工具，它首次被引入是在Android 1.6版本的SDK软件开发工具包中。它能够对打包的Android应用程序进行优化， 以使Android操作系统与应用程序之间的交互作用更有效率，这能够让应用程序和整个系统运行得更快。用Zipalign处理过的应用程序执行时间达到最低限度，当设备运行APK应用程序时占更少的RAM。</p><p>Zipalign如何进行优化的呢？调用buildtoolszipalign，对签名后的APK文件进行对齐处理，使APK中所有资源文件距离文件起始偏移为4字节的整数倍，从而在通过内存映射访问APK文件时会更快。同时也减少了在设备上运行时的内存消耗。</p><p>至此，一个完整的Android APK就生成了。</p>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>商业模式新生代</title>
      <link href="2021/05/20/0-du-shu-bi-ji/shang-ye-mo-shi-xin-sheng-dai/"/>
      <url>2021/05/20/0-du-shu-bi-ji/shang-ye-mo-shi-xin-sheng-dai/</url>
      
        <content type="html"><![CDATA[<ol><li>CS客户细分–customer segments：任何一个组织都会服务于一个或多个客户群体</li><li>VP价值主张–value propositions：一个组织的价值主张在于解决客户的问题和满足客户的需求</li><li>CH渠道通路–channels：价值主张通过沟通、分发以及销售渠道传递给客户</li><li>CR客户关系–customer relationships：客户关系以客户群体为单位建立和维护</li><li>R$收入来源–revenue streams：收入来源于将价值主张成功地提供给客户</li><li>KR核心资源–key resources：核心资源是指为实现上述各项元素的供给和交付而必须的资源</li><li>KA关键业务–key activities：为实现供给和交付所需完成的关键业务活动</li><li>KP重要合作–key partnerships：部分活动需要外包，部分资源需要从其他企业获得</li><li>C$成本结构–cost structure：成本结构取决于经济模式中的各项元素</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>身体语言密码</title>
      <link href="2021/05/20/0-du-shu-bi-ji/shen-ti-yu-yan-mi-ma/"/>
      <url>2021/05/20/0-du-shu-bi-ji/shen-ti-yu-yan-mi-ma/</url>
      
        <content type="html"><![CDATA[<ul><li>绝大多数的男性和将近半数的女性并不知道自己脖子以下的身体究竟是何种模样。</li></ul><ul><li>20 世纪 50 年代的一位研究肢体语言的先锋人物阿尔伯特·麦拉宾发现：一条信息所产生的全部影响力中 7%来自于语言（仅指文字），38%来自于声音（其中包括语音、音调以及其他声音），剩下的 55%则全部来自于无声的肢体语言。</li></ul><ul><li>所谓“感知力强”，也就是指能够通过观察发现人们的话语和他们的肢体语言之间的矛盾之处。</li></ul><ul><li>正确解读身体语言的三大规则：</li></ul><ol><li>连贯地理解</li><li>寻找一致性</li><li>结合语境来理解</li></ol><ul><li>投降的小狗会吐出舌头以示友好，人则会亮出自己的手掌</li></ul><ul><li>男性的手臂稍稍向内侧弯曲，而女性的手臂则恰恰相反。稍稍向内侧弯曲的手臂使得男性在瞄准和投掷时能够更加准确，而女性略微向外侧张开的手臂则使得她们能在抱孩子时更加平稳。</li></ul><ol><li>正在撒谎——他的嘴唇在颤抖</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>横向领导力</title>
      <link href="2021/05/20/0-du-shu-bi-ji/heng-xiang-ling-dao-li/"/>
      <url>2021/05/20/0-du-shu-bi-ji/heng-xiang-ling-dao-li/</url>
      
        <content type="html"><![CDATA[<ul><li>培养个人技能，明确目标，影响他人</li></ul><ul><li>我们遇到问题时总是喜欢责怪别人，取得成绩时则喜欢把荣誉据为己有，这是人类的通病。</li></ul><ol><li>根据你想要实现的结果制定目标</li><li>有条理地思考，从数据，到分析，到方向，再到具体行动</li><li>在经验中学习，随时学习，随时总结</li><li>通过接受具有挑战性的任务，充分投入到工作中</li><li>对于应该坚持的工作方法和需要改进的工作方法提供和寻求反馈</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="2021/05/12/ji-suan-ji-wang-luo/"/>
      <url>2021/05/12/ji-suan-ji-wang-luo/</url>
      
        <content type="html"><![CDATA[<ul><li>互联网之所以能够向用户提供许多服务，就是因为互联网具有两个重要基本特点，即连通性和共享。</li></ul><ul><li>电路交换——整个报文的比特流连续地从源点直达终点，好像在一个管道中传送。</li><li>报文交换——整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。</li><li>分组交换——单个分组（这只是整个报文的一部分）传送到相邻结点，存储下来后查找转发表，转发到下一个结点。</li><li>若要连续传送大量的数据，且其传送时间远大于连接建立时间，则电路交换的传输效率较快。报文交换和分组交换不需要预先分配传输带宽，在传送突发数据时可提高整个网络的信道利用率。由于一个分组的长度往往远小于整个报文的长度，因此分组交换比报文交换的时延小，同时也具有更好的灵活性。</li></ul><ul><li>对于高速网络链路，我们提高的仅仅是数据的发送速率而不是比特在链路上的传播速率，传播速率只取决于通信线路的介质材料。因此，通常说的“光纤信道的传输速率高”是指可以用很高的速率向光纤信道发送数据，而光纤信道的传播速率实际上还要比铜线的传播速率略低一些。</li></ul><ul><li>信道或网络的利用率过高会产生非常大的时延。</li></ul><ul><li>能够占领市场的就是标准。</li></ul><ul><li>看一台计算机网络协议是否正确，不能只看在正常情况下是否正确，而且还必须非常仔细地检查这个协议能否应付各种异常情况。</li></ul><ul><li>在任何信道中，码元传输的速率是有上限的，传输速率超过此上限，就会出现严重的码间串扰的问题，使接收端对码元的判决（即识别）成为不可能。</li></ul><ul><li>信号应当有足够大的振幅，以便在噪声干扰下能够在接收端正确地被检测出来。</li></ul><ul><li>时分复用更有利于数字信号的传输</li></ul><ul><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> new </category>
          
      </categories>
      
      
        <tags>
            
            <tag> new </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>产品经理必懂的技术那点事儿</title>
      <link href="2021/05/11/0-du-shu-bi-ji/chan-pin-jing-li-bi-dong-de-ji-zhu-na-dian-shi-er/"/>
      <url>2021/05/11/0-du-shu-bi-ji/chan-pin-jing-li-bi-dong-de-ji-zhu-na-dian-shi-er/</url>
      
        <content type="html"><![CDATA[<ul><li>产品思维侧重从用户和商业视角出发，技术思维侧重在技术实现和系统框架层面，两种思维方式也有交叉点，那就是产品的需求、设计和产品功能。</li></ul><ul><li>产品定位是否清晰直接决定了产品以什么样的形态呈现给用户使用。</li></ul><ul><li>产品经理必现回答的8个问题：<ol><li>产品的目标用户是谁？</li><li>产品为目标用户解决了一个什么核心问题？</li><li>产品的核心功能是什么？</li><li>产品的使用场景是什么？</li><li>产品给目标用户带来的价值是什么？</li><li>如何用一句话介绍产品是什么？</li><li>与同类产品的定位差异是什么？</li><li>产品的盈利模式是什么？</li></ol></li></ul><ul><li>懂技术不如懂产品，去理解产品、理解用户才是真正把产品做好的决定性条件。</li></ul><ul><li>在现在竞争激烈且同质化竞争严重的环境下，快速响应能力会成为一款产品的制胜要诀。应对快速响应有一个理论方法可以采用，那就是MVP（minimum viable product，最小可行性产品）。做MVP需要化繁为简的能力，抓住本质核心，把关键路径上的节点做好后再去做细节分支。很多时候，人都有求全的心理，觉得没有这个会怎样，没有那个会怎样，实际却是不会怎样。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chrome更新书签策略</title>
      <link href="2021/04/26/0-ri-chang-xue-xi/chrome-geng-xin-shu-qian-ce-lue/"/>
      <url>2021/04/26/0-ri-chang-xue-xi/chrome-geng-xin-shu-qian-ce-lue/</url>
      
        <content type="html"><![CDATA[<h5 id="A：这个主要比对的是云端最后一次操作时间和你机器上的最后一次操作时间。（本地修改文件会自动更新修改日期）"><a href="#A：这个主要比对的是云端最后一次操作时间和你机器上的最后一次操作时间。（本地修改文件会自动更新修改日期）" class="headerlink" title="A：这个主要比对的是云端最后一次操作时间和你机器上的最后一次操作时间。（本地修改文件会自动更新修改日期）"></a>A：这个主要比对的是云端最后一次操作时间和你机器上的最后一次操作时间。（本地修改文件会自动更新修改日期）</h5><p>如果某机器的最后一次操作时间比云端的最后一次操作时间要早，那么云端的配置比本地的配置要新，这时采用云端覆盖本地的操作，即下载。</p><p>如果某机器的最后一次登录时间比云端的最后一次操作时间要晚，那么本地的配置比云端的配置要新，这时采用本地覆盖云端的操作，即上传。</p><h5 id="B：目前采用的策略并非“最新的版本全替换”策略，而是“增量合并更新”的方式。"><a href="#B：目前采用的策略并非“最新的版本全替换”策略，而是“增量合并更新”的方式。" class="headerlink" title="B：目前采用的策略并非“最新的版本全替换”策略，而是“增量合并更新”的方式。"></a>B：目前采用的策略并非“最新的版本全替换”策略，而是“增量合并更新”的方式。</h5><p>即当A计算机的版本有更新时，在B计算机上存在旧版本的状态下，在B计算机上打开chrome同步，会采取增量更新合并的方式，即保留B计算机上的内容，同时同步获得A计算机上更新的内容。这样做的目的大概是为了保证本地（B计算机上）内容不因在A计算机的修改发生丢失，同时能够获得A计算机上更新的全部内容。这样的策略可以避免因为在A计算机上的误操作而导致B计算机上书签的丢失，保证了安全性，但是同时损失了书签的简洁性，增加了冗余性。个人还是推荐Google书签同步使用”最新版本全替换”的策略，同时增加书签“历史版本”，便于回滚和找回。</p>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WPS表格无法多窗口打开文件</title>
      <link href="2021/04/26/0-yi-nan-za-zheng/wps-biao-ge-wu-fa-duo-chuang-kou-da-kai-wen-jian/"/>
      <url>2021/04/26/0-yi-nan-za-zheng/wps-biao-ge-wu-fa-duo-chuang-kou-da-kai-wen-jian/</url>
      
        <content type="html"><![CDATA[<p>双击WPS表格EXE打开多个窗口后选择对应的文件打开</p>]]></content>
      
      
      <categories>
          
          <category> 疑难杂症 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>知乎不支持转载的文章怎样复制文字?</title>
      <link href="2021/04/26/0-yi-nan-za-zheng/zhi-hu-bu-zhi-chi-zhuan-zai-de-wen-zhang-zen-yang-fu-zhi-wen-zi/"/>
      <url>2021/04/26/0-yi-nan-za-zheng/zhi-hu-bu-zhi-chi-zhuan-zai-de-wen-zhang-zen-yang-fu-zhi-wen-zi/</url>
      
        <content type="html"><![CDATA[<p>只要从你要复制的最后开始往前选，一直选到开头的X人赞同的同字（包括同字），然后Ctrl+C，万事大吉（谷歌浏览器亲测有效，其余浏览器未测试）</p><p><img src="/2021/04/26/0-yi-nan-za-zheng/zhi-hu-bu-zhi-chi-zhuan-zai-de-wen-zhang-zen-yang-fu-zhi-wen-zi/da914189dbf73cea21ca53fecdc81c5f_720w.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 疑难杂症 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>日常学习01</title>
      <link href="2021/04/25/ri-chang-xue-xi-01/"/>
      <url>2021/04/25/ri-chang-xue-xi-01/</url>
      
        <content type="html"><![CDATA[<ul><li>宏病毒：鉴于绝大多数人都不需要或者不会使用宏功能，所以可以得出一个相对重要的结论：如果office文档在打开时，系统给出一个宏病毒警告框，就应该对这个文档保持高度警惕，它被感染的可能性极大。</li></ul><ul><li>解压缩：以往的压缩工具通常是将计算机中的资料或文档进行压缩，用来缩小存储空间，但是压缩后就不能再运行了，如果想运行必须解压缩。而ASPack是专门对Win32可执行程序进行压缩的工具，压缩后程序仍能正常运行，丝毫不会受到任何影响。</li></ul><ul><li>SQL注入：SQL注入通过网页修改网站数据库，它能够直接在数据库中添加具有管理员权限的用户，最终获得系统管理员权限。黑客利用获得的管理员权限任意获得网站上的文件或者在网页上加挂木马和各种恶意程序，对网站的正常运营和访问该网页的用户都带来巨大危害。</li></ul><ul><li>#define 是宏定义，它不能定义常量，但宏定义可以实现在字面意义上和其它定义常量相同的功能，本质的区别就在于 #define 不为宏名分配内存，而 const 也不为常量分配内存，怎么回事呢，其实 const 并不是去定义一个常量，而是去改变一个变量的存储类，把该变量所占的内存变为只读！</li></ul><ul><li>文件后缀名与封装是什么关系？文件后缀名就是封装的代名词，一般是对应关系，如mkv后缀名就表示的是mkv封装的文件。</li></ul><ul><li>文件后缀名修改后还能不能播放？早期的一些播放器用后缀名识别文件封装格式的，改掉后缀名后不能正常识别文件，现在很多播放器都是读取文件头信息来识别封装格式的，改掉是可以播放的。</li></ul><ul><li>git是用于Linux内核开发的版本控制工具。与CVS、Subversion一類的集中式版本控制工具不同，它采用了分布式版本库的作法，不需要服务器端软件，就可以運作版本控制，使得源代码的发布和交流极其方便。git的速度很快，这对于诸如Linux内核这样的大项目来说自然很重要。git最为出色的是它的合并追踪（merge tracing）能力</li></ul><ul><li>SVN更适用于项目管理， Git仅适用于代码管理</li></ul><ul><li>整个主机板上面最重要的就是芯片组了！而芯片组通常又分为两个桥接器来控制各组件的沟通，分别是：(1)北桥：负责连结速度较快的CPU、主内存与显示卡等组件；(2)南桥：负责连接速度较慢的周边介面，包括硬盘、USB、网络卡等等</li></ul><ul><li>假设你今天购买了500GB的硬盘一颗，但是格式化完毕后却只剩下460GB左右的容量，这是什么原因？答：因为一般硬盘制造商会使用十进位的单位，所以500GByte代表为500<em>1000</em>1000*1000Byte之意。转成档案的容量单位时使用二进位(1024为底)，所以就成为466GB左右的容量了。硬盘厂商并非要骗人，只是因为硬盘的最小物理量为512Bytes，最小的组成单位为磁区(sector)， 通常硬盘容量的计算采用『多少个sector』，所以才会使用十进位来处理的</li></ul>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>U盘病毒制作过程曝光</title>
      <link href="2021/04/25/u-pan-bing-du-zhi-zuo-guo-cheng-pu-guang/"/>
      <url>2021/04/25/u-pan-bing-du-zhi-zuo-guo-cheng-pu-guang/</url>
      
        <content type="html"><![CDATA[<h3 id="步骤1：将病毒或木马复制到U盘中"><a href="#步骤1：将病毒或木马复制到U盘中" class="headerlink" title="步骤1：将病毒或木马复制到U盘中"></a>步骤1：将病毒或木马复制到U盘中</h3><h3 id="步骤2：在U盘中新建文本文档，并重命名为“Autorun-inf”"><a href="#步骤2：在U盘中新建文本文档，并重命名为“Autorun-inf”" class="headerlink" title="步骤2：在U盘中新建文本文档，并重命名为“Autorun.inf”"></a>步骤2：在U盘中新建文本文档，并重命名为“Autorun.inf”</h3><h3 id="步骤3：用记事本打开“Autorun-inf”，编辑文件代码，使得双击U盘图标后运行制定木马程序"><a href="#步骤3：用记事本打开“Autorun-inf”，编辑文件代码，使得双击U盘图标后运行制定木马程序" class="headerlink" title="步骤3：用记事本打开“Autorun.inf”，编辑文件代码，使得双击U盘图标后运行制定木马程序"></a>步骤3：用记事本打开“Autorun.inf”，编辑文件代码，使得双击U盘图标后运行制定木马程序</h3><pre class="line-numbers language-none"><code class="language-none">[AutoRun]OPEN&#x3D;腾讯QQ.batshellexecute&#x3D;腾讯QQ.batshell\Auto\command&#x3D;腾讯QQ.bat]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2021/04/25/u-pan-bing-du-zhi-zuo-guo-cheng-pu-guang/image-20210425181201257.png"></p><h3 id="步骤4：将病毒或木马文件和“Autorun-inf”文件隐藏——在“属性”→“常规”界面勾选“隐藏”复选框"><a href="#步骤4：将病毒或木马文件和“Autorun-inf”文件隐藏——在“属性”→“常规”界面勾选“隐藏”复选框" class="headerlink" title="步骤4：将病毒或木马文件和“Autorun.inf”文件隐藏——在“属性”→“常规”界面勾选“隐藏”复选框"></a>步骤4：将病毒或木马文件和“Autorun.inf”文件隐藏——在“属性”→“常规”界面勾选“隐藏”复选框</h3><h3 id="最终：将U盘接入计算机中，右击U盘对应的图标，在快捷菜单中回到Auto命令，表示设置成功"><a href="#最终：将U盘接入计算机中，右击U盘对应的图标，在快捷菜单中回到Auto命令，表示设置成功" class="headerlink" title="最终：将U盘接入计算机中，右击U盘对应的图标，在快捷菜单中回到Auto命令，表示设置成功"></a>最终：将U盘接入计算机中，右击U盘对应的图标，在快捷菜单中回到Auto命令，表示设置成功</h3>]]></content>
      
      
      <categories>
          
          <category> 牛刀小试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 黑客尝试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令积累</title>
      <link href="2021/04/25/linux-ming-ling-ji-lei/"/>
      <url>2021/04/25/linux-ming-ling-ji-lei/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关机病毒制作</title>
      <link href="2021/04/22/0-niu-dao-xiao-shi/guan-ji-bing-du-zhi-zuo/"/>
      <url>2021/04/22/0-niu-dao-xiao-shi/guan-ji-bing-du-zhi-zuo/</url>
      
        <content type="html"><![CDATA[<h4 id="步骤1：打开新建的记事本，输入“shutdown-p”命令，即自动重启本地计算机，保存，重命名文本文档为“腾讯QQ-bat”"><a href="#步骤1：打开新建的记事本，输入“shutdown-p”命令，即自动重启本地计算机，保存，重命名文本文档为“腾讯QQ-bat”" class="headerlink" title="步骤1：打开新建的记事本，输入“shutdown -p”命令，即自动重启本地计算机，保存，重命名文本文档为“腾讯QQ.bat”"></a>步骤1：打开新建的记事本，输入“shutdown -p”命令，即自动重启本地计算机，保存，重命名文本文档为“腾讯QQ.bat”</h4><p><img src="/2021/04/22/0-niu-dao-xiao-shi/guan-ji-bing-du-zhi-zuo/image-20210425164750463.png"></p><h4 id="步骤2：右键单击“腾讯QQ-bat”图标，在弹出的菜单中单击“创建快捷方式命令”"><a href="#步骤2：右键单击“腾讯QQ-bat”图标，在弹出的菜单中单击“创建快捷方式命令”" class="headerlink" title="步骤2：右键单击“腾讯QQ.bat”图标，在弹出的菜单中单击“创建快捷方式命令”"></a>步骤2：右键单击“腾讯QQ.bat”图标，在弹出的菜单中单击“创建快捷方式命令”</h4><h4 id="步骤3：右键单击“腾讯QQ-bat-快捷方式”图标，在弹出的菜单中单击“属性”命令"><a href="#步骤3：右键单击“腾讯QQ-bat-快捷方式”图标，在弹出的菜单中单击“属性”命令" class="headerlink" title="步骤3：右键单击“腾讯QQ.bat-快捷方式”图标，在弹出的菜单中单击“属性”命令"></a>步骤3：右键单击“腾讯QQ.bat-快捷方式”图标，在弹出的菜单中单击“属性”命令</h4><h4 id="步骤4：切换至“快捷方式”选项卡，单击“更改图标”按钮，改成腾讯QQ的图标"><a href="#步骤4：切换至“快捷方式”选项卡，单击“更改图标”按钮，改成腾讯QQ的图标" class="headerlink" title="步骤4：切换至“快捷方式”选项卡，单击“更改图标”按钮，改成腾讯QQ的图标"></a>步骤4：切换至“快捷方式”选项卡，单击“更改图标”按钮，改成腾讯QQ的图标</h4><p><img src="/2021/04/22/0-niu-dao-xiao-shi/guan-ji-bing-du-zhi-zuo/image-20210425162955428.png"></p><h4 id="步骤5：右键单击“腾讯QQ-bat”图标，在弹出的菜单中单击“属性”，切换到“常规”选项卡，勾选“隐藏”勾选框"><a href="#步骤5：右键单击“腾讯QQ-bat”图标，在弹出的菜单中单击“属性”，切换到“常规”选项卡，勾选“隐藏”勾选框" class="headerlink" title="步骤5：右键单击“腾讯QQ.bat”图标，在弹出的菜单中单击“属性”，切换到“常规”选项卡，勾选“隐藏”勾选框"></a>步骤5：右键单击“腾讯QQ.bat”图标，在弹出的菜单中单击“属性”，切换到“常规”选项卡，勾选“隐藏”勾选框</h4><p><img src="/2021/04/22/0-niu-dao-xiao-shi/guan-ji-bing-du-zhi-zuo/image-20210425163106991.png"></p><h4 id="最终：可看到桌面上未显示“腾讯QQ-bat”图标，只显示了“腾讯QQ”图标，用户一旦双击该图标计算机便会关机"><a href="#最终：可看到桌面上未显示“腾讯QQ-bat”图标，只显示了“腾讯QQ”图标，用户一旦双击该图标计算机便会关机" class="headerlink" title="最终：可看到桌面上未显示“腾讯QQ.bat”图标，只显示了“腾讯QQ”图标，用户一旦双击该图标计算机便会关机"></a>最终：可看到桌面上未显示“腾讯QQ.bat”图标，只显示了“腾讯QQ”图标，用户一旦双击该图标计算机便会关机</h4><p><img src="/2021/04/22/0-niu-dao-xiao-shi/guan-ji-bing-du-zhi-zuo/image-20210425165826248.png"></p><h4 id="关机相关命令介绍："><a href="#关机相关命令介绍：" class="headerlink" title="关机相关命令介绍："></a>关机相关命令介绍：</h4><p>一段时间后关机：shutdown -s -t 秒数效果是倒计时到该秒数后关机，例如shutdown -s -t 3600就是3600秒后关机，也就是一小时后关机</p><p>立即关机命令：shutdown -p关闭本地计算机，效果是马上关机，而不进行倒计时；也可以使用shutdown -s -t 0设置0秒后关机，也就是立即关机的意思</p><p>一段时间后重启：shutdown -r -t 秒数，效果是倒计时该秒数后重启，例如shutdown -r -t 0倒数0秒后重启，也就是立即重启的意思，如果没有加-t参数则会倒计时默认的秒数后关机，一般是一分钟</p><p>休眠命令：shutdown -h,这条指令让计算机休眠，也就是完全断电，但是会保存当前电脑的状态，下次启动时这些打开过的程序都还在。类似虚拟机的挂起功能</p><p>睡眠指令：睡眠和休眠的不同的地方是，睡眠没有完全掉电，电脑中其他的耗电部分都关闭，只留下内存供电，下次在唤醒电脑的时候，恢复到睡眠之前的状态。这点和休眠类似，睡眠的好处就是启动快。短时间离开电脑的话可以睡眠，如果时间间隔比较久的话用休眠。休眠和关机一样是不耗电的，而睡眠因为还有给内存供电，所以睡眠还是耗电的</p><p>启用屏幕保护：cmd下输入rundll32.exe user32.dll LockWorkStation，可以启动屏幕保护功能，这样要再次使用电脑的时候要输入密码。可以在短时间离开的时候，防止别人动你电脑</p><p>显示shutdown命令语法：输入shutdown -help显示shutdown指令的用法</p><p>shutdown -a表示取消关机，或者取消重启。在shutdown -s或者shutdown -r倒计时结束之前执行shutdown -a可以取消关机或者重启操作</p>]]></content>
      
      
      <categories>
          
          <category> 牛刀小试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 黑客尝试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下删除文件的几种方法及速度比较</title>
      <link href="2021/04/22/0-ri-chang-xue-xi/linux-xia-shan-chu-wen-jian-de-ji-chong-fang-fa-ji-su-du-bi-jiao/"/>
      <url>2021/04/22/0-ri-chang-xue-xi/linux-xia-shan-chu-wen-jian-de-ji-chong-fang-fa-ji-su-du-bi-jiao/</url>
      
        <content type="html"><![CDATA[<h3 id="方法汇总："><a href="#方法汇总：" class="headerlink" title="方法汇总："></a>方法汇总：</h3><p>场景：删除/tmp下的所有文件</p><p>方法一：直接使用rm——rm -f /tmp/*</p><p>方法二：使用find 和 rm——find /tmp/ -type f  -exec rm {} \</p><p>方法三： 使用find——find /tmp/ -type f -delete</p><p>方法四：使用rsync，rsync是linux下文件同步和数据传输的命令。通过构造一个空文件夹并且和目标文件夹进行同步，就可以把目标文件夹的内容给删除了：</p><p>mkdir blankfiles<br>rsync –delete-before -d blanktest/  /tmp/</p><h3 id="速度比较："><a href="#速度比较：" class="headerlink" title="速度比较："></a>速度比较：</h3><table><thead><tr><th align="left">COMMAND</th><th align="left">TIME TAKEN</th></tr></thead><tbody><tr><td align="left">RM Command</td><td align="left">Is not capable of deleting large number of files</td></tr><tr><td align="left">Find Command with -exec</td><td align="left">14 Minutes for half a million files</td></tr><tr><td align="left">Find Command with -delete</td><td align="left">5 Minutes for half a million files</td></tr><tr><td align="left">Perl</td><td align="left">1 Minute for half a million files</td></tr><tr><td align="left">RSYNC with -delete</td><td align="left">2 Minute 56 seconds for half a million files</td></tr></tbody></table><hr><center> 详情请见大佬说明文档：<a href="https://www.slashroot.in/which-is-the-fastest-method-to-delete-files-in-linux">Which is the fastest method to delete files in Linux</a> </center><p>Creating, deleting, and modifying files is one of the common task that a user does in any operating system. This kind of task comes under a day to day list of tasks that a user does. Although it is quite fast and seamless operation when it comes to deleting a single or a handful of files in Linux or any other operating system. But if the number of files is quite large, then the deletion operation takes quite long to complete.</p><p><a href="http://www.slashroot.in/how-does-file-deletion-work-linux">What happens when you delete a file in Linux</a>, depends on the kind of file system, on which the file you want to delete resides. There are many operational differences in deleting files under different types of file system. When we talk about files in Linux, its all about inodes rather than files. How an inode gets modified, during file deletion is an important aspect to understand.</p><p>Inodes are the building blocks of Linux operating system. If you are interested in understanding inodes, i would recommend reading the below post, before going ahead, as we will not be discussing inode related details in this post.</p><p><strong>Read:</strong> <a href="http://www.slashroot.in/inode-and-its-structure-linux">What is an inode in Linux</a></p><p>I am writing this post, to find out the fastest method to delete large number of files in Linux. We will begin this tutorial with some simple file deletion methods, and then will compare the speed with which different method completed the task of file deletion. Another major reason for writing this post is the time i spend on one of our crawler servers, to delete millions of files with very small size (few KBs).</p><p>As i told, if you are dealing with small number of files, then the operation will be fast compared to a large number of files which are of very small size. Let’s begin this with some simple commands in Linux used to delete files.</p><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="Commands-to-delete-files-in-Linux-and-their-example-usage"><a href="#Commands-to-delete-files-in-Linux-and-their-example-usage" class="headerlink" title="Commands to delete files in Linux and their example usage"></a>Commands to delete files in Linux and their example usage</h2><p>To delete files in Linux, the most commonly used command is rm command. Let’s see some example’s of rm command.</p><pre class="line-numbers language-none"><code class="language-none">[root@myvm1 ~]# rm -f testfile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>-f</strong> used in the above command, will delete the file forcefully without asking for a confirmation.</p><pre class="line-numbers language-none"><code class="language-none">[root@myvm1 ~]# rm -rf testdirectory<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>The above command will delete the directory named “<strong>testdirectory</strong>“ as well as all the contents inside that directory(-r option used is to delete files recursively)</p><pre class="line-numbers language-none"><code class="language-none">[root@myvm1 ~]# rmdir testdirectory<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>The above command rmdir, will only delete the directory if its empty.</p><p>Let’s now have a look at some different methods of deleting files in Linux. One of my favorite methods out there is to use find command. Find commands is a very handy tool that can be used to search files according to its type, size, created date, modified date, and much more different criteria. To find out more about this wonderful searching tool in Linux, read the below post.</p><p><strong>Read:<a href="http://www.slashroot.in/find-command-usage-and-examples-linux"> </a></strong><a href="http://www.slashroot.in/find-command-usage-and-examples-linux">Usage examples of find command in Linux</a></p><pre class="line-numbers language-none"><code class="language-none">[root@myvm1 &#x2F;]# find &#x2F;test -type f -exec rm &#123;&#125; \;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>The above shown command, will delete all the files inside /test directory. First the find command will look for all files inside the directory, and then for each result, it will execute and rm.</p><p>Let’s see some different methods that can be used with find command, to delete files.</p><pre class="line-numbers language-none"><code class="language-none">[root@myvm1 &#x2F;]# find &#x2F;test -mtime +7 -exec rm &#123;&#125; \;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>In the above shown example, find command will search all those files inside the /test directory which are modified 7 days ago, and then delete each of them.</p><pre class="line-numbers language-none"><code class="language-none">[root@myvm1 &#x2F;]# find &#x2F;test -size +7M -exec rm &#123;&#125; \;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Above shown example, will search for all those files in the directory /test which are larger than 7M, and then delete each of them.</p><p>In all of the above shown examples of find command, rm command is invoked for each and every file in the list. For example, in the last find command shown above, if the result is 50 files which are bigger than 7M, then 50 rm commands are invoked for deleting each of them. This will take a much longer time.</p><p>Instead of using the above command of rm with the help of -exec argument in find, there is a better alternative. We will see the alternative and then calculate the difference between speed in each of them.</p><p>As i told before, the main idea behind finding the deletion speed, is when you delete large number of files. So lets first create half a million files with the help of a simple bash for loop. And after creating half a million files, we will try to delete it with rm command, find command with exec argument and then will see a better find command alternative.</p><pre class="line-numbers language-none"><code class="language-none">[root@myvm1 test]# for i in $(seq 1 500000); do echo testing &gt;&gt; $i.txt; done<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>The above command will create 5 lakh files (half a million) in the current working directory, with the name 1.txt to 500000.txt, and each file contains the text <strong>“testing”,</strong> so the file size will be at least in the range of some kilo bytes. Let’s now test the speed of deleting these number of files with different commands. First let’s use the simple rm command, and then will use find command with -exec and then delete option to calculate the time taken to delete these number of files.</p><pre class="line-numbers language-none"><code class="language-none">[root@myvm1 test]# time rm -f *-bash: &#x2F;bin&#x2F;rm: Argument list too longreal  0m11.126suser  0m9.673ssys   0m1.278s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>If you see the above rm command i ran on the test directory, containing half a million files, it gave me a message saying <strong>/bin/rm: Argument list too long</strong>. Which means the command didn’t complete the deletion, because the number of files given to rm command was too big to complete. So rm command didn’t even stand the test, because it gave up. Don’t pay attention to the time displayed by the time command, because rm command didn’t complete its operation, and time command displays the output without bothering about the end result of the command.</p><p>Now let’s use our previously seen find command with -exec argument.</p><pre class="line-numbers language-none"><code class="language-none">[root@myvm1 test]# time find .&#x2F; -type f -exec rm &#123;&#125; \;real  14m51.735suser  2m24.330ssys   9m48.743s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>From the output we got by using time command, it is clear that it took 14 minutes and 51 seconds to delete 5 lakh files from a single directory. This is quite a long time, because for each file a separate rm command is executed, until the complete list of files gets deleted.</p><p>Now lets test the time consumed, by using <strong>-delete,</strong> option in find command.</p><pre class="line-numbers language-none"><code class="language-none">[root@myvm1 test]# time find .&#x2F; -type f -deletereal  5m11.937suser  0m1.259ssys   0m28.441s[root@myvm1 test]#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Wow you saw that result!! -delete option only took 5 minutes 11 seconds. That’s a wonderful improvement in the speed, when you delete millions of files in Linux.</p><p>Let’s now have a look at how deleting files using Perl language works, and its speed compared to other options we saw earlier.</p><pre class="line-numbers language-none"><code class="language-none">[root@myvm1 test]# time perl -e &#39;for(&lt;*&gt;)&#123;((stat)[9]&lt;(unlink))&#125;&#39;real  1m0.488suser  0m7.023ssys   0m27.403s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>That’s insanely fast compared to other find command, and rm command options we saw earlier. Till now this seems to be the best method that can be used to delete all the files in a directory. That’s a remarkable achievement in speed for deleting files in Linux. If you see the output Perl only took around 1 minute to delete half a million files in that directory.</p><p>But yeah if you are interested in finding more complex options while using Perl, you need to have some good hands on with Perl regular expressions.</p><p>There is one more lesser used and less known method that can be used to delete large number of files inside a folder. This method is none other than our famous tool <strong>RSYNC</strong> used for transferring and synchronizing files between two local as well as remote locations in Linux.</p><p>Let’s have a look at that method of deleting all files inside a folder with the help of RSYNC command. The method and logic used behind deleting files with the help of rsync is based on the fact that rsync is commonly used for synchronizing files between two different locations.</p><p>This can be achieved by simply synchronizing a target directory which has the large number of files, with an empty directory. In our case <strong>test</strong> directory has half a million files, lets create a directory called as <strong>blanktest</strong>, which will be kept empty for the purpose of simply synchronization. Now along with this we will be using -delete option in rsync, which will delete all those files in the target directory, which are are not present in the source(in our case the source is an empty directory, so all the files in the destination directory will be deleted.)</p><p><strong>Empty Directory</strong>: /home/blanktest</p><p><strong>Directory to be emptied:</strong> /test</p><pre class="line-numbers language-none"><code class="language-none">[root@myvm1 home]# time rsync -a --delete blanktest&#x2F; test&#x2F;real  2m52.502suser  0m2.772ssys   0m32.649s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>The results are pretty impressive, so its much better to use rsync if you want to empty a directory containing millions of files, compared to find command.</p><p>The below shown table summarizes the speed for file deletion in Linux, using different methods in Linux.</p><table><thead><tr><th align="left">COMMAND</th><th align="left">TIME TAKEN</th></tr></thead><tbody><tr><td align="left">RM Command</td><td align="left">Is not capable of deleting large number of files</td></tr><tr><td align="left">Find Command with -exec</td><td align="left">14 Minutes for half a million files</td></tr><tr><td align="left">Find Command with -delete</td><td align="left">5 Minutes for half a million files</td></tr><tr><td align="left">Perl</td><td align="left">1 Minute for half a million files</td></tr><tr><td align="left">RSYNC with -delete</td><td align="left">2 Minute 56 seconds for half a million files</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主题美化</title>
      <link href="2021/04/21/zhu-ti-mei-hua/"/>
      <url>2021/04/21/zhu-ti-mei-hua/</url>
      
        <content type="html"><![CDATA[<center>详情请见官方文档：<a herf="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">hexo-theme-matery</a></center><h3 id="待完成事项"><a href="#待完成事项" class="headerlink" title="待完成事项"></a>待完成事项</h3><ul><li>待增添留言板功能</li></ul><blockquote><p><strong>注</strong>：本留言板功能依赖于第三方评论系统，请<strong>激活</strong>你的评论系统才有效果。并且在主题的 <code>_config.yml</code> 文件中，第 <code>19</code> 至 <code>21</code> 行的“<strong>菜单</strong>”配置，取消关于留言板的注释即可。</p></blockquote><ul><li>更改头像</li></ul><ul><li>修改关于页面</li></ul>]]></content>
      
      
      <categories>
          
          <category> 个人博客设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac怎样查看隐藏文件</title>
      <link href="2021/04/21/0-yi-nan-za-zheng/mac-zen-yang-cha-kan-yin-cang-wen-jian/"/>
      <url>2021/04/21/0-yi-nan-za-zheng/mac-zen-yang-cha-kan-yin-cang-wen-jian/</url>
      
        <content type="html"><![CDATA[<p>现代人的隐私保护意识越来越强。而电脑做为日常生活和工作资料的储存箱，会存放很多涉及个人隐私的内容。所以有人喜欢在Mac上隐藏文件和文件夹，来保护自己的个人隐私。</p><p>但是隐藏之后，有些用户却不知道如何让隐藏文件再显示出来，今天就来教大家如何在Mac上显示隐藏文件的几种办法。</p><p>在我们说明办法之前，先普及一下隐藏文件的一些知识。</p><h2 id="什么是隐藏文件以及它们在Mac上的位置？"><a href="#什么是隐藏文件以及它们在Mac上的位置？" class="headerlink" title="什么是隐藏文件以及它们在Mac上的位置？"></a>什么是隐藏文件以及它们在Mac上的位置？</h2><p>其实在我们的电脑中，默认情况下就会有很多隐藏文件和文件夹。这样用户在使用的过程中就不会意外的将其删除或者修改他们。</p><p>因为这些默认隐藏的文件和文件夹都是一些支撑Mac运行的重要文件，总之是很重要的东西。</p><p>在Mac中，隐藏文件不会显示在正常的文件和文件夹列表中。它们以“.”命名。在他们的名字之前隐藏文件可以是任何类型，例如，它可以是.bash_profile，.htaccess文件或.svn目录。如果希望，还可以隐藏/ bin，/ usr和/ etc等文件夹。大多数隐藏的文件都存在于Library文件夹（〜/ Library）中。</p><h2 id="如何在Mac上显示隐藏文件？"><a href="#如何在Mac上显示隐藏文件？" class="headerlink" title="如何在Mac上显示隐藏文件？"></a>如何在Mac上显示隐藏文件？</h2><p>现在您已经了解了隐藏文件和文件夹的基本知识，那么隐藏文件和文件夹要怎么重新显示出来呢？</p><h3 id="方法1：使用Finder查看Mac隐藏文件"><a href="#方法1：使用Finder查看Mac隐藏文件" class="headerlink" title="方法1：使用Finder查看Mac隐藏文件"></a>方法1：使用Finder查看Mac隐藏文件</h3><p>在最新的macOS Sierra中，Apple包含了Finder快捷键。这允许用户快速显示隐藏的文件夹Mac。</p><p>操作步骤如下：</p><ul><li><p>打开Finder，然后点击主文件夹。您可以访问左栏中“设备”下的主文件夹。</p></li><li><p>按键盘键Cmd + Shift +。 （点）。只要按下此组合键，就会看到所有隐藏的文件夹和文件。</p><p><img src="/2021/04/21/0-yi-nan-za-zheng/mac-zen-yang-cha-kan-yin-cang-wen-jian/finder.jpg"></p></li><li><p>如果您需要再次隐藏这些文件，您只需再次按下该组合即可。</p></li></ul><h3 id="方法2：直接在库中查找隐藏文件夹"><a href="#方法2：直接在库中查找隐藏文件夹" class="headerlink" title="方法2：直接在库中查找隐藏文件夹"></a>方法2：直接在库中查找隐藏文件夹</h3><p>还有一种办法是直接在〜/ Library文件夹中进行查找</p><ul><li><p>首先打开Finder。按Alt（选项）键。现在，从按下键后丢弃的菜单栏中选择Go。</p></li><li><p>您现在可以使用Home文件夹下面的〜/ Library文件夹。</p></li><li><p>您也可以转到Finder &gt;&gt; Go查看该文件夹。现在选择“转到文件夹”选项或只需按Shift + Cmd + G组合键。现在输入〜/ Library并点击Go。</p><p><img src="/2021/04/21/0-yi-nan-za-zheng/mac-zen-yang-cha-kan-yin-cang-wen-jian/library.jpg"></p></li></ul><p>这将显示所有隐藏的文件和文件夹。此外，它还将授予您访问这些文件夹的权限。</p><h3 id="方法3：使用命令查找隐藏文件和文件夹"><a href="#方法3：使用命令查找隐藏文件和文件夹" class="headerlink" title="方法3：使用命令查找隐藏文件和文件夹"></a>方法3：使用命令查找隐藏文件和文件夹</h3><p>如果你还想尝试一些更极客的办法，那么你可以使用命令查找</p><p>如果你是一个极客并且非常清楚使用终端，那么这个解决方案可能会激发你的兴趣。您所要做的就是按照以下步骤进行操作。</p><ul><li><p>首先要打开终端。</p></li><li><p>在终端中，运行以下提到的脚本：</p></li><li><p>$ defaults写com.apple.Finder AppleShowAllFiles true $ killall Finder您的隐藏文件夹将可见。</p></li><li><p>如果要隐藏起来，只需要运行相同的脚本，将“true”值更改为“false”</p><p><img src="/2021/04/21/0-yi-nan-za-zheng/mac-zen-yang-cha-kan-yin-cang-wen-jian/terminal.jpg"></p></li><li><p>如前所述，默认情况下会隐藏某些文件夹和文件。这是为了避免用户可能错误地对它们执行的修改。修改这些文件会损坏您的Mac系统，并且是不可逆的。</p></li><li><p>由于该过程不可逆转，所以在操作时需谨慎处理。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 疑难杂症 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac电脑使用技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建</title>
      <link href="2021/04/21/0-ge-ren-bo-ke-she-ji/bo-ke-da-jian/"/>
      <url>2021/04/21/0-ge-ren-bo-ke-she-ji/bo-ke-da-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><h4 id="GitHub-pages设置"><a href="#GitHub-pages设置" class="headerlink" title="GitHub pages设置"></a>GitHub pages设置</h4><ol><li>注册GitHub账号</li><li>打开<a href="https://github.com/%EF%BC%8C%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%EF%BC%9A">https://github.com/，新建一个项目：</a></li></ol><p><img src="/2021/04/21/0-ge-ren-bo-ke-she-ji/bo-ke-da-jian/1.jpg"></p><p>然后如下图所示，输入自己的项目名字，后面一定要加<code>.github.io</code>后缀，README初始化也要勾上</p><p><strong>名称一定要和你的github名字完全一样，比如你github名字叫<code>abc</code>，那么仓库名字一定要是<code>abc.github.io</code></strong></p><p><img src="/2021/04/21/0-ge-ren-bo-ke-she-ji/bo-ke-da-jian/2.jpg"></p><p>然后项目就建成了，点击<code>Settings</code>，向下拉到最后有个<code>GitHub Pages</code>，点击<code>Choose a theme</code>选择一个主题。然后等一会儿，再回到<code>GitHub Pages</code>，会变成下面这样：</p><p><img src="/2021/04/21/0-ge-ren-bo-ke-she-ji/bo-ke-da-jian/3.jpg"></p><p>浏览器输入链接”yourname.github.io”，就会出现自己的网页啦，效果如下：</p><p><img src="/2021/04/21/0-ge-ren-bo-ke-she-ji/bo-ke-da-jian/4.jpg"></p><h4 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h4><ol><li><p>去官网下载最新稳定版<a href="https://nodejs.org/en/">Node.js</a></p></li><li><p>安装选项全部默认，一路点击<code>Next</code></p></li><li><p>最后安装好之后，按<code>Win+R</code>打开命令提示符，输入<code>node -v</code>和<code>npm -v</code>，如果出现版本号，那么就安装成功了</p></li></ol><h4 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h4><ol><li><p>为了把本地的网页文件上传到github上面去，我们需要用到分布式版本控制工具————Git[<a href="https://git-scm.com/download/win">下载地址]</a></p></li><li><p>安装选项还是全部默认，只不过最后一步添加路径时选择<code>Use Git from the Windows Command Prompt</code>，这样我们就可以直接在命令提示符里打开git了</p></li><li><p>安装完成后在命令提示符中输入<code>git --version</code>验证是否安装成功</p></li></ol><h2 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h2><h4 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h4><ol><li><p>在合适的地方新建一个文件夹，用来存放自己的博客文件，比如存放在<code>D:\blog</code>目录下</p></li><li><p>在该目录下右键点击<code>Git Bash Here</code>，打开git的控制台窗口（以后我们所有的操作都在git控制台进行，就不要用Windows自带的控制台了）</p></li><li><p>定位到该目录下，输入<code>npm i hexo-cli -g</code>安装Hexo（会有几个报错，无视它就行）</p></li><li><p>安装完后输入<code>hexo -v</code>验证是否安装成功</p></li><li><p>然后就要初始化我们的网站，输入<code>hexo init</code>初始化文件夹，接着输入<code>npm install</code>安装必备的组件</p></li><li><p>这样本地的网站配置也弄好啦，输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>打开本地服务器，然后浏览器打开<a href="http://localhost:4000/%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E6%88%91%E4%BB%AC%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%95%A6%EF%BC%8C%E6%95%88%E6%9E%9C%E5%A6%82%E4%B8%8B%EF%BC%9A%EF%BC%88%E6%8C%89%60ctrl+c%60%E5%85%B3%E9%97%AD%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89">http://localhost:4000/，就可以看到我们的博客啦，效果如下：（按`ctrl+c`关闭本地服务器）</a></p></li></ol><p><img src="/2021/04/21/0-ge-ren-bo-ke-she-ji/bo-ke-da-jian/5.jpg"></p><h4 id="连接GitHub与本地"><a href="#连接GitHub与本地" class="headerlink" title="连接GitHub与本地"></a>连接GitHub与本地</h4><ol><li>首先右键打开git bash，然后输入下面命令：（用户名和邮箱根据你注册github的信息自行修改）</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config --global user.name <span class="token string">"yourname"</span><span class="token function">git</span> config --global user.email <span class="token string">"youremail"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li>然后生成密钥SSH key：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen -t rsa -C <span class="token string">"youremail"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>打开<a href="http://github.com/">github</a>，在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个SSH，名字随便</li></ol><blockquote><p>git bash中输入</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> ~/.ssh/id_rsa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>将输出的内容复制到框中，点击确定保存。</p></blockquote><ol start="4"><li>输入<code>ssh -T git@github.com</code>，如果如下图所示，出现你的用户名，那就成功了！</li></ol><p><img src="/2021/04/21/0-ge-ren-bo-ke-she-ji/bo-ke-da-jian/6.jpg"></p><p>备注：打开博客根目录下的<code>_config.yml</code>文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息：</p><blockquote><p>修改最后一行的配置：</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">deploy:  type: <span class="token function">git</span>  repository: https://github.com/godweiyang/godweiyang.github.io  branch: main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>repository修改为你自己的github项目地址</p></blockquote><h4 id="写文章、发布文章"><a href="#写文章、发布文章" class="headerlink" title="写文章、发布文章"></a>写文章、发布文章</h4><ol><li><p>首先在博客根目录下右键打开git bash，安装一个扩展<code>npm i hexo-deployer-git</code></p></li><li><p>然后输入<code>hexo new &quot;article title&quot;</code>，新建一篇文章</p></li><li><p>然后打开<code>D:\blog\source\_posts</code>的目录，可以发现下面多了一个<code>.md</code>文件，就是你的文章文件啦</p></li><li><p>编写完markdown文件后，根目录下输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>可以本地预览效果，最后输入<code>hexo d</code>上传到github上，这时打开你的github.io主页就能看到发布的文章啦！</p></li></ol><h4 id="绑定个人域名"><a href="#绑定个人域名" class="headerlink" title="绑定个人域名"></a>绑定个人域名</h4><p>现在默认的域名还是<code>xxx.github.io</code>，是不是很没有牌面？</p><p>想不想也像我一样弄一个专属域名呢，首先你得购买一个域名，xx云都能买，看你个人喜好了</p><blockquote><p>以我的百度云为例，如下图所示，添加两条解析记录：</p></blockquote><p><img src="/2021/04/21/0-ge-ren-bo-ke-she-ji/bo-ke-da-jian/7.jpg"></p><blockquote><p>然后打开你的github博客项目，点击<code>settings</code>，拉到下面<code>Custom domain</code>处，填上你自己的域名，保存：</p></blockquote><p><img src="/2021/04/21/0-ge-ren-bo-ke-she-ji/bo-ke-da-jian/8.jpg"></p><blockquote><p>这时候你的项目根目录应该会出现一个名为<code>CNAME</code>的文件了。如果没有的话，打开你本地博客<code>/source</code>目录，我的是<code>D:\blog\source</code>，新建<code>CNAME</code>文件，注意没有后缀。然后在里面写上你的域名，保存</p><p>最后运行<code>hexo g</code>、<code>hexo d</code>上传到github</p></blockquote><h4 id="备份博客源文件"><a href="#备份博客源文件" class="headerlink" title="备份博客源文件"></a>备份博客源文件</h4><p>有时候我们想换一台电脑继续写博客，这时候就可以将博客目录下的所有源文件都上传到github上面</p><blockquote><p>首先在github博客仓库下新建一个分支<code>hexo</code>，然后<code>git clone</code>到本地，把<code>.git</code>文件夹拿出来，放在博客根目录下</p></blockquote><blockquote><p>然后<code>git checkout hexo</code>切换到<code>hexo</code>分支，然后<code>git add .</code>，然后<code>git commit -m &quot;xxx&quot;</code>，最后<code>git push origin hexo</code>提交就行了</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 个人博客设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文章初始化设置</title>
      <link href="2021/04/20/wen-zhang-chu-shi-hua-she-zhi/"/>
      <url>2021/04/20/wen-zhang-chu-shi-hua-she-zhi/</url>
      
        <content type="html"><![CDATA[<h3 id="初始化文章的Front-matter"><a href="#初始化文章的Front-matter" class="headerlink" title="初始化文章的Front-matter"></a>初始化文章的<code>Front-matter</code></h3><p>修改”/scaffolds/post.md”</p><center>初始状态</center><pre class="line-numbers language-none"><code class="language-none">title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><center>修改后的状态</center><pre class="line-numbers language-none"><code class="language-none">title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;top: true#推荐文章（文章是否置顶）如果 top 值为 true，则会作为首页推荐文章;不置顶则将该行删除cover: flase#版本新增，表示该文章是否需要加入到首页轮播封面中;默认关闭，不需要的话删除该行，需要的话将flase改成truesummary: this is the summary #文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要keywords: this is the keywords #文章关键字，SEO 时需要;默认为文章标题tags:- new#标签项，此项待修改categories: new#分类项，此项待修改<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>备注：author项已在根_config.yml中修改</p><h3 id="引用图片"><a href="#引用图片" class="headerlink" title="引用图片"></a>引用图片</h3><p>使用 markdown 语法插入相对路径的图片，可以利用插件。设置 <code>post_asset_folder:true</code> 后，在根目录下执行：</p><pre class="line-numbers language-none"><code class="language-none">npm install https:&#x2F;&#x2F;github.com&#x2F;CodeFalling&#x2F;hexo-asset-image --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>确保在 source/_posts 下创建和 markdown 文件同名的目录，里面存放需要的图片，然后在 markdown 中插入图片：</p><pre class="line-numbers language-none"><code class="language-none">_posts    |- hexo.md    |_ hexo        |_ image.png<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">! [] (hexo&#x2F;image.png)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成的页面中图片引用路径</p><pre class="line-numbers language-none"><code class="language-none">&lt;img src&#x3D;&quot;&#x2F;2016&#x2F;11&#x2F;25&#x2F;hexo&#x2F;image.png&quot; alt&#x3D;&quot;hexo image&quot;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>至此，用 markdown 完美实现本地图片插入</p>]]></content>
      
      
      <categories>
          
          <category> 个人博客设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超链接居中</title>
      <link href="2021/04/20/0-ri-chang-xue-xi/chao-lian-jie-ju-zhong/"/>
      <url>2021/04/20/0-ri-chang-xue-xi/chao-lian-jie-ju-zhong/</url>
      
        <content type="html"><![CDATA[<p>*markdown本身不支持，但可以使用html：</p><ol><li>方法一：</li></ol><pre class="line-numbers language-none"><code class="language-none">&lt;center&gt;[链接名称](链接地址)&lt;&#x2F;center&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>示例：</p></blockquote><center>[链接名称](链接地址)</center><ol start="2"><li>方法二：</li></ol><pre class="line-numbers language-none"><code class="language-none">&lt;center&gt;&lt;a href&#x3D;链接地址&gt;链接名称&lt;&#x2F;a&gt;&lt;&#x2F;center&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>示例：</p></blockquote><center><a href="链接地址">链接名称</a></center><ol start="3"><li>方法三：</li></ol><pre class="line-numbers language-none"><code class="language-none">&lt;div align&#x3D;center &gt;&lt;a href&#x3D;链接地址&gt;链接名称&lt;&#x2F;a&gt;&lt;&#x2F;div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>示例：</p></blockquote><div align="center"><a href="链接地址">链接名称</a></div><p>备注：方法一当有回车符时可能会失效</p>]]></content>
      
      
      <categories>
          
          <category> 日常学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown编写技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文章Front-matter介绍</title>
      <link href="2021/04/20/0-ge-ren-bo-ke-she-ji/wen-zhang-front-matter-jie-shao/"/>
      <url>2021/04/20/0-ge-ren-bo-ke-she-ji/wen-zhang-front-matter-jie-shao/</url>
      
        <content type="html"><![CDATA[<center> 详情请见官方说明文档：<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">hexo-theme-matery</a> </center><hr><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><blockquote><p><strong>注意</strong>:</p><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章的特色图<strong>各有特色</strong>。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="http://tool.oschina.net/encrypt?type=2">开源中国在线工具</a>、<a href="http://encode.chahuo.com/">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx">站长工具</a>。</li><li>您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则</li></ol></blockquote><p>以下为文章的 <code>Front-matter</code> 示例。</p><h3 id="最简示例"><a href="#最简示例" class="headerlink" title="最简示例"></a>最简示例</h3><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="最全示例"><a href="#最全示例" class="headerlink" title="最全示例"></a>最全示例</h3><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;top: true#推荐文章（文章是否置顶）如果 top 值为 true，则会作为首页推荐文章;不置顶则将该行删除cover: flase#版本新增，表示该文章是否需要加入到首页轮播封面中;默认关闭，不需要的话删除该行，需要的话将flase改成truesummary: this is the summary #文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要tags:<span class="token list punctuation">-</span> new#标签项，此项待修改categories: new#分类项，此项待修改<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 个人博客设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编写和发布新文章</title>
      <link href="2021/04/20/bian-xie-he-fa-bu-xin-wen-zhang/"/>
      <url>2021/04/20/bian-xie-he-fa-bu-xin-wen-zhang/</url>
      
        <content type="html"><![CDATA[<h3 id="新建文章的方法"><a href="#新建文章的方法" class="headerlink" title="新建文章的方法"></a>新建文章的方法</h3><h5 id="方法一：进入博客目录，在-source-posts-文件夹下直接建立一个-md文件"><a href="#方法一：进入博客目录，在-source-posts-文件夹下直接建立一个-md文件" class="headerlink" title="方法一：进入博客目录，在 /source/_posts 文件夹下直接建立一个.md文件"></a>方法一：进入博客目录，在 /source/_posts 文件夹下直接建立一个.md文件</h5><h5 id="方法二：进入博客目录，右键选择-“-Git-Bash-Here-“-进入命令窗口，输入下面代码"><a href="#方法二：进入博客目录，右键选择-“-Git-Bash-Here-“-进入命令窗口，输入下面代码" class="headerlink" title="方法二：进入博客目录，右键选择 “ Git Bash Here “ 进入命令窗口，输入下面代码:"></a>方法二：进入博客目录，右键选择 “ Git Bash Here “ 进入命令窗口，输入下面代码:</h5><pre class="line-numbers language-none"><code class="language-none">hexo new &quot;新建文章名称&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时，在” /source/_posts”文件夹里便有了”新建文章名称.md”文件。</p><h3 id="发布新建文章"><a href="#发布新建文章" class="headerlink" title="发布新建文章"></a>发布新建文章</h3><p>在该博客项目文件夹下右键选择 “ Git Bash Here “ 进入命令窗口，输入如下代码：</p><pre class="line-numbers language-none"><code class="language-none">hexo g -d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意事项：</p><ul><li><p>部署到GitHub时，可能因为网速、被墙等原因，需要多次运行”hexo deploy”；也可以运行”hexo clean”后在运行上述代码</p></li><li><p>.md文件不要用记事本打开，建议使用具有markdown语法的程序打开</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 个人博客设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主题修改</title>
      <link href="2021/04/20/0-ge-ren-bo-ke-she-ji/zhu-ti-xiu-gai/"/>
      <url>2021/04/20/0-ge-ren-bo-ke-she-ji/zhu-ti-xiu-gai/</url>
      
        <content type="html"><![CDATA[<h3 id="挑个好看的主题"><a href="#挑个好看的主题" class="headerlink" title="挑个好看的主题"></a>挑个好看的主题</h3><p>全凭个人喜好，在网上能找到很多好看的主题供你下载</p><p>知乎话题：<a href="https://www.zhihu.com/question/24422335">有哪些好看的 Hexo 主题？</a></p><p>Hexo官方：<a href="https://hexo.io/themes/">Themes</a></p><h3 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h3><p>用git bash，进入到博客的本地目录中：</p><pre class="line-numbers language-none"><code class="language-none">$ cd 你的博客目录路径<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2021/04/20/0-ge-ren-bo-ke-she-ji/zhu-ti-xiu-gai/1460000012780333"></p><p>然后使用clone的方法将想要的主题下载下来：（这里选用的是NexT主题）</p><pre class="line-numbers language-none"><code class="language-none">$ git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="修改配置文件，安装"><a href="#修改配置文件，安装" class="headerlink" title="修改配置文件，安装"></a>修改配置文件，安装</h3><p>git克隆完成后，打开当前目录下的“_config.yml”配置文件</p><p>找到theme的配置选项，一般在文件的最后</p><p>之后，将theme选项配置为我们新下载好的next主题即可（“：”冒号之后空格不可少）</p><p><img src="/2021/04/20/0-ge-ren-bo-ke-she-ji/zhu-ti-xiu-gai/1460000012780334"></p><h3 id="调试，发布"><a href="#调试，发布" class="headerlink" title="调试，发布"></a>调试，发布</h3><p>回到git bash，输入调试命令：</p><pre class="line-numbers language-none"><code class="language-none">$ hexo server --debug<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如图，在浏览器中输入localhost:4000查看：</p><p><img src="/2021/04/20/0-ge-ren-bo-ke-she-ji/zhu-ti-xiu-gai/1460000012780335"></p><p>在本地查看无误之后，输入生成和发布命令,就可已将新主题发布到自己的博客网站上了</p><pre class="line-numbers language-none"><code class="language-none">$ hexo g -d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>*如出现缓存引起的异常，可以在生成命令前执行清除缓存命令：</p><pre class="line-numbers language-none"><code class="language-none">$ hexo clean<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h3><p>做完这些之后，就可以打开你的博客网站，查看新更换的主题效果！</p>]]></content>
      
      
      <categories>
          
          <category> 个人博客设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题修改 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
